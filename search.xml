<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建自己的github博客</title>
    <url>/2018/06/25/build-hexo/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="1-什么是-Hexo"><a href="#1-什么是-Hexo" class="headerlink" title="1 什么是 Hexo"></a>1 什么是 Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h2 id="2-开始搭建博客"><a href="#2-开始搭建博客" class="headerlink" title="2 开始搭建博客"></a>2 开始搭建博客</h2><h3 id="2-1-前提"><a href="#2-1-前提" class="headerlink" title="2.1 前提"></a>2.1 前提</h3><p>电脑安装好 Node 和 Git</p>
<h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><p>直接用 npm 全局安装（嫌慢的话就用 cnpm 吧）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-搭建博客网站"><a href="#2-3-搭建博客网站" class="headerlink" title="2.3 搭建博客网站"></a>2.3 搭建博客网站</h3><p>完成 Hexo 的安装之后，就可以执行下面的命令，在指定文件夹内生成系列的网站文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init folderName</span><br><span class="line">cd folderName</span><br><span class="line">npm install // 安装依赖</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong><br>好像新版本的 hexo-cli 在初始化项目的时候会自动安装依赖，如下图<br><img src="http://img.cdn.lijiayuan.top//hexo%E6%90%AD%E5%BB%BA/hexo-build/build.png" alt="image"></p>
<p>鉴于网络因素，直接用npm 安装依赖实在是太慢了，想快一点的同学看到他在装依赖的时候，不要怂，直接就是 Ctrl+C 断了它进程，然后自己进入文件夹用 cnpm install 装依赖。</p>
<h2 id="3-查看效果"><a href="#3-查看效果" class="headerlink" title="3 查看效果"></a>3 查看效果</h2><p>运行下面代码，开启博客<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></p>
<p>最后打开4000端口就可以看到自己的博客网站啦<br><img src="http://img.cdn.lijiayuan.top//hexo%E6%90%AD%E5%BB%BA/hexo-build/index.png" alt="image"></p>
<h2 id="4-项目结构"><a href="#4-项目结构" class="headerlink" title="4 项目结构"></a>4 项目结构</h2><p>新建个项目之后，指定的文件夹的目录如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></p>
<h3 id="4-1-config-yml"><a href="#4-1-config-yml" class="headerlink" title="4.1 _config.yml"></a>4.1 _config.yml</h3><p>网站的 <a href="https://note.youdao.com/" target="_blank" rel="noopener">配置</a> 信息，小伙伴们可以在这边配置大部分的参数。</p>
<h3 id="4-2-package-json"><a href="#4-2-package-json" class="headerlink" title="4.2 package.json"></a>4.2 package.json</h3><p>这个就不说了，就是这个项目的信息了。</p>
<h3 id="4-3-scaffold-文件夹"><a href="#4-3-scaffold-文件夹" class="headerlink" title="4.3 scaffold 文件夹"></a>4.3 scaffold 文件夹</h3><p><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">模板</a> 文件夹。当我们新建文章的时候，Hexo 会根据 scaffold 来建议文件</p>
<p>Hexo 的模板是指在新建的 markdown 文件中默认填充的内容。例如，如果我们修改 scaffold/post.md 中的 Front-matter 内容，那么没一次新建一篇文章都会包含这个修改</p>
<h3 id="4-4-source-文件夹"><a href="#4-4-source-文件夹" class="headerlink" title="4.4 source 文件夹"></a>4.4 source 文件夹</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code>(下划线)的文件/文件夹和隐藏的文件将会被忽略（意思就是在这里不要以下划线开头去命名新建的文件/文件夹）。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p>
<h3 id="4-5-themes-文件夹"><a href="#4-5-themes-文件夹" class="headerlink" title="4.5 themes 文件夹"></a>4.5 themes 文件夹</h3><p><a href="https://hexo.io/zh-cn/docs/themes" target="_blank" rel="noopener">主题</a> 文件夹。Hexo会根据主题来生成静态页面。这里的话，推荐一个主题吧。 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a> 我也不知道为啥要推荐它，反正就瞅他顺眼+多人用+文档全吧。不过想用其他也随便吧，反正写博客嘛，咱们还是多关注内容，外观的话，顺眼舒服就行了。</p>
<h2 id="5-开始写博客"><a href="#5-开始写博客" class="headerlink" title="5 开始写博客"></a>5 开始写博客</h2><p>这个就很简单了，三步走直接搞定啦。</p>
<ol>
<li>直接找个能写 markdown 的工具就开始写我们的博客了。这里的话我推荐用一下 『有道云笔记』吧（『有道云笔记』的工作人员看到了麻烦给点广告费啊~(@^_^@)~），平常就可以在上面做做笔记，写写博客，写完直接导出来一个 markdown 文件。当然其他编辑器一般也是可以方便的写 markdown 的。</li>
</ol>
<p>『<strong>注意</strong>：这里有道云笔记有个坑点，不是会员不给 markdown 引入本地的图片，如果想用图片的话只能引入网上外链，这时候就要使用图床了，这边推荐用一下『七牛云』吧，有免费 10 G 的空间可以用。（『七牛云』的小姐姐看到麻烦给我叫个鸡腿），里面还有一些使用技巧，这里就不说了，大家自己再去百度玩一下吧。』</p>
<ol start="2">
<li><p>将写完的 markdowm 文件直接丢到 <code>source/_posts</code> 文件夹内，但是为了方便分类和管理自己的文章，在导出的 markdown 文件加入下面这些东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">#文章标题</span><br><span class="line">title: flex布局</span><br><span class="line">#文章发布时间</span><br><span class="line">date: 2018-08-26 21:37:55</span><br><span class="line">#文章的标签，可多写几个</span><br><span class="line">tags: 前端布局</span><br><span class="line">#文章分类</span><br><span class="line">categories: flex</span><br><span class="line">---</span><br><span class="line">#下面就是我们的文章正文啦</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面然后就可以在我们的站点中看到我们新增的博客啦。</p>
</li>
</ol>
<h2 id="6-后续"><a href="#6-后续" class="headerlink" title="6 后续"></a>6 后续</h2><p>讲到这里，我们的博客已经搭建起来的了，如果还有不明白的东西可以去翻翻 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 中文文档</a>。最后咧，虽然博客搭起来了，也能写了，但是不自己配置一下的话，还是有点简陋的，所以下次就来讲讲如何去配置我们的 Hexo 博客吧。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 自定义指令实现点击元素外触发事件</title>
    <url>/2018/11/25/custom-directive-clickoutside/</url>
    <content><![CDATA[<p><strong>前言</strong> 最近搞了毕设，需要实现一个场景，点击一块区域，弹出一个编辑区域，点击页面的其他地方的时候，这个编辑区域就隐藏，本想想之前写模态框一样写个方法的时候，突然<br><img src="http://img.cdn.lijiayuan.top/custom-directive/timg.jfif" alt="image"><br>觉得可以尝试用 vue 相关的东西优雅的解决这个事情，然后就学了下面的自定义指令了。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>既然要用 Vue 的自定义指令，那么肯定要了解一下 Vue 自定义指令的相关知识啦，关于这部分的内容，看我之前写过的<a href="https://lijiayuan.top/2018/11/26/vue-custom-directive/" target="_blank" rel="noopener">《Vue 自定义指令》</a>或者直接看<a href="https://cn.vuejs.org/v2/guide/custom-directive.html#ad" target="_blank" rel="noopener">官方文档</a>就可以啦，这里我就不再多讲了。</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>这个按照我之前写模态框的经验，我的做法是给 document 绑定一个点击事件，然后判断触发点击事件的那个元素是不是模态框所在的<code>目标区域</code>，如果不是，那么就触发隐藏事件。看一下代码吧<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).mouseup(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _con = $(<span class="string">' 目标区域 '</span>);   <span class="comment">// 设置目标区域</span></span><br><span class="line">  <span class="keyword">if</span>(!_con.is(e.target))&#123; <span class="comment">// 判断是不是目标区域</span></span><br><span class="line">    some code...   <span class="comment">// 功能代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>有了思路，实现起来就简单了。就直接放定义的代码啦<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clickOutside = &#123;</span><br><span class="line">  <span class="comment">// 初始化指令</span></span><br><span class="line">  bind(el, binding, vnode) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clickHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这里判断点击的元素是否是本身，是本身，则返回</span></span><br><span class="line">      <span class="keyword">if</span> (el.contains(e.target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断指令中是否绑定了函数</span></span><br><span class="line">      <span class="keyword">if</span> (binding.expression) &#123;</span><br><span class="line">        <span class="comment">// 如果绑定了函数 则调用那个函数，此处binding.value就是handleClose方法</span></span><br><span class="line">        binding.value(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给当前元素绑定个私有变量，方便在unbind中可以解除事件监听</span></span><br><span class="line">    el.__vueClickOutside__ = clickHandler;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, clickHandler);</span><br><span class="line">  &#125;,</span><br><span class="line">  update() &#123;&#125;,</span><br><span class="line">  unbind(el, binding) &#123;</span><br><span class="line">    <span class="comment">// 解除事件监听</span></span><br><span class="line">    <span class="built_in">document</span>.removeEventListener(<span class="string">'click'</span>, el.__vueClickOutside__);</span><br><span class="line">    <span class="keyword">delete</span> el.__vueClickOutside__;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">directives: &#123;clickOutside&#125;,</span><br></pre></td></tr></table></figure></p>
<p>接下来就可以就可以在组件内直接使用啦<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-click-outside</span>=<span class="string">"closeDialog"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我实现的效果<br><img src="http://img.cdn.lijiayuan.top/click-outside/test.gif" alt="image"></p>
<p>然后关于这个点击元素外触发某个事件，如果还有啥其他优雅的方式的话，下面留言分享一下哈。</p>
]]></content>
  </entry>
  <entry>
    <title>JS 中数组对象的方法</title>
    <url>/2018/12/17/arr-fn/</url>
    <content><![CDATA[<p><strong>前言</strong> 在 JS 中我们数组用的是比较多的了，它自带了很多方法可以用，省去了我们时间，特别是 ES6 当中对数组的扩展让数组具有了更强大的功能，为了以后使用数组的时候能够充分发挥数组的特性，在这里对数组的方法进行一次汇总吧。</p>
<p><strong>说明</strong> 标题后的标识 <code>*</code> 是说明该方法会改变原数组 </p>
<h2 id="对数组元素的操作"><a href="#对数组元素的操作" class="headerlink" title="对数组元素的操作"></a>对数组元素的操作</h2><h3 id="push-amp-pop"><a href="#push-amp-pop" class="headerlink" title="push() &amp; pop() *"></a>push() &amp; pop() *</h3><p>push() 向数组的末尾添加一个或更多元素（就是传进去的参数），并返回新的长度。</p>
<p>pop() 删除并返回数组的最后一个元素。</p>
<p>具体效果看代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.push(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 4 arr的长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1,2,3,5] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res2 = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// 5 移除的数组项</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
<h3 id="shift-amp-unshift"><a href="#shift-amp-unshift" class="headerlink" title="shift() &amp; unshift() *"></a>shift() &amp; unshift() *</h3><p>shift() 删除并返回数组的第一个元素</p>
<p>unshift() 向数组的头部添加一个或者多个元素（传入的参数），并返回新的长度。</p>
<p>具体效果看代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> res1 = arr.shift();</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 1 移除的数组项</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2,3] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res2 = arr.unshift(<span class="number">5</span>,<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// 4 数组新长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [5,7,2,3]</span></span><br></pre></td></tr></table></figure>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>这个方法是从某个已有的数组返回选定的元素。一般带两参数 par1 和 par2，方法返回原数组 [par1, par2) 区间内的值组成的新数组。如果只有一个参数 par1 的话，就返回原数组 [par1，数组尾] 区间内的值组成的新数组。<br>具体看代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// [2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">1</span>)); <span class="comment">// [2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice() *"></a>splice() *</h3><p>这个方法有点复杂了，他是从原数组中删除/添加项目,并返回删除的项目。具体是删除还是添加，看参数决定，它至少需要两个参数 index，deleteCount，分别指代要开始删除/添加项目的下标 index 和要删除的项目的个数 deleteCount，后面如果其他参数通通就是要加入 index 位置后面的项目了。看代码就知道一切了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 删除操做</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">0</span>,<span class="number">2</span>)); <span class="comment">// [0,1] 从 下标 0 的位置开始删除两个元素，并返回。  </span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2,3,4] 删除后就剩它仨了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加操作</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)); <span class="comment">// [] 第二个参数 0 ，那就没有删除啥元素咯，然后在下标 1 的位置开始插入</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2, 5, 6, 7, 3, 4] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换操作</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">// [5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2, 2, 6, 7, 3, 4 ]</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法是很强大的，可以用它来实现数组元素的删除，替换，添加的操作，看上面代码就知道啦。</p>
<h2 id="整个数组的大操作-转换-amp-拼接-amp-排序-amp-倒置"><a href="#整个数组的大操作-转换-amp-拼接-amp-排序-amp-倒置" class="headerlink" title="整个数组的大操作(转换&amp;拼接&amp;排序&amp;倒置)"></a>整个数组的大操作(转换&amp;拼接&amp;排序&amp;倒置)</h2><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>这个方法是将数组转换为字符串，数组元素间用传进去的参数（ 没有参数就用<code>,</code>） 分隔<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">'|'</span>)); <span class="comment">// 1|2|3|4|5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.join()); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>这个方法用于拼接两个数组并返回一个新的数组。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.concat([<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])); <span class="comment">// [ 1, 2, 3, 4, 5, 6, 7, 8 ]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort() *"></a>sort() *</h3><p>这个就不用讲了吧，排序，不过默认的排序方法是把数字当成字符串来排序的，所以就会有了下面代码中的问题，也有了我们关于排序的重写。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">22</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 1, 13, 22, 4, 5 ] 因为 22 的第一个字符是 2 比 4 小，所以 22 比 4 小。。。 </span></span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">val1,val2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val1-val2;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 13, 22, 4, 5 ]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse() *"></a>reverse() *</h3><p>如其名，倒置数组的元素。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">22</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 5, 4, 13, 22, 1 ]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="toString-amp-toLocaleString-amp-valueOf"><a href="#toString-amp-toLocaleString-amp-valueOf" class="headerlink" title="toString() &amp; toLocaleString() &amp; valueOf()"></a>toString() &amp; toLocaleString() &amp; valueOf()</h3><p>这三个方法，是个对象就会有，数组对象也不例外，也顺便写出来看看吧，具体啥效果，看代码吧。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">22</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()); <span class="comment">// 1,22,13,4,5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toLocaleString()); <span class="comment">// 1,22,13,4,5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.valueOf()); <span class="comment">// [ 1, 22, 13, 4, 5 ]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="数组位置方法"><a href="#数组位置方法" class="headerlink" title="数组位置方法"></a>数组位置方法</h2><h3 id="indexOf-amp-lastIndexOf"><a href="#indexOf-amp-lastIndexOf" class="headerlink" title="indexOf() &amp; lastIndexOf()"></a>indexOf() &amp; lastIndexOf()</h3><p>这个用于查找数组中的元素，找到后返回元素的下标，找不到的话就返回 -1。两个方法都是一样的，只不过一个从头到尾找，一个从尾到头找<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">22</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">13</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">22</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">44</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><h3 id="every-amp-some"><a href="#every-amp-some" class="headerlink" title="every() &amp; some()"></a>every() &amp; some()</h3><p>every() 对数组每一项运行一个函数，如果该函数对每一项都返回 true，则整体返回 true</p>
<p>some() 这个和上面一样啦，不过这个只要有一项是 true，整体就返回 true</p>
<p>具体看代码啦<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>这个是对数组中的每一项运行给定函数，没有返回值。看代码吧<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">// 打印整个数组</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>这个方法是对数组的每一项运行给定函数，返回每一项返回结果组成的数组。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item+<span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [ 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>这个方法是对数组的每一项运行给定函数，返回该函数会返回为 true 的数组项组成的新数组。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [ 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="ES6-扩展的数组方法"><a href="#ES6-扩展的数组方法" class="headerlink" title="ES6 扩展的数组方法"></a>ES6 扩展的数组方法</h2><h3 id="Array-from-对象转为数组"><a href="#Array-from-对象转为数组" class="headerlink" title="Array.from() 对象转为数组"></a>Array.from() 对象转为数组</h3><p>这个方法用于将两类对象转为真正的数组，分别是<code>类数组对象</code>和<code>可遍历对象</code>（包括 ES6 新增的数据结构 Set 和 Map）用法就看代码吧<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrLike = &#123;</span><br><span class="line">  <span class="string">'0'</span>:<span class="string">'1'</span>,</span><br><span class="line">  <span class="string">'1'</span>:<span class="string">'2'</span>,</span><br><span class="line">  <span class="string">'2'</span>:<span class="string">'2'</span>,</span><br><span class="line">  length:<span class="string">'3'</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from( arrLike);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ '1', '2', '2' ]</span></span><br></pre></td></tr></table></figure></p>
<p>在实际应用中，DOM 操作返回的 NodeList 集合就是一个类数组对象。</p>
<h3 id="Array-of-值转为数组"><a href="#Array-of-值转为数组" class="headerlink" title="Array.of() 值转为数组"></a>Array.of() 值转为数组</h3><p>这个是用来替代 Array() 或 new Array()的，为啥要替换，来段代码感受下就知道了<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>()); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>(<span class="number">3</span>)); <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of()); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="literal">undefined</span>)); <span class="comment">// [undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">3</span>)); <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure></p>
<p>看出门道了吧，Array() 会因为参数不同会有不同的效果，而 Array.of() 就不会存在这种问题啦。</p>
<h3 id="copyWithin-数组内成员复制"><a href="#copyWithin-数组内成员复制" class="headerlink" title="copyWithin() 数组内成员复制 *"></a>copyWithin() 数组内成员复制 *</h3><p>这个方法有点迷，暂时不知道是用来干啥的，但是也记一下它能干啥，没准以后就用上了。<br>它的话是在当前数组内部将指定位置的成员复制到其他位置（覆盖掉原有成员），然后返回该数组。他有下面三个参数</p>
<ul>
<li>target（必选）：从该位置开始替换数据</li>
<li>start（可选）：从该位置读取数据，默认 0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认是数组长度，如果为负值，表示倒数。</li>
</ul>
<p>具体有啥效果就看代码吧<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 从下标 0 开始换 下标 1（也就是 2）开始的数据，一直替换到 下标 4 前（也就是到 arr[3] 结束）</span></span><br><span class="line"><span class="comment">// 人话说就是 arr[0] 到 arr[4-2] 的值被 arr[1] 到 arr[4-1] 的值替换掉</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>)); <span class="comment">// [ 2, 3, 6, 6, 5 ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr2 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>)); <span class="comment">// [ 0, 3, 4, 5, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="find-amp-findIndex-查找数组元素"><a href="#find-amp-findIndex-查找数组元素" class="headerlink" title="find() &amp; findIndex() 查找数组元素"></a>find() &amp; findIndex() 查找数组元素</h3><p> find() 用于查找符合第一个符合条件的数组成员，并将其返回。如果没有的话，就返回 undefined。</p>
<p> findIndex() 和上面一样，不过他返回的是那个符合条件的数组的下标。</p>
<p> 啥效果就看代码吧<br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr.find(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">4</span>;</span><br><span class="line">&#125;)  <span class="comment">// 返回数值 5 </span></span><br><span class="line"></span><br><span class="line">arr.findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">4</span>;</span><br><span class="line">&#125;) <span class="comment">// 返回下标 4</span></span><br></pre></td></tr></table></figure></p>
<h3 id="fill-数组填充"><a href="#fill-数组填充" class="headerlink" title="fill() 数组填充"></a>fill() 数组填充</h3><p> 这个方法是用给定值填充一个数组。初始化数组的时候可以用到。它有三个参数：<br> value 填充数组的值<br> start 填充的起始位置<br> end 填充的结束位置<br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="string">'a'</span>) <span class="comment">// [ 'a', 'a', 'a' ]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].fill(<span class="string">'a'</span>, <span class="number">2</span>, <span class="number">4</span>) <span class="comment">// [ 1, 2, 'a', 'a', 5 ]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="entries-amp-key-amp-values-遍历数组"><a href="#entries-amp-key-amp-values-遍历数组" class="headerlink" title="entries() &amp; key() &amp; values() 遍历数组"></a>entries() &amp; key() &amp; values() 遍历数组</h3><p>这三个都会返回一个迭代器对象，可以用 for…of 循环遍历，区别是，entries() 遍历键值对，keys() 遍历键名，values() 遍历键值，啥效果看代码。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, ele] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, ele);</span><br><span class="line">&#125; <span class="comment">// 0 1  1 2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125; <span class="comment">// 0  1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ele <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ele);</span><br><span class="line">&#125; <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="includes-判断数组是否有某值"><a href="#includes-判断数组是否有某值" class="headerlink" title="includes() 判断数组是否有某值"></a>includes() 判断数组是否有某值</h3><p>这个方法如其名，用于判断数组内是否有某个值，如果有，返回 true，没有，返回 false。他如果有第二个参数的话，那么第二个参数表示开始搜索的位置。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">arr.includes(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">arr.includes(<span class="number">1</span>,<span class="number">5</span>) <span class="comment">// false 从下标 5 开始搜没有 1</span></span><br></pre></td></tr></table></figure></p>
<p>关于数组的的方法，就总结道这边了，如果还有遗漏或者错误的地方的话，就麻烦下下面评论修正啦。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>小红帽学前端教程（0） 开头瞎BB</title>
    <url>/2019/08/17/cxqd-0-bb/</url>
    <content><![CDATA[<p>大家好，我是小红帽，一个前端小辣鸡。为了能够更好学习整理自己所学的前端知识，所以我打算不要脸的写一个初级前端学习的系列文章，同时也算作为一个分享和交流吧。至于为啥是初级前端学习咧，我想说</p>
<blockquote>
<p>我也想写个中高级前端的进阶教程啊，奈何我只是一个小辣鸡，写不了哇。</p>
</blockquote>
<h2 id="1-What"><a href="#1-What" class="headerlink" title="1 What"></a>1 What</h2><p>学习一个东西前，我们先解决一个「what」的问题，啥是前端咧？前端开发是干啥的？</p>
<p>简单粗暴来讲，前端就是所有呈现在用户面前与用户进行交互的东西，一个电脑网页，一个手机 APP 界面，一个游戏的界面等等等。差不多的意思就是你所看到的东西就是互联网的前端。</p>
<p>要是原始一点讲，就是一个写网页的切图仔就对了。当然现在时代不一样了，前端不在是之前那个写网页的切图仔了，这点你到后面就会发现了。不过我们基础还是和之前一样，是 HTML（结构），CSS（表现），JavaScript（行为）这三样技术。</p>
<p>那么这三个东西是啥啊？我们拿人作为例子。</p>
<h3 id="1-1-HTML"><a href="#1-1-HTML" class="headerlink" title="1.1 HTML"></a>1.1 HTML</h3><p>首先是 HTML（超文本标记语言），HTML 是一个页面的基本结构，定下了整个页面的页面骨架。<br>就类似我们人的骨架吧，如下图</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1/bone.jpg" alt="image"></p>
<h3 id="1-2-CSS"><a href="#1-2-CSS" class="headerlink" title="1.2 CSS"></a>1.2 CSS</h3><p>其次是 CSS（层叠样式表），如其名，样式表。加样式的变好看的。</p>
<p>我们前面只有这么一个骨架太吓人了，我们要我们的人（页面）好看一点，咋办，当然是用我们的 CSS 啦，它的话就是用来给 HTML 添加一层样式，进行美化的。我们用 CSS 给他一身好看的皮囊啦，当然根据不同产品的审美需求，我们可以有各种「好看的」皮囊。</p>
<p>有这样的</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1/linger.jpg" alt="image"></p>
<p>当然还有这样的</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1/ruhua.jpg" alt="image"></p>
<h3 id="1-3-JavaScript"><a href="#1-3-JavaScript" class="headerlink" title="1.3 JavaScript"></a>1.3 JavaScript</h3><p>最后就是我们的 JavaScript 了，JS 是行为层，最简单的说法就是给予网页动态交互的行为。</p>
<p>就像我们人一样，长的再好，穿的再好看，结果是个植物人，那其他人咋想会跟你打交道咧，所以就要加点动作啦。这样更富有层次感。你看下面帅如发哥，动态图看起来是不是比静态的，更帅更富有层次咧。</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1/fage.jpg" alt="image"></p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1/d-fage.gif" alt="image"></p>
<p>这三个就是前端三剑客的，也就是我们前端开发要学的东西。后面我们学啥框架，啥新技术啊，搞来搞去都是这三个家伙。</p>
<h2 id="2-Why"><a href="#2-Why" class="headerlink" title="2 Why"></a>2 Why</h2><p>为啥要学前端咧，这个问题很重要，因为这是一条不归路，没有一个可以说服自己的理由，要想坚持下去还是有点难度的。在此给大家准备了几个理（jie）由（kou）</p>
<ul>
<li>我喜欢开发，并且前端开发是一种看得着摸得到的开发，你写啥电脑就给你搞出个啥效果，很有趣。</li>
<li>前端开发也是软件开发，以后工作时候的工资还是很诱人的。</li>
<li>前端开发简单易上手。内心OS：算是个理由吧，前端入门的确很简单，但是学到后面你肯定会对我说「我信你个鬼！你个糟老头子坏得很！」</li>
<li>没有理由，劳资就是要学，爱咋咋地。</li>
</ul>
<h2 id="3-How"><a href="#3-How" class="headerlink" title="3 How"></a>3 How</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>这个就是我们本次系列文章的中心了，我们要这么去学前端呢。我们前面看到前端开发主要就是用 HTML + CSS + JS。所以我们的前端学习也是围绕这三个东西进行的。这边的话，我自己瞎分了三个部分：<code>基础知识</code>，<code>入门知识</code>，<code>初级知识</code>。其中基础知识必须是要先学好的，入门知识和初级知识也建议耐着性子逐步来，当然你交叉来学问题也不大。</p>
<p>然后前端开发嘛，也是编程，学编程，就一点，多敲代码！甭管啥知识，代码敲多了，很多前面不懂的后面敲敲就懂了。切忌只看不敲啊。咱这毕竟是偏应用的学科。大佬请忽视这一段</p>
<h3 id="3-2-基础知识"><a href="#3-2-基础知识" class="headerlink" title="3.2 基础知识"></a>3.2 基础知识</h3><p>这一块也可以叫做基础常识吧，因为我们要学的就是最最基本的 HTML + CSS 的基础知识，知道这两个家伙怎么用，怎么去写出一个网页来，怎么去布局一个网页，写出一个带样式的网页来。最后还要知道 JavaScript 这门语言最最基本的语法操作，和用 JavaScript 进行简单的 DOM 操作。</p>
<p>这一块知识的话，学到后面，知道这些东西这么用，能写几个简单的页面就算了。（例如一个简单的登陆框页面）也不要求你看到一个网页你就能自己把他实现出来，虽然这个是可以的，但是过程会比较痛苦。就不要磨灭你的信心啦。但是还是要好好学习这一段的知识，不然你后面你还得回来学！想想就知道啦。你站都站不稳，还想学跑步？</p>
<h3 id="3-3-入门前端知识"><a href="#3-3-入门前端知识" class="headerlink" title="3.3 入门前端知识"></a>3.3 入门前端知识</h3><p>这一块的话，就要学一下新的 HTML5、CSS3 的知识,了解他们的新特性，最好的话找本专门介绍 JavaScript 的书或者教程系统的学一下 JS。再学一下 JQuery 的用法，经历过前面刀耕火种的开发，你会发现 JQ 的出现是多么神圣的一件事情（当然后面你就不会这么觉得了）。除却这些基本的知识，你也可以开始偷懒去了解一下如 bootstrap 的 UI 框架和其他的一些 JQ 插件来协助你开发了。</p>
<p>经历了这一阶段的学习，如果学的好的话，那么恭喜你已经入门前端了，现在的你应该可以达到别人丢给你一个页面，你可以自己手撸或者利用其他工具偷懒去实现那个网页出来的水平啦。</p>
<h3 id="3-4-初级前端知识"><a href="#3-4-初级前端知识" class="headerlink" title="3.4 初级前端知识"></a>3.4 初级前端知识</h3><p>这一块的话，咱们首先学一下 ES6 的新特性，建议买本阮一峰老师的《ES6标准入门》来看。然后就可以学习前端三大框架了，这边的话我学的是 Vue，因为简单易上手，文档齐全，国内生态完善。当然你要学其他也是可以，不过个人感觉 react 和 Vue 后面是主流技能，Angular 在国内感觉比较小众，并且听说学习成本比较大，所以暂时不推荐大家作为第一学习的前端开发框架。</p>
<p>除却学框架，我们还要了解一点后台的知识，这样我们也好跟后台的同事打交道。这边就会让大家简单了解一下 Node 的一点基础知识，不需要了解太多，知道个意思就差不多了，了解一个完整的项目是怎么运作的。并且其实你前面 JS 学好了，其实 Node 还是挺容易上手的。在这个学习的过程顺带了解一点计算机网络的知识和浏览器的一些知识咯。现在粗略学习，后面提升的时候就要认真学学咯。</p>
<p>此外，以后的开发我们不是自己一个人玩玩就可以的了，所以我们必须要学会一点 Git 操作，使用 Git 进行版本迭代和团队协作开发。顺便了解一下全球最大的同性交友网站 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></p>
<p>这部分的知识个人感觉就是由个人的学习转向真正的项目开发的过程，学完这些，至少你自己能手把手搭建一个完整的前端项目（能和后台交互的那种哦），然后对于前端开发的工程化，你自己应该也要有自己的一份心得。简单来说就是你现在已经是个初级的前端开发工程师了，你知道一个完整的项目开发是怎么一回事，也知道自己在一个项目开发中该干啥，该怎么干了。</p>
<p>看起来好像这部分知识很复杂，其实上手也贼快的，基本你自己手撸一个项目，这块知识你基本就有一个感觉在了。感觉有了，学起来就快了。也不会那么迷茫了。</p>
<p>下面的话，我自个简单粗暴的搞了一张思维导图，比较简单，因为太复杂的我也懒得画，并且还容易摧残我们小辣鸡的自信心。就随便搞搞咯.我前面也写了，这是一个初级前端的教程，这里面的知识体系虽然不是一个完整的前端知识体系，但建立起这样的知识体系的时候你就差不多是个初级前端工程师了，后面的知识点就自个再去完善和补充了。如果自己想在这边的基础上修改成自己的知识体系的话，可以到<a href="http://naotu.baidu.com/file/ebc223651a61a8199a7974dcc686550f?token=8f60ad47abc51b63" target="_blank" rel="noopener">百度脑图</a>这边修改然后保存到你本地那边。</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1/base-no.png" alt="image"><br><img src="http://img.cdn.lijiayuan.top/cxqd/1/init-no.png" alt="image"><br><img src="http://img.cdn.lijiayuan.top/cxqd/1/pri-no.png" alt="image"></p>
<h2 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h2><p>看到最后，是不是发现我好像也没写啥玩意，这就对了。前端入门的话，感觉还真的没啥也没那么复杂。要学前端的话，不要怕，代码敲多了，入门很简单的，就是后面提升的时候头有点凉而已。</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/touliang.jpg" alt="image"></p>
<p>后面的教程的话，我大概就是根据思维导图上的点来进行学习分享咯。要是觉得我这样的学法或者是本文的看法有啥问题的话，欢迎留言指正，大家一起学习交流，一起秃头，呸，一起加油。</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/%E5%B0%81%E9%9D%A2%20%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>概述</tag>
      </tags>
  </entry>
  <entry>
    <title>小白重装系统</title>
    <url>/2019/01/17/czxt/</url>
    <content><![CDATA[<p><strong>前言</strong> 现在电脑是人手必备啦，所以大家多少都要了解一下电脑的东西，这样电脑出问题也不会被修电脑的忽悠了。今天就说一下万能的<code>「重装系统」</code>大法。</p>
<p>重装系统的话，现在有两种方式：一是用 <code>nt6</code> 程序直接装系统，这种就比较简单啦，直接去下个 nt6，都有文字提示，不过这个软件暂不支持在 win10 上面运行，所以 win10 的小伙伴想重装系统的话就要看下面的 U 盘装机咯。</p>
<p>下面就开始我们最常用的 U 盘装机咯</p>
<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h2><p>要装系统，首先有下面几样东西</p>
<ul>
<li>一个 U 盘</li>
<li>启动盘制作工具（easyU）</li>
<li>一个系统安装包</li>
<li>驱动和激活工具</li>
</ul>
<p>上面的这些东西我都放到这个网盘里面啦，大家自己下啦<br><img src="http://img.cdn.lijiayuan.top/czxt/wp.png" alt="image"><br>链接：<a href="https://pan.baidu.com/s/1DfaH7irX30XDCsqxdjgvpA" target="_blank" rel="noopener">https://pan.baidu.com/s/1DfaH7irX30XDCsqxdjgvpA</a><br>提取码：rkd9<br>下面我们开始一步一步来刷机</p>
<h3 id="1-1-制作-U-盘启动盘"><a href="#1-1-制作-U-盘启动盘" class="headerlink" title="1.1 制作 U 盘启动盘"></a>1.1 制作 U 盘启动盘</h3><p>这个就很简单啦，直接电脑插入 U 盘，打开 easyU，直接全新制作就行了，简简单单，如下图：<br><img src="http://img.cdn.lijiayuan.top/czxt/0.png" alt="image"></p>
<p><code>注</code> 这个制作启动盘会格式化 U 盘，所以原来 U 盘有东西的话记得清走。 </p>
<h3 id="1-2-进入-PE"><a href="#1-2-进入-PE" class="headerlink" title="1.2 进入 PE"></a>1.2 进入 PE</h3><p>进入 PE 的快捷键各个品牌的电脑可能会不一样，有的是 F2，有的是 F10，DEL，F12 也有，大家装系统前自己先去百度那那个型号的电脑进入 PE 的快捷键是啥，然后一按开机键就猛按就对了（其实在电脑品牌那个界面出现的时候按就可以了，不过为了怕错过，一开始就猛按吧）</p>
<p>猛按之后电脑会让你选择启动模式（如下图的样子），选择 U 盘启动（带有 「USB」 字眼的那个）</p>
<p><img src="http://img.cdn.lijiayuan.top/czxt/0.1.jpg" alt="image"></p>
<p>选择 U 盘启动之后，会让你选择 PE 系统，有两个选项，随便调进去进行了。如下图：<br><img src="http://img.cdn.lijiayuan.top/czxt/0.2.jpeg" alt="image"></p>
<p><code>注</code> 各个 U 盘启动盘的界面不一样的，我那时候忘记拍照了，所以就从网上找了个类似的图片,所以图片不一样的是正常的，别怕。</p>
<p>选择后进入 PE，这个过程和我们日常开机是一样的，需要等待一段时间，然后就开入我们所谓的 PE 啦（其实就是一个装在 U 盘里面简化的 windows 系统，没那么神秘），如下：<br><img src="http://img.cdn.lijiayuan.top/czxt/0.0.jpg" alt="image"></p>
<h3 id="1-3-磁盘分区"><a href="#1-3-磁盘分区" class="headerlink" title="1.3 磁盘分区"></a>1.3 磁盘分区</h3><p>别怕，这个看起来吓人而已，其实也是用软件帮我们搞的。</p>
<p>打开桌面的 「DG 硬盘分区软件」，进去之后有两种选择</p>
<ol>
<li>如果你只是想格式化 C 盘，然后装系统的话，就直接选中 C 盘，然后右键格式化就行</li>
<li>如果你像我一样想干干净净开始或者像重新调整磁盘空间的话，选中电脑硬盘，右键快速分区</li>
</ol>
<p><img src="http://img.cdn.lijiayuan.top/czxt/1.jpg" alt="image"></p>
<p>后面要咋分配就是你自己的事情啦，不过要注意如果你要装 win7，分区表类型最好选 <code>MBR</code> 格式，win10 就 <code>GUID</code> 格式咯，然后系统盘最好留个 <code>100 G</code> 吧。一键确定之后，硬盘格式化！东西就全都没啦！所以千万要备份好自己的数据哦（手动滑稽）</p>
<h2 id="2-重装系统"><a href="#2-重装系统" class="headerlink" title="2 重装系统"></a>2 重装系统</h2><p>准备了那么多，选择终于要开始的我们的装系统环节了，其实装系统和装一个软件是一样的，首先打开我们的系统镜像</p>
<p><img src="http://img.cdn.lijiayuan.top/czxt/2.jpg" alt="image"></p>
<p>双击 setup 装咯</p>
<p><img src="http://img.cdn.lijiayuan.top/czxt/3.jpg" alt="image"></p>
<p>下一步咯</p>
<p><img src="http://img.cdn.lijiayuan.top/czxt/4.jpg" alt="image"></p>
<p>有密钥的就输入密钥，想我一样没有的就点击「我没有产品密钥」咯</p>
<p><img src="http://img.cdn.lijiayuan.top/czxt/5.jpg" alt="image"></p>
<p>挑个喜欢的版本吧</p>
<p><img src="http://img.cdn.lijiayuan.top/czxt/6.jpg" alt="image"></p>
<p>此处我们选择自定义安装</p>
<p><img src="http://img.cdn.lijiayuan.top/czxt/7.jpg" alt="image"></p>
<p>选中系统盘安装</p>
<p><img src="http://img.cdn.lijiayuan.top/czxt/8.jpg" alt="image"></p>
<p>到了这边就等着他自己装啦</p>
<p>— 很久之后 —</p>
<p><img src="http://img.cdn.lijiayuan.top/czxt/9.jpg" alt="image"></p>
<p>他装完系统要重启啦，这个时候就等系统重启，但是在电脑关机之后，启动之前把 U 盘拔了。</p>
<p>重启之后，恭喜你，系统安装成功啦（此处省略 win10 系统那烦人的电脑个性化设置） </p>
<h3 id="3-后续工作"><a href="#3-后续工作" class="headerlink" title="3 后续工作"></a>3 后续工作</h3><p>虽然说这样安装完，电脑是可以用的了，但是他会缺少一些驱动啥，后面用的时候可能会出问题，所以现在我们为我们的电脑装修一下。</p>
<h3 id="3-1-装驱动"><a href="#3-1-装驱动" class="headerlink" title="3.1 装驱动"></a>3.1 装驱动</h3><p>这个也简单，直接用网盘中万能驱动软件（用对应系统的啊），他会自动检测电脑缺啥驱动了，我们之需要到软件的右下角选中 「安装后删除已解压的驱动文件」，并且把软件推荐中的那些不要附加软件去掉勾选，且点击上面的那个倒三角菜单，取消掉那个网址导航（虽然人家要赚钱，但是我就是不想要这些附加的鬼东西啊）</p>
<p><img src="http://img.cdn.lijiayuan.top/czxt/10.png" alt="image"></p>
<p>最后一键安装，等就对了</p>
<h3 id="3-2-安装运行库"><a href="#3-2-安装运行库" class="headerlink" title="3.2 安装运行库"></a>3.2 安装运行库</h3><p>这个步骤是可以省略的，但是有些软件运行是要依赖某些运行库的，为了省去以后的麻烦，我一般会先装网盘中的那四个运行库，当然安装前，要勾选掉倒三角菜单中的那个「网址导航」。（没有办法，自己用的电脑，一定要清爽干净）</p>
<h3 id="3-3-激活"><a href="#3-3-激活" class="headerlink" title="3.3 激活"></a>3.3 激活</h3><p>不是每一个人都有正版的 windows 的密钥啊，所以我们就只能去通过各种方式去激活了。</p>
<p>这里的话就要用网盘里面的那两个激活工具了，win7 的图形化界面操作，就不用说了。win10 的话打开那个激活工具的文件夹，选中 <code>KMS-VL-ALL.cmd</code> 文件，右键以管理员身份运行（管理员身份运行哦，不要直接双击打开了，然后这个工具还会顺便帮你激活你的 office），然后就让他自己操作，激活完后他会自己关掉的。可能杀毒软件会报毒，没事的，别怕。</p>
<h3 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4 写在最后"></a>4 写在最后</h3><p>看完是不是觉得重装系统真的挺简单的列，是的，就是这么简单的，不过备份数据啊，重装软件，配置电脑这些就比较烦，所以没事就不要乱重装系统折腾自己啦，好好关心照顾自己的电脑啦。</p>
<p>最后放一下我那些装机工具的来源</p>
<ol>
<li><a href="https://www.itsk.com/thread-393549-1-1.html" target="_blank" rel="noopener">U 盘制作工具</a></li>
<li><a href="https://www.itsk.com/thread-393547-1-1.html" target="_blank" rel="noopener">万能驱动软件</a></li>
<li><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">系统镜像</a>,这个网站还有微软原生的 office 镜像文件，需要的也可以去下载。</li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>重装系统</tag>
      </tags>
  </entry>
  <entry>
    <title>小红帽学前端 | 1.3 常用 HTML 元素</title>
    <url>/2019/09/14/cxqd-1-3-commonEle/</url>
    <content><![CDATA[<p><strong>前言</strong> 上次我们介绍完 head 元素里面的东西，主要就是了解元数据的一些东西，也算摸明白整个 HTML 文件的一个结构了吧。然后聊了那么多枯燥的概念，今天来整点实际的，我们直接上手写页面，写一个丑的一批的网页简历（没有 CSS 写样式搭配，是真的丑。）。如下：</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1.3/1.png" alt="image"></p>
<p>借助这个来了解一下我们常用到的这么几个 HTML 元素。</p>
<p>本文的笔记代码我丢到 <a href="https://github.com/lijiayuan365/relearnFront-end/tree/master/HTML" target="_blank" rel="noopener">GitHub</a> 上面去了，最好可以去看看，然后自己琢磨搞出来练练手。</p>
<h2 id="1-常用元素概览"><a href="#1-常用元素概览" class="headerlink" title="1 常用元素概览"></a>1 常用元素概览</h2><p>HTML 元素很多，但是常用的就那么几个。我们先看一下全景，然后在一个一个去用他。</p>
<p>不同的元素有着不同的作用，我们简单做个分类，今天我们了解有下面的这些元素。</p>
<ul>
<li><p>布局相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div span</span><br></pre></td></tr></table></figure>
</li>
<li><p>文本元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h1 - h6, p</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ul ol li</span><br></pre></td></tr></table></figure>
</li>
<li><p>表格元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">table tr th td</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">button(按钮) a（链接） img（图片）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-布局元素-div-span"><a href="#2-布局元素-div-span" class="headerlink" title="2 布局元素 div span"></a>2 布局元素 div span</h2><p>这两个都是用于布局的布局容器，本身是没有任何语义的。也正因为如此，他们采用于布局，用于给元素分组分模块。比如像下面这种<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;header&quot;&gt;...&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;...&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;footer&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>就把整个页面分成了三个模块。</p>
<p>这两个元素唯一的不同就是，<code>div</code> 是块级元素，<code>span</code> 是内联级元素。</p>
<blockquote>
<p>元素就分这两种。其中块级元素会独占一行，不能和其他元素并排，可以设置固定的宽高。内联元素可以与其他内联元素并排，不能设置宽高。</p>
</blockquote>
<p>比如我们看看下面的代码会显示啥<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>GitHub:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/lijiayuan365"</span>&gt;</span>https://github.com/lijiayuan365<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>网站：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.lijiayuan.top"</span>&gt;</span>lijiayuan.top<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>电话邮箱...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1.3/2.png" alt="image"></p>
<p>可以看到两个 <code>span</code> 的元素内容是挤在一行的，而 <code>div</code> 的内容是各占一行的。</p>
<h2 id="3-标题元素-h1-h6"><a href="#3-标题元素-h1-h6" class="headerlink" title="3 标题元素 h1 - h6"></a>3 标题元素 h1 - h6</h2><p>h1 - h6 元素代表了六个级别的章节标题的。<code>h1</code> 是最高的部分级别，<code>h6</code> 是最低的。按照语义化的角度看，这个元素就用于做标题的咯。</p>
<p>在 demo 页面中，每一项的标题就是用 h1 元素的。</p>
<h2 id="4-段落元素-p"><a href="#4-段落元素-p" class="headerlink" title="4 段落元素 p"></a>4 段落元素 p</h2><p>HTML 段落元素。表示文本的一个段落。该元素通常表现为一整块与相邻文本分离的文本，或以垂直的空白隔离或以首行缩进。</p>
<p>反正就是你要是有几段文字的，想要展示的，那就丢到 <code>p</code> 元素里面咯，一个元素的内容就是一个段落。</p>
<h2 id="5-列表元素-ul-ol-li"><a href="#5-列表元素-ul-ol-li" class="headerlink" title="5 列表元素 ul ol li"></a>5 列表元素 ul ol li</h2><p>这个是列表元素。其中 <code>ul</code>，<code>ol</code> 分别定义无序列表和有序列表。<code>li</code> 是他们列表里面的列表项目。看个代码就知道了。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>熟练掌握 HTML，CSS，JavaScript 等前端技术；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>熟悉使用 DIV + CSS 布局；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>熟悉运用 jQuery，Vue，WePY 等前端开发框架；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>熟悉前端开发规范、工程化、组件化，模块化开发；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>了解面向对象设计原则，常见的数据结构与算法及设计模式；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>了解服务端语言 Java，Node.js 和 HTTP 协议；<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>用 Express 搭建后台，用分层思想优化后台项目结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>使用 Antv-G6 设计工作流绘制组件<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>使用 Vue 动态组件实现表单字段的动态渲染<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1.3/3.png" alt="image"></p>
<p>可以看到 <code>ul</code> 无序列表的列表项前面用一个黑点标注，<code>ol</code> 有序列表的列表项目前面就直接用数字依次排下来。</p>
<h2 id="6-表格元素-table-tr-th-td"><a href="#6-表格元素-table-tr-th-td" class="headerlink" title="6 表格元素 table tr th td"></a>6 表格元素 table tr th td</h2><p>有时候我们展示数据使用单纯的列表看起来不是特别直观，我们会使用表格。他里面涉及的元素还挺多的。其中 <code>table</code> 定义一个表格，<code>tr</code> 表示表格的一行，里面的 <code>td</code> 和 <code>th</code> 都是行内的列项目。其中 <code>th</code> 是列标题。看个代码就明白了。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 表格标题行 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>时间<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>单位<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>工作内容<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>岗位<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--表格第二行内容--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>2018.06 - 2018.10<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>XX 公司<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>做了啥牛逼的事情，取得啥牛逼的成绩<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>前端开发工程师<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>2018.06 - 2018.10<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>XX 公司<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>做了啥牛逼的事情，取得啥牛逼的成绩<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>前端开发工程师<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的内容显示到网页就有了下面的效果。</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1.3/4.png" alt="image"></p>
<p>然后 <code>table</code> 元素的属性有几个我们要拉出来看看。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>border</td>
<td>定义表格的边框的宽度</td>
</tr>
<tr>
<td>cellspacing</td>
<td>规定单元格之间的空白</td>
</tr>
<tr>
<td>cellpadding</td>
<td>规定单元边沿与其内容之间的空白。（也就是内边距）</td>
</tr>
</tbody>
</table>
<p>此外 <code>td</code> 元素有两个属性我们也要关注一下。<br>属性| 描述<br>—|—<br>colspan | 规定单元格可以横跨的列数<br>rowspan | 规定单元格可横跨的行数</p>
<p>这两个有啥子用啊，很有用的，我们的表格不可能都是那么规规矩矩几行几列来着。有时候我们会存在合并左右两个单元格的情况，也有可能存在合并上下两个单元格的情况，就像下面这种情况。</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1.3/5.png" alt="image"></p>
<p>这种这么搞啊，就是分别使用 <code>colspan=&quot;2&quot;</code> 和 <code>rowspan=&quot;2&quot;</code> 来让一个 <code>td</code> 占据两个 <code>td</code> 的列（行）。代码如下：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">cellspacing</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 此处 td 占据两列 td 的空间（就是合并左右两个单元格吧）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>2列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 此处 td 占据两行 td 的空间（就是合并上下两个单元格吧）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>2行<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>rrr<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>rrr<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>eee<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>eee<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面空间安排的刚好，要是空间多或者小，出现多余的 td 会怎么样呢？自己玩玩。</p>
<h2 id="7-其他元素"><a href="#7-其他元素" class="headerlink" title="7 其他元素"></a>7 其他元素</h2><h3 id="7-1-按钮元素-button"><a href="#7-1-按钮元素-button" class="headerlink" title="7.1 按钮元素 button"></a>7.1 按钮元素 button</h3><p>按钮树与用户交互最为常见的元素啦，他用起来也简单。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(&apos;I want you&apos;)&quot;&gt;I want you&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<p>就是展示一个按钮，然后给他的点击事件（onclick）绑定一个方法，让用户点击之后弹出出一个对话框。</p>
<h3 id="7-2-链接元素-a"><a href="#7-2-链接元素-a" class="headerlink" title="7.2 链接元素 a"></a>7.2 链接元素 a</h3><p>我们平常有 word 的时候应该用过超链接吧，这个就是网页里面的链接，他就是用于从当前页面链接到其他地方的。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.lijiayuan.top"</span>&gt;</span>lijiayuan.top<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面 <code>a</code> 元素的内容就是网页上显示的东西，然后元素的 <code>href</code> 属性就是链接跳转的地址。当我们在网页点击这个内容的时候，我们就会直接跳转到 <code>http://www.lijiayuan.top</code> 这个网址。</p>
<h3 id="7-3-图片元素-img"><a href="#7-3-图片元素-img" class="headerlink" title="7.3 图片元素 img"></a>7.3 图片元素 img</h3><p>常言道「一图胜前言」，所以我们的网页里面肯定是要放图的啦。放图就用 img 元素啦。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/avatar.png"</span> <span class="attr">alt</span>=<span class="string">"照片"</span> <span class="attr">width</span>=<span class="string">"auto"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>img</code> 元素的 <code>src</code> 属性是指显示图片的地址，可以是本地的也可以是网上的。然后 <code>alt</code> 属性是指当你的 <code>src</code> 给的地址没有图片的时候会显示的文本。按道理是要写的。<code>height</code>,<code>width</code> 属性就不说了，就是图片的高宽啦。</p>
<h2 id="讲在最后"><a href="#讲在最后" class="headerlink" title="讲在最后"></a>讲在最后</h2><p>上面这这个元素基本就是我们平常用的比较多的元素啦。其实基本用到的就只有这些。但是在 HTML5 之后的话，出现了许多新的语义化的标签，这个就自己看或者我们到时候再讲咯。因为不想写太多，所以元素内的一些属性没有细说，只是让大家知道这么简单去用咯，深入一点的了解，自己来或者看后面我写不写吧。</p>
<p>看完这一篇，大家其实基本的 HTML 都会写啦，只不过是写的很难看而已。无所谓，难看大家也要写下去，练一下，可以模仿我给的 demo。（基本学前端都是模仿过来的）。反正就是一句话，多敲代码。</p>
]]></content>
      <categories>
        <category>小红帽学前端</category>
      </categories>
      <tags>
        <tag>常见标签</tag>
        <tag>HTML 元素</tag>
      </tags>
  </entry>
  <entry>
    <title>小红帽学前端 | 1.2 了解 head 元素</title>
    <url>/2019/09/01/cxqd-1-2-head/</url>
    <content><![CDATA[<p><strong>前言</strong> 我们上次大概了解了 HTML 的那么一个结构。其中讲到我们有一个 head 元素，这个东西不能简单讲完。所以这边我们单独挖出来讲讲。</p>
<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>学之前还是要先知道人家是啥，其实 head 元素人家也是一个元素，但是与一般元素不同，人家一般元素的内容是会显示在浏览器页面上的。head 元素里面的内容是不会显示在浏览器中的。他里面放着的是文档的各种属性和信息，包括文档的标题，样式和脚本的引用，元数据等等。大概有下面这些元素。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link&gt; &lt;script&gt; &lt;style&gt; &lt;title&gt; &lt;meta&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们就一个一个拉出来溜溜。</p>
<h2 id="2-title-元素"><a href="#2-title-元素" class="headerlink" title="2 title 元素"></a>2 title 元素</h2><p>我们写文章有文章的标题，网页也有标题啊，不过这里要和 <code>h1</code> 元素区分开，人家虽然也叫标题不过用于网页内容的标题，那么他标题在哪边啊，不知道啊。建个 HTML 文件看看咯。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;我是标题&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;我是段落&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们打开网页看看。在这里看到没，我们网页的标题。处在标签栏的位置的地方。</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1.2/head1.png" alt="image"></p>
<h2 id="3-link、style、script-元素"><a href="#3-link、style、script-元素" class="headerlink" title="3 link、style、script 元素"></a>3 link、style、script 元素</h2><p>这三个家伙以后用的多，现在先不用，link 元素一般是用来引入 CSS 资源的，style 元素里面是给我写 CSS 样式的。那么 script 元素咧。你猜？</p>
<p>当然用来写脚本的啦，一般就 JavaScript 啦。这几个我们先认个脸熟，后面我们用到自然就懂了。现在就开始我们 head 元素里面最大头的 meta 元素的介绍了。</p>
<p>不过这边还有讲一下 link 除了引入后面后面要学的样式之外，还有一个很重要的功能。那就是引入我们网页的图标，啥网页图标啊，请看</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1.2/head4.png" alt="image"></p>
<p>看到木有，在网页标题旁边的小图标，那个就是网页的图标，虽然可能有点不起眼，但是对比那些木有自己设图标直接用浏览器默认的那些网页，这样看起来更富有气息啊。并且以后处于性能的考虑，这个最好还是加上。</p>
<p>咋加咧，当然是 <code>link</code> 元素啊：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>herf</code> 属性指向图标的地址，为了保持兼容性，一般图标的后缀名我们统一是 <code>.ico</code>，如何获取，自行百度。</p>
<h2 id="4-meta-元素"><a href="#4-meta-元素" class="headerlink" title="4 meta 元素"></a>4 meta 元素</h2><p>这个元素是为文档添加元数据的。啥是元数据啊？就是描述数据的数据。例如指定你文档的字符编码，文档的作者等等等。这个东西很重要，有些公司面试的时候很喜欢问这里面的东西。</p>
<p>一般的 meta 元素包含了 name 和 content 属性，大概长这样子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;XX&quot; content=&quot;conteng&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中 name 指定了 meta 元素的类型，说明该元素包含了说明类型的信息。content 指定了实际的元数据的内容。下面我们就搞我们搞几个常见看看。</p>
<h3 id="4-1-charset-字符编码"><a href="#4-1-charset-字符编码" class="headerlink" title="4.1 charset 字符编码"></a>4.1 charset 字符编码</h3><p>在我们上面的例子中有下面这行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个指定了文档的字符编码（就是在这个文档中被允许使用的字符集）是 <code>UTF-8</code>。这个基本所有的 HTML 文本里面都有的，记下便是。</p>
<h3 id="4-2-author-作者，keyword-关键字和-description-网页描述信息"><a href="#4-2-author-作者，keyword-关键字和-description-网页描述信息" class="headerlink" title="4.2 author 作者，keyword 关键字和 description 网页描述信息"></a>4.2 author 作者，keyword 关键字和 description 网页描述信息</h3><p>这个一般我们是用不到的，但是在某些地方是需要的。我们先看看这两个是怎么通过 meta 元素加进去的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;author&quot; content=&quot;Leon&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;keyword&quot; content=&quot;小红帽 学习&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;这个是小红帽用于测试的网页&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>留下个作者信息还是有点用，有些内容关系系统会有获取页面作者的信息，用于联系作者或者干嘛干嘛的。</p>
<p>至于页面描述，这个就主要用来 SEO（搜索引擎优化） 的。至于是啥效果，我们打开浏览器搜索 「腾讯」试一下。可以看到有下面这么一个结果。</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1.2/head2.png" alt="image"></p>
<p>看到画圈圈的那块内容了没有，那个就是页面的描述，这个可以便于被搜索引擎搜索到并且显示在搜索结果上，让人没进去网站前先知道那个网站里面大概是啥东西。</p>
<p>啥，不信吗？那我们就点进去腾讯官网看一下，然后右键查看源代码。</p>
<p><img src="http://img.cdn.lijiayuan.top/cxqd/1.2/head3.png" alt="image"></p>
<p>如何</p>
<p><img src="http://img.cdn.lijiayuan.top/deepcopy/biaoqing.jpg" alt="image"></p>
<p>至于关键字，也是用于 SEO。让搜索引擎搜对应关键字的时候能快速找到你。</p>
<h3 id="4-3-viewport-视窗"><a href="#4-3-viewport-视窗" class="headerlink" title="4.3  viewport 视窗"></a>4.3  viewport 视窗</h3><p>这个在现在移动端页面基本都会用的了，主要用于移动端页面的缩放和拖拽的。视窗，理解也简单，就是用户网页的可视区域（也就是你手机浏览器里面展示网页内容的那个区域）。这个面试会问到。下看看代码吧：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>像我上面的描述就是说我这个页面啊，视口的宽度和查看设备的宽度是一致的，且一开始的缩放比例是 1。他还有其他的一下数据信息，我们一一列出来：</p>
<ul>
<li><strong>width</strong> viewport 的大小，可以是一个固定的像素，也可以是特殊值，例如 device-width（设备的宽度）</li>
<li><strong>height</strong> 不说了，指定高度咯，其他同上。</li>
<li><strong>initial-scale</strong> 页面第一次加载时候的缩放比例</li>
<li><strong>maximum-scale</strong> 允许用户缩放到的最大比例，范围 0-10</li>
<li><strong>minimum-scale</strong> 允许用户缩放到的最小比例，范围还是 0-10</li>
<li><strong>user-scalable</strong> 这个就是说用户能不能手动缩放啦，值是 <code>yes</code>、 <code>true</code> 就允许用户手动缩放网页。反之 <code>no</code>、 <code>false</code> 就不允许咯。不写的话，默认值就是 <code>yes</code> 咯。</li>
</ul>
<h3 id="4-4-X-UA-Compatible"><a href="#4-4-X-UA-Compatible" class="headerlink" title="4.4 X-UA-Compatible"></a>4.4 X-UA-Compatible</h3><p>这个是 IE8 中新增的，是一个关于网页文档兼容模式的定义。浏览器的兼容性问题，要么现在要么以后，你肯定会知道的。啥都不说了，万恶的 IE。</p>
<p>对于这个元数据，不需要想太多，直接写下面的数据就对了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge chrome=1&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>就直接让 IE 浏览器以最高级模式渲染文档就完事了。</p>
<h2 id="5-写在后面"><a href="#5-写在后面" class="headerlink" title="5 写在后面"></a>5 写在后面</h2><p>关于元数据，就讲这几个就够了。其他的碰到再说了。现在让我们详细讲太多会感到无聊和迷惑的，咱们初学，简单点。</p>
<p>不过搞完这些，基本的概念咱也学会了，自己搞个 HTML 写一下吧，代码这种东西，不写一下你是学不好的。内容可以复制粘贴随便来，但是标签属性那些自己手敲一下。熟悉一下。搞一个标准的 HTML 文档出来。下一次的文章的话就是讲我们常见的 HTML 元素咯，到时候就是直接开始敲啦。不然没意思也没用啊。</p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>小红帽学前端 | 1.1 HTML 简介</title>
    <url>/2019/08/25/cxqd-1-1-htmlDesc/</url>
    <content><![CDATA[<p><strong>前言</strong> 从今天开始，小红帽开始了学习前端的道路（假装从头开始）。开始第一天，定个小目标，理清 HTML 是一门怎么样的东西。知道他里面有什么玩意，在自己整一个 「Hello World ！」的 HTML 文本出来先。</p>
<h2 id="1-HTML-是啥？"><a href="#1-HTML-是啥？" class="headerlink" title="1 HTML 是啥？"></a>1 HTML 是啥？</h2><p>老套路，学啥东西先看看人家是啥玩意，这里的话。<br>HTML 全称 HyperText Markup Language，翻译成中文是「超文本标记语言」。看翻译就知道，他并不是一门编程语言，而是一种标记语言，一种告知浏览器如何组织页面的标记语言。</p>
<p>啥玩意，你可以理解这玩意是一个文本，然后咧，我们在这里文本外面套层皮下去，做点小标记，来告诉浏览器去渲染解析他的时候，知道这个标记的渲染出来是一个标题，那个文本渲染出来的是一个加粗的文本。眼熟不，像不像大学期末考在书上画重点，做满了标记，你像浏览器一样，一翻书，看到这些标记的文本，就知道「哦，这玩意是重点，搞出来的要不一样」</p>
<p>现在我们整一个 HTML 文件出来，开始我们对 HTML 的摸索。我们先右键新建一个文本文档，然后吧他的后缀名 <code>.txt</code> 改为 <code>.html</code>（不知道改后缀名自个百度去），然后用  notepad++ 打开进行编辑。下面所展示的代码均在我们现在创建的 HTML 文件中编写。开始我们对 HTML 的摸索之旅吧。</p>
<blockquote>
<p>这边一开始，大家就先老老实实用个 notepad++ 或者直接记事本来写代码啦，就不要用啥子 IDE，有点杀鸡用牛刀的感觉。此外大家刚开始学，不要偷懒，认真打好每一串代码，不要用 IDE 偷懒。这样对刚开始的学习才好。等到你学入门知识的时候就可以用那些 IDE 去帮你偷懒啦。当然现在你要用也随你。建议用 VSCode 等这种轻量级的 IDE，Webstorm 这种就算了，好用！但是是真的浪费，且那玩意真的很吃内存。</p>
</blockquote>
<h2 id="2-剖析-HTML-元素"><a href="#2-剖析-HTML-元素" class="headerlink" title="2 剖析 HTML 元素"></a>2 剖析 HTML 元素</h2><h3 id="2-1-元素组成要素"><a href="#2-1-元素组成要素" class="headerlink" title="2.1 元素组成要素"></a>2.1 元素组成要素</h3><p>HTML 是由一个个 HTML 元素组成的，那么我们看看一个 HTML 元素是怎么样的。我们就拿一个段落元素为例吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;我是一个段落&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>这上面这个元素主要有下面几个部分</p>
<ul>
<li><strong>开始标签</strong>（Opening tag）</li>
</ul>
<p>他由一个小于号 &lt; 和一个大于号 &gt;，包裹这一个元素名称（本例为 p）组成。本例中 <code>&lt;p&gt;</code> 就是我们的开始标签。他告诉浏览器「兄弟，注意啦，从这开始这是一个段落，你要按照段落的样子渲染」</p>
<ul>
<li><strong>结束标签</strong>（Closing tag）</li>
</ul>
<p>与开始标签一样，只是在其元素名前面加了一个斜杠，表示元素的结尾。也就是本例中的 <code>&lt;/p&gt;</code>。他就告诉浏览器「大兄弟，段落渲染在这边就可以啦。后面的咋渲染就不关我的事情啦」</p>
<ul>
<li><strong>内容</strong>（Content）</li>
</ul>
<p>元素的内容啊，就是被标签包裹住的东西。这边的话就是中间的那段文本。但他也可以是另外一个元素，这个是可以层层嵌套的。</p>
<ul>
<li><strong>元素</strong>（Element）</li>
</ul>
<p>上面的东西凑起来就是一个元素啦。</p>
<p>当然不一定每个元素都是有这些构成要素的，例如我们的 <code>空元素</code> 就只有标签举例的话就是我们的图片标签 img 了，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;xxx.jpg&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>他整个元素就这么一点东西。就只有一个标签。</p>
<h3 id="2-2-元素属性"><a href="#2-2-元素属性" class="headerlink" title="2.2 元素属性"></a>2.2 元素属性</h3><p>元素也有着属性的，属性里面包含元素的额外信息，这些信息不会显示在实际的内容中。我们看下面的代码。写法也简单，就是在开始标签里面加 <code>属性名=“属性值”</code> 的这种写法，就是要注意互相之间要有个空格，不然就不知道会出现什么奇怪的情况了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p class=&quot;desc&quot; id=“de2”&gt;描述&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<p>这上面 p 元素有两个属性，分别是 id 和 class。其中 class 的属性，值为 desc，在页面中我们是看不到这些东西，这个 class 属性一般是用来识别此元素的样式信息或者也可以用于识别元素等作用。</p>
<p>元素的属性太多了，这边就不想一一说了，到时候用多了就知道了。</p>
<h2 id="3-创建一个完整的-HTML-文件"><a href="#3-创建一个完整的-HTML-文件" class="headerlink" title="3 创建一个完整的 HTML 文件"></a>3 创建一个完整的 HTML 文件</h2><p>学习了一些 HTML 元素的基础知识，但是这些元素单独是没有意义的。HTML 是有自己的一套规则的。我们就看一下一个完整的 HTML 文件是怎么样的。我们再搞一个 HTML 文件，然后把下面的代码放到里面去。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;demo&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello World!&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>看起来一堆代码，其实我们用浏览器打开他的话就只有一句 <code>Hello World!</code> 显示在我们的页面上。为啥子咧。我们分析一下他的组成你就知道为啥了。</p>
<p>1 <code>&lt;!DOCTYPE html&gt;</code></p>
<p>声明文档类型。他的作用就是告诉我们的语言解析器，也就是我们的浏览器要用什么样的文档类型定义来解析下面的文档。之前声明这个的时候贼多东西，现在你知道直接第一行加 &lt;!DOCTYPE html&gt; 这个就行啦。</p>
<p>2 <code>&lt;html&gt;&lt;/html&gt;</code></p>
<p>html 元素。这个元素包裹了整个完整的页面，是一个根元素，前期基本不用去理他。后面用到的时候再说。</p>
<p>3 <code>&lt;head&gt;&lt;/head&gt;</code></p>
<p>头元素。这个元素是一个容器，它包含了所有你想包含在HTML页面中但不想在HTML页面中显示的内容。这些内容包括你想在搜索结果中出现的关键字和页面描述，CSS样式，字符集声明等等。这块内容很重要，所以我们在在下一篇文章里面去介绍他。</p>
<p>4 <code>&lt;body&gt;&lt;/body&gt;</code></p>
<p>body 元素。包含了你访问页面时所有显示在页面上的内容，文本，图片，音频，游戏等等。反正你在页面上看到的东西全在这里面就对啦。</p>
<p>所有 HTML 都应该要有上面的那些东西，我们要搞事的地方基本就在 body 元素里面。现在你可以尝试自己搞一个 HTML 文件，搞点事情。例如一级标题的元素名是 <code>h1</code>,段落的元素名是 <code>p</code>。先拿这两个元素去玩一下。或者自己再去找找其他元素玩玩。</p>
<h2 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4 写在最后"></a>4 写在最后</h2><p>重学之后发现其实自己还是不懂这些基础的东西，因为发现自己会用但是不知道如何说出来。果然还是一个小辣鸡。这边的话，如果大家想学前端的话可以去 <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a> 找教程好好看，如果觉得看文字教程觉得有点难消化的，可以我公众号那边回复「前端」，就会有一些前端的视频教程，大家可以结合着来学习。咋说咧，自己当初学前端的时候没有踏实学好，现在我真的是一个以一个初学者的态势来学习了，如果有啥不懂或者我哪边理解错了，欢迎留言指正，大家一起学习进步啦。</p>
]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 中的深拷贝与浅拷贝</title>
    <url>/2018/11/25/deepcopy-shallowcopy-in-JS/</url>
    <content><![CDATA[<p><strong>前言</strong> 最近在写项目的时候涉及到一些父子组件传递个对象或者数组通信啥的，或者是直接复制添加对象啥的，直接使用赋值的时候总会出错</p>
<h2 id="1-什么是深拷贝-amp-浅拷贝"><a href="#1-什么是深拷贝-amp-浅拷贝" class="headerlink" title="1 什么是深拷贝&amp;浅拷贝"></a>1 什么是深拷贝&amp;浅拷贝</h2><p>见名知义，无论是深拷贝还是浅拷贝，都是 copy 的问题。就是 copy 的时候出现的两种情况。区分起来也挺简单的，举个例子，假设 B 是 A 复制过来的，当我们修改 A 的时候，B 也随之改变了，那么这个就是<code>浅拷贝</code>，那要是 B 没有随 A 一起改变的话，那么这个就<code>深拷贝</code>了。</p>
<h2 id="2-现实场景"><a href="#2-现实场景" class="headerlink" title="2 现实场景"></a>2 现实场景</h2><p>首先呢，我们先要明白在 Javascript 中，有 5 种简单数据类型（也称为基本数据类型），分别是 Undefined，Null，String，Number，Boolean,还有 1 种复杂数据类型即 Object，（ES6 新出的 Symbol 数据类型就先不讨论了）</p>
<h3 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h3><p>对于基本数据类型的复制就谈不上什么深拷贝和浅拷贝了，对于基本数据类型来说，他们的值在栈内存中占据着固定大小的空间，并被保存在栈内存中。假设 变量 b 复制 基本数据类型变量 a，那么 b 会内存中占据自己的空间，和 a 就没啥关系了，大家各管各的，互不干涉。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-复杂数据类型（Object）"><a href="#2-2-复杂数据类型（Object）" class="headerlink" title="2.2 复杂数据类型（Object）"></a>2.2 复杂数据类型（Object）</h3><p>对于对象的话，他是引用类型，复制起来就要区分浅拷贝和深拷贝了，因为 Object 是引用类型，他真正的值保存在堆内存中，他在栈内存存储是变量名和指向该对象值的指针（就是一个地址），如下图所示。<br><img src="http://img.cdn.lijiayuan.top/deepcopy/cashed.png" alt="image"><br>所以当我们用平常用一个变量去复制一个 Object 类型的变量的时候，复制的是他的指针地址而已，所以两个变量最终都指向同一个变量，大家要改一起改，这就是<code>浅拷贝</code>啦，如下<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">'kk'</span>,<span class="attr">age</span>:<span class="number">12</span>,<span class="attr">desc</span>:<span class="string">'源对象'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj2.desc = <span class="string">'目标对象'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name:'kk',age:12,desc:'目标对象'&#125; 此处源对象跟着一起变了</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;name:'kk',age:12,desc:'目标对象'&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>啥，不信？！，那就看图<br><img src="http://img.cdn.lijiayuan.top/deepcopy/example.png" alt="image"><br>如何<br><img src="http://img.cdn.lijiayuan.top/deepcopy/biaoqing.jpg" alt="image"><br>但是在我们日常的使用当中，Object 类型的浅拷贝的行为会让我们很迷，我复制这个对象就是想复制他的值而已啦，不要复制人家个值就和他绑到一块了，跟他一起「同生共死」。所以啊，当我们想按照我们复制的想法，就只复制他的值用来自己用，他的是他的，我的是我的，大家井水不犯河水。接下来就要说咋办了。</p>
<h2 id="3-实现对象类型的深拷贝"><a href="#3-实现对象类型的深拷贝" class="headerlink" title="3 实现对象类型的深拷贝"></a>3 实现对象类型的深拷贝</h2><p>对于对象的深拷贝，搜集了网上的资料，就有下面三种方法</p>
<h3 id="3-1-slice-amp-concat"><a href="#3-1-slice-amp-concat" class="headerlink" title="3.1 slice()&amp;concat()"></a>3.1 slice()&amp;concat()</h3><p>这个是针对数组的深拷贝，可以通过这两个方法实现对数组的深拷贝,如下<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.slice();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1,2,3,4]</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">`</span>concat<span class="string">` 同理可得，不过这两个方法有个问题，`</span>slice()<span class="string">` 和 `</span>concat()<span class="string">` 方法能够深拷贝的就只有数组的一级属性，但是如果是多维数组的话，那么只有一级属性的值是深拷贝，往下就都是浅拷贝了，如下所示</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>,<span class="number">2</span>],<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[[0,2],1,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[[0,2],2,3,4]</span></span><br><span class="line"><span class="comment">// arr2[1] 没变，但是 arr2[0] 跟着一起改了</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.cdn.lijiayuan.top/deepcopy/example3.png" alt="image"></p>
<h3 id="3-2-JSON-的骚操作"><a href="#3-2-JSON-的骚操作" class="headerlink" title="3.2 JSON 的骚操作"></a>3.2 JSON 的骚操作</h3><p>通过 JSON 的 stringify， parase 操作也可以实现对象的深拷贝。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123;name:&apos;kk&apos;,age:12,desc:&apos;源对象&apos;&#125;</span><br><span class="line">let obj2 = JSON.parase(JSON.stringify(obj1));</span><br><span class="line">obj2.desc = &apos;目标对象&apos;;</span><br><span class="line">console.log(obj1); //&#123;name:&apos;kk&apos;,age:12,desc:&apos;源对象&apos;&#125; 此处源对象就没有一起变了</span><br><span class="line">console.log(obj2); // &#123;name:&apos;kk&apos;,age:12,desc:&apos;目标对象&apos;&#125;</span><br><span class="line">``` </span><br><span class="line">此法数组和对象都可以用。</span><br><span class="line">### 3.3 自己写一个深拷贝函数</span><br><span class="line">自己动手，丰衣足食</span><br><span class="line">```javascript</span><br><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">  let newObj = Array.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  if (obj &amp;&amp; typeof obj === &quot;object&quot;) &#123;</span><br><span class="line">    for (let key in obj) &#123;</span><br><span class="line">      if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        //判断ojb子元素是否为对象，如果是，递归复制</span><br><span class="line">        if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123;</span><br><span class="line">          newObj[key] = deepCopy(obj[key]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          //如果不是，简单复制</span><br><span class="line">          newObj[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = [1,2,3];</span><br><span class="line">let b = deepCopy(a);</span><br><span class="line">a[0] = 0;</span><br><span class="line">console.log(a); //[0,2,3]</span><br><span class="line">console.log(a); // [1,2,3]</span><br></pre></td></tr></table></figure></p>
<h3 id="3-4-JQ-的-extend-方法"><a href="#3-4-JQ-的-extend-方法" class="headerlink" title="3.4 JQ 的 extend 方法"></a>3.4 JQ 的 extend 方法</h3><p>这个就直接放文档了<br><code>$.extend( [deep ], target, object1 [, objectN ] )</code><br>deep:如果设为true，则递归合并即深拷贝。<br>target:待修改对象。<br>object1:待合并到第一个对象的对象。<br>objectN:待合并到第一个对象的对象。<br>使用如下</p>
<pre><code class="javascript"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],
<span class="keyword">let</span> b = $.extend(<span class="literal">true</span>,[],a);
a[<span class="number">0</span>]=<span class="number">1</span>;
<span class="built_in">console</span>.log(a); <span class="comment">// [0,2,3]</span>
<span class="built_in">console</span>.log(b); <span class="comment">// [1,2,3]</span>
</code></pre>
<p>以上就是关于 JS 中的深拷贝与浅拷贝的知识和如何进行深拷贝的知识了，如果有错或者有其他方式的话，欢迎在下面留言评论啦。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
        <tag>浅拷贝</tag>
        <tag>对象复制</tag>
        <tag>对象传值</tag>
      </tags>
  </entry>
  <entry>
    <title>express 项目分层实践</title>
    <url>/2018/12/08/express-project-2/</url>
    <content><![CDATA[<p><strong>前言</strong> 上次我们搭建了一个基本的 express 后台，但是这样的项目结构的可扩展性，维护性和代码复用性都不是很好，参照之前学习 JavaWeb 时候的四层架构设计，用分层的思想来对 express 进行一点小优化，进一步提高代码的可拓展性。本文的源代码在 <a href="https://github.com/lijiayuan365/express-project" target="_blank" rel="noopener">Github</a> 上，建议看着代码来看这篇文章。</p>
<h2 id="1-四（五）层结构概念"><a href="#1-四（五）层结构概念" class="headerlink" title="1 四（五）层结构概念"></a>1 四（五）层结构概念</h2><p>这个就简单说一下，所谓四层架构就是 Model实体层，Dao层（数据访问层也就是从数据库中查数据），Service层（业务逻辑层，也就是处理好数据），Controller层（视图控制层，在前后端分离的情况下就是写接口响应前端请求）和前端的 view（视图层），为啥要搞分层咧，说到底就是要解耦合，提高拓展性和维护性，写代码的时候，思路清晰一点，后面改代码的时候也知道要改哪边。</p>
<p>但是我们这次只是涉及后台的，视图层我们就不用管了，只需看前面的就行了。</p>
<h2 id="2-分层"><a href="#2-分层" class="headerlink" title="2 分层"></a>2 分层</h2><p>首先看一下项目结构哈<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">│  app.js</span><br><span class="line">│  package.json</span><br><span class="line">│  README.md</span><br><span class="line">│</span><br><span class="line">├─.idea</span><br><span class="line">│  │  express-project.iml</span><br><span class="line">│  │  misc.xml</span><br><span class="line">│  │  modules.xml</span><br><span class="line">│  │  vcs.xml</span><br><span class="line">│  │  watcherTasks.xml</span><br><span class="line">│  │  workspace.xml</span><br><span class="line">│  │</span><br><span class="line">│  └─inspectionProfiles</span><br><span class="line">├─bin</span><br><span class="line">│      www</span><br><span class="line">│</span><br><span class="line">├─config</span><br><span class="line">│      db.json</span><br><span class="line">│</span><br><span class="line">├─dao</span><br><span class="line">│      BaseDao.js</span><br><span class="line">│      UserDao.js</span><br><span class="line">│</span><br><span class="line">├─models</span><br><span class="line">│      user.js</span><br><span class="line">│</span><br><span class="line">├─public</span><br><span class="line">│  ├─images</span><br><span class="line">│  ├─javascripts</span><br><span class="line">│  └─stylesheets</span><br><span class="line">│          style.css</span><br><span class="line">│</span><br><span class="line">├─routes</span><br><span class="line">│      index.js</span><br><span class="line">│      users.js</span><br><span class="line">│</span><br><span class="line">├─services</span><br><span class="line">│      UserService.js</span><br><span class="line">│</span><br><span class="line">├─utils</span><br><span class="line">│      db-util.js</span><br><span class="line">│</span><br><span class="line">└─views</span><br><span class="line">        error.jade</span><br><span class="line">        index.jade</span><br><span class="line">        layout.jade</span><br></pre></td></tr></table></figure></p>
<p>按照分层思想，我们新建几个文件夹哈，首先是 Model层的 <code>models</code> 文件夹，dao 层的 <code>dao</code> 文件夹，service 层的 <code>services</code> 文件夹，controller 层的话就用原来的 <code>routes</code> 文件夹就可以了，为了方便，我加了一个全局配置的 <code>config</code> 文件夹和工具函数 <code>utils</code> 文件夹。具体项目如下，我们从最底层开始来一个一个来分析</p>
<h3 id="2-1-config"><a href="#2-1-config" class="headerlink" title="2.1 config"></a>2.1 config</h3><p>这个就放着各种配置文件，例如我的 <code>db.json</code> 里面就放了mongodb 的端口号，数据库名那些，反正就是各种配置啦</p>
<h3 id="2-2-utils"><a href="#2-2-utils" class="headerlink" title="2.2 utils"></a>2.2 utils</h3><p>这个就是有一些创建型的方法或者其他公共方法，像创建数据库连接池的方法我就放在这边的 <code>db-util</code> 里面了。</p>
<h3 id="2-3-models"><a href="#2-3-models" class="headerlink" title="2.3 models"></a>2.3 models</h3><p>实体层,针对 mongodb 来说，一个集合对应一个 model，然后都是这样的形式啦。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; mongoClient &#125; = <span class="built_in">require</span>(<span class="string">'../utils/db-util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 user Schema</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  name: <span class="built_in">String</span>,</span><br><span class="line">  id: <span class="built_in">String</span>,</span><br><span class="line">&#125;,&#123;<span class="attr">versionKey</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*model 的参数1 导出的模块名，</span></span><br><span class="line"><span class="comment">参数2 创建的 Schema，</span></span><br><span class="line"><span class="comment">参数2 指定数据库中的集合的名字，若不加的，则抹默认取‘第一个参数s’的集合*/</span></span><br><span class="line"><span class="keyword">let</span> User = mongoClient.model(<span class="string">'User'</span>, user, <span class="string">'user'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = User;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-dao"><a href="#2-4-dao" class="headerlink" title="2.4 dao"></a>2.4 dao</h3><p>创建完实体层，接下来就是 dao 层了，这边我封装了一个 BaseDao，基本的数据库操作都有了，后面我们创建其他 dao 的时候就很舒服啦，直接继承一下 BaseDao 就好了。例如下面的这个 UserDao：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> BaseDao = <span class="built_in">require</span>(<span class="string">'./BaseDao'</span>);</span><br><span class="line"><span class="comment">// 导入对应的实体</span></span><br><span class="line"><span class="keyword">let</span> User = <span class="built_in">require</span>(<span class="string">'../models/user'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">BaseDao</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(User);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果有啥特殊需求的话，自己再重写方法咯</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UserDao;</span><br></pre></td></tr></table></figure></p>
<p>这样就写好了一个基本的 dao 了，增删改查这些他都从 BaseDao 中继承了，</p>
<h3 id="2-5-services"><a href="#2-5-services" class="headerlink" title="2.5 services"></a>2.5 services</h3><p>service 层是业务逻辑层，这么写就看你项目的业务啦。我下面就简单些一个查询所有 user 数据的方法啦。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UserDao = <span class="built_in">require</span>(<span class="string">'../dao/UserDao'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> getUserList() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用 dao 层查询数据</span></span><br><span class="line">      <span class="keyword">let</span> userList = <span class="keyword">await</span> userDao.findAll();</span><br><span class="line">      <span class="keyword">return</span> userList;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`getUserList error--&gt; <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = UserService;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-6-routes"><a href="#2-6-routes" class="headerlink" title="2.6 routes"></a>2.6 routes</h3><p>controller 层，写接口用，这个写起来简单，就拿一下 service 层的数据返回就可以啦。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> UserService = <span class="built_in">require</span>(<span class="string">'../services/UserService'</span>);</span><br><span class="line"><span class="keyword">let</span> userService = <span class="keyword">new</span> UserService();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET users listing. */</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  userService.getUserList().then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code:<span class="number">0</span>,</span><br><span class="line">      msg:<span class="string">'OK'</span>,</span><br><span class="line">      data:data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// res.send('respond with a resource');</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/login'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    code:<span class="number">0</span>,</span><br><span class="line">    msg:<span class="string">'OK'</span>,</span><br><span class="line">    data:&#123;<span class="attr">result</span>:<span class="literal">true</span>&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p>
<p>然后这边的话，我有一个想法，就是想着每次多一个路由实例（controller）的时候，就要往 <code>app.js</code> 里面导入并引入，觉得这样 controller 多了的时候，<code>app.js</code> 里面代码会很多，所以就想着把模块导入的代码移到 routes 文件夹里面的 <code>index.js</code> 里面来，<code>app.js</code> 就引入个 <code>index</code> 就好啦。所以就有了下面 <code>index.js</code> 的代码。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123; <span class="attr">title</span>: <span class="string">'Express'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// user 路由模块</span></span><br><span class="line"><span class="comment">// 当我在 user 文件里面写一个 '/login' 的时候，前端访问就要访问 '/user/login'</span></span><br><span class="line">router.use(<span class="string">'/user'</span>, <span class="built_in">require</span>(<span class="string">'./users'</span>));</span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p>
<p>至此，全文就结束啦，对于 express 框架的分层实践如果有更好的建议或者我这样分层有啥问题的话，欢迎在在下方留言哈，大家一起学习一下。</p>
]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>express</tag>
        <tag>分层架构</tag>
      </tags>
  </entry>
  <entry>
    <title>配置自己的github博客</title>
    <url>/2018/10/10/deploy-hexo/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1 项目结构"></a>1 项目结构</h2><h3 id="1-1-config-yml"><a href="#1-1-config-yml" class="headerlink" title="1.1 _config.yml"></a>1.1 _config.yml</h3><p>网站的配置信息，在这边配置网站的大部分信息</p>
<h3 id="1-2-scaffolds"><a href="#1-2-scaffolds" class="headerlink" title="1.2 scaffolds"></a>1.2 scaffolds</h3><p>模板文件夹，新建文件会根据里面的模板创建新的文件</p>
<h3 id="1-3-source"><a href="#1-3-source" class="headerlink" title="1.3 source"></a>1.3 source</h3><p>资源文件夹是存放用户资源的地方，然后 <code>_posts</code> 是存放 markdown 文章的地方</p>
<h3 id="1-4-themes"><a href="#1-4-themes" class="headerlink" title="1.4 themes"></a>1.4 themes</h3><p>主题文件夹，hexo 会根据主题生成静态文件夹。本次我们使用的主题是 Next 主题<br><a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题网站</a></p>
<h2 id="2-config-yml-的配置"><a href="#2-config-yml-的配置" class="headerlink" title="2 _config.yml 的配置"></a>2 _config.yml 的配置</h2><h3 id="2-1-网站"><a href="#2-1-网站" class="headerlink" title="2.1 网站"></a>2.1 网站</h3><p>我们可以在 <code>_config.yml</code> 文件 中修改大部分的配置，具体咋配置，我就偷个懒了。直接贴中文文档的图了。<br><img src="http://img.cdn.lijiayuan.top//hexo-config/website.png" alt="image"><br>其中，<code>language</code> 就设置为 <code>zh-Hans</code> 啦，毕竟咱还是用中文写博客的，当然如果有大佬想搞个国际化的全英博客的话就另当别论了。  <code>description</code> 主要用于SEO，告诉搜索引擎一个关于我们站点的简单描述，官方是推荐在里面写我们站点的关键字，主题啥的，但是个人咧还是比较喜欢直接写个个人签名╭(╯^╰)╮ <code>author</code> 参数就是来说这个博客的是谁家的孩子啦。</p>
<h3 id="2-2-网址"><a href="#2-2-网址" class="headerlink" title="2.2 网址"></a>2.2 网址</h3><p><img src="http://img.cdn.lijiayuan.top//hexo-config/url.png" alt="image"><br>如果你的网站存放在子目录中，例如 <code>http://yoursite.com/blog</code>，则请将你的 url 设为 <code>http://yoursite.com/blog</code> 并把 root 设为 <code>/blog/</code>。</p>
<h3 id="2-3-目录"><a href="#2-3-目录" class="headerlink" title="2.3 目录"></a>2.3 目录</h3><p><img src="http://img.cdn.lijiayuan.top//hexo-config/dir.png" alt="image"><br>这里是高端局，我这种菜鸡就老老实实跟着官方走，不乱改了。</p>
<h3 id="2-4-文章"><a href="#2-4-文章" class="headerlink" title="2.4 文章"></a>2.4 文章</h3><p><img src="http://img.cdn.lijiayuan.top//hexo-config/article.png" alt="image"><br>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 <code>example.com</code>，您有一篇文章名为 hello，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是绝对于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p>
<h3 id="2-5-其他"><a href="#2-5-其他" class="headerlink" title="2.5 其他"></a>2.5 其他</h3><p><img src="http://img.cdn.lijiayuan.top//hexo-config/other.png" alt="image"></p>
<h2 id="3-其他配置"><a href="#3-其他配置" class="headerlink" title="3 其他配置"></a>3 其他配置</h2><h3 id="3-1-标签、分类、关于设置"><a href="#3-1-标签、分类、关于设置" class="headerlink" title="3.1 标签、分类、关于设置"></a>3.1 标签、分类、关于设置</h3><p>仔细看了一下上面关于目录的配置，然后又看了其他人的 hexo 博客，心头是不是一阵疑惑，咦，咋感觉自己少了那么多目录结构咧。咋整啊？自己装呗。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure></p>
<p>执行完这三条命令后，在站点的source 的目录下就生成了  tags，about，categories 三个文件夹然后就分别到 source 文件夹中新生成的 about  文件夹里面的 index.md 中添加下面的代码<br>type: “tags”<br>重新运行之后是不是就出来了，什么？出不来？好吧，我错了，这样的话就要去看你选择的 theme 里面的配置了，把 menu 里面对这三个菜单项的注释去掉，就可以了。再不行的话，那就那就，百度吧。</p>
<h3 id="3-2-关联到-github-pages"><a href="#3-2-关联到-github-pages" class="headerlink" title="3.2 关联到 github pages"></a>3.2 关联到 github pages</h3><ol>
<li>修改 _config.yml, 在文件最底部添加如下代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: ssh://git@github.com/你的github名/你的github名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装一个 hexo 插件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>部署项目，就直接运行下面三条命令就行了</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean // 清除原来打包的项目</span><br><span class="line">hexo g // 生成新的项目</span><br><span class="line">hexo d // 上传项目到github</span><br></pre></td></tr></table></figure>
<p>最后的最后，让我们打开浏览器，输入 <code>https://你的github用户名.github.io</code>，例如我的 <code>https://lijiayuan365.github.io</code>\<br><img src="http://img.cdn.lijiayuan.top//hexo-config/myblog.png" alt="image"></p>
<h2 id="4-真正的最后"><a href="#4-真正的最后" class="headerlink" title="4 真正的最后"></a>4 真正的最后</h2><p><code>强烈推荐下面这位大佬的博客</code> <a href="https://www.qcmoke.site/2018/09/14/131/" target="_blank" rel="noopener">Hexo 博客主题的设置与完善</a>，可以说是相当的全面与仔细了，快速配置好你的博客。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>配置博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/01/15/hello-world/</url>
    <content><![CDATA[<a id="more"></a>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>flex布局</title>
    <url>/2018/08/26/flex-knowledge/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="语法篇"><a href="#语法篇" class="headerlink" title="语法篇"></a>语法篇</h2><h3 id="一、flex是啥"><a href="#一、flex是啥" class="headerlink" title="一、flex是啥?"></a>一、flex是啥?</h3><p>flex即Flexible Box，意为弹性盒布局，用来为盒状模型提供最大的灵活性。（任何一个容器都可以被指定为flex布局）<br>用法：display:flex<br> <code>注意设置为flex布局之后，子元素的float，clear，vertical-align属性将失效</code></p>
<h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><p>采用flex布局的元素，称为flex容器（flex container）简称“容器”，它的所有子元素自动成为容器成员，称为flex项目（flex item），简称“项目”。<br>容器默认存在两根轴，水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start,结束位置叫做main<br>end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列，单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h3 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h3><p>以下有六个属性设置在容器上。 </p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h4 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h4><p>flex-direction属性决定主轴方向（即项目的排列方向）<br>它可能有四个值</p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿</li>
<li>column-reverse：主轴为垂直方向，起点在下沿</li>
</ul>
<h4 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h4><p>默认情况下，项目都排在一条线（又称轴线）上，flex-wrap属性定义，如果一条轴线排不下，如何换行。<br>它可能取三个值</p>
<ul>
<li>nowrap(默认)：不换行</li>
<li>wrap：换行，第一行在上方。</li>
<li>wrap-reverse：换行，第一行在下方</li>
</ul>
<h4 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h4><p>flex-flow属性是flex-direction属性与flex-wrap属性的简写形式，默认值为row nowrap（水平排列，不换行）</p>
<h4 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h4><p>justify-content属性定义了项目在主轴上的对齐方式。（主轴如果是水平的话，那么就是定义项目是否水平居中那些的了）<br>它可能取5个值，具体对齐方式与主轴的方向有关，下面假设主轴为从左到右</p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center：居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等</li>
<li>space-around：每个项目两侧的间隔相等。所以，每个项目之间的间隔比项目与边框的间隔大一倍</li>
</ul>
<h4 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h4><p>align-it属性定义项目在交叉轴上如何对齐。（默认的就是垂直方向的居中那些问题啦）<br>它可能有五个值 </p>
<ul>
<li>flex-start:交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐（一般的话就是垂直居中啦）</li>
<li>baseline：项目的第一行文字的基线对齐。</li>
<li>stretch（默认）：如果项目未设置高度或设为auto，将占满整个容器的高度</li>
</ul>
<h4 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h4><p>align-content属性定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用<br>它可能的值有</p>
<ul>
<li>flex-start：与交叉轴的起点对齐</li>
<li>flex-end：与交叉轴的终点对齐</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间平均分布</li>
<li>space-around:每根轴线两侧的间隔都相等，所以轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴</li>
</ul>
<h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p>
<ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>blex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
<h4 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h4><p>order属性定义项目的排列顺序，数值越小，排列越靠前，默认为0.</p>
<h4 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h4><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br> <code>注</code> 如果所有的项目的flex-grow属性都为一，则它们将等分剩余空间(如果有的话)，如果每个项目的属性值不同，那么首先就是先把剩余空间等分成所有项目flex-grow值之和份，然后每个项目根据自己的flex-grow值分剩余空间。<br>例：三个项目，两个flex-grow值为1，一个值为2，则将剩余空间4等份，其中那个flex-grow值为2的项目分得2/4的剩余空间</p>
<h4 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h4><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br> <code>注</code>如果所有项目的flex-shrink属性都为1<br>负值对该属性无效</p>
<h4 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h4><p>flex-basis属性定义了再分配多余空间之前，项目占据主轴的空间。浏览器根据这个属性，计算主轴是否有多余的空间，它默认为auto，即项目的本来大小。</p>
<h4 id="4-5flex属性"><a href="#4-5flex属性" class="headerlink" title="4.5flex属性"></a>4.5flex属性</h4><p>flex属性是flex-grow，flex-shrink，flex-basis的简写，默认值为0 1 auto，后两个属性可选。（一般也是直接用这个）<br> <code>该属性有两个快捷键值：auto（1 1 auto）和none（0 0 auto）</code><br>然后肯定推荐用这个啦。</p>
<h4 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h4><p>align-self属性允许单个项目有着与其他项目不一样的对齐方式，可覆盖align-item属性，默认为auto，表示继承父元素的align-items属性，如果没有父元素，等同于stretch。<br>该属性和容器的align-items属性一样可能取6个值，除了auto，其他都和它一样。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本文学习自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">flex布局教程语法篇</a><br>（完）</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端布局</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>简单学习 Promise 对象</title>
    <url>/2018/10/24/learn-promise/</url>
    <content><![CDATA[<p><strong>引言</strong> Promise 是异步编程的一种解决方案，比传统的解决方案——回调和事件——更合理且强大。最近的项目要用到这个，就参考阮一峰老师的<a href="http://es6.ruanyifeng.com" target="_blank" rel="noopener">《ES6标准入门》</a>这本书简单学一下了。</p>
<h2 id="1-Promise-的含义"><a href="#1-Promise-的含义" class="headerlink" title="1 Promise 的含义"></a>1 Promise 的含义</h2><p>所谓 Promise ，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上来看，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise 对象有以下两个特点。</p>
<ol>
<li>对象的状态不受外界影响。</li>
<li>一旦状态改变就不会再变。</li>
</ol>
<h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2 基本用法"></a>2 基本用法</h2><p>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。<br>举个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功*/</span>) &#123;</span><br><span class="line">     resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异步操作失败</span></span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise 构造函数接收<code>一个函数</code>作为参数，该<code>函数</code>的两个参数分别是 <code>resolve</code> 和 <code>reject</code>。他们是两个函数，由 Javascript 引擎提供，不用自己部署。</p>
<p><code>resolve</code> 函数的作用是将 <code>Promise</code> 对象的状态从『未完成』（Pending）变为『成功』（Resolved），在异步操作成功的时候调用，并将异步操作的结果作为参数传递过去。 <code>reject</code> 函数的作用是，将 <code>Promise</code> 对象的状态从『未完成』（Pending）变为『失败』（Rejected）</p>
<p>当我们生成了一个 Promise 实例之后。就可以用 <code>then</code> 方法分别指定 <code>Resolved</code> 状态和 <code>Rejected</code> 状态的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failed</span></span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>then</code> 方法可以接受两个回调函数作为参数。第一个回调函数是 <code>Promise</code> 对象的状态变为 <code>Resolved</code> 时调用，第二个回调函数是 <code>Promise</code> 对象的状态变为 <code>Rejected</code> 时调用。其中第二个参数是可选的，不一定要提供。这两个函数都接收 <code>Promise</code> 对象传出的值作为参数。</p>
<p>我们来个小例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line">  <span class="keyword">let</span> value = <span class="string">'value'</span>;</span><br><span class="line">  resolve(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi</span></span><br><span class="line"><span class="comment">// value</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，Promise 新建后会立即执行，所以首先输出的是 <code>Promise</code>。然后，<code>then</code> 方法指定的回调函数将当前脚本所有同步任务执行完成后才会执行，所以 <code>Resolved</code> 最后输出。</p>
<h2 id="3-Promise-prototype-then"><a href="#3-Promise-prototype-then" class="headerlink" title="3 Promise.prototype.then()"></a>3 Promise.prototype.then()</h2><p>Promise 实例具有 <code>then</code> 方法，即 <code>then</code> 方法是定义在原型对象 <code>Promise.prototype</code> 上的。它的作用是为 Promise 实例添加改变状态时的回调函数。前面说过，<code>then</code> 方法的第一个参数是 <code>Resolved</code> 状态的回调函数，第二个参数（可选）是 <code>Rejected</code> 状态的回调函数。</p>
<p><code>then</code> 方法返回的是一个新的 <code>Promise 实例</code>（<code>注意</code> 不是原来的那个 Promise 实例）。因此可以采用链式写法，即 <code>then</code> 方法后面再调用另一个 <code>then</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码使用 <code>then</code> 方法依次指定了两个回调函数。第一个回调函数完成以后，将会返回结果作为参数，传入第二个回调函数。</p>
<p>然后采用链式的 <code>then</code> 可以指定一组按顺序调用的回调函数。这时，前一个回调函数有可能返回的还是一个 Promise 对象（即有异步操作），而后一个回调函数就会等待该 Promise 对象的状态发生变化，再被调用。</p>
<h2 id="4-Promise-prototype-catch"><a href="#4-Promise-prototype-catch" class="headerlink" title="4 Promise.prototype.catch()"></a>4 Promise.prototype.catch()</h2><p><code>Promise.prototype.catch</code> 方法是 <code>.then(null, rejection)</code> 的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>getJSON</code> 方法返回一个 Promise 对象，如果该对象状态变为 <code>Resolved</code>，则会调用 <code>then</code> 方法指定的回调函数；如果异步操作抛出错误，状态就会变成 <code>Rejected</code>，然后调用 <code>catch</code> 方法指定的回调函数处理这个错误。另外， <code>then</code> 方法指定的回调函数如果在运行中抛出错误，也会被 <code>catch</code> 方法捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'rejected'</span>, err));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .then(<span class="literal">null</span>, (err) =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected:"</span>, err));</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，Promise 抛出一个错误就被 <code>catch</code> 方法指定的回调函数所捕获。注意，上面的写法和下面两种写法是等价的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>由上面可以看出， <code>reject</code> 方法的作用等同于抛出错误。<br>如果 <code>Promise</code> 状态已经变成 Resolved，在抛出错误是无效的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  <span class="comment">// Promise 状态已变成 已完成</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong> 一般来说，不要在 <code>then</code> 方法中定义 <code>Reject</code> 状态的回调函数（即 <code>then</code> 的第二个参数），而是使用 <code>catch</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面 <code>then</code> 方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用 <code>catch</code> 方法，而不使用 <code>then</code> 方法的第二个参数。</p>
<h2 id="5-Promise-all"><a href="#5-Promise-all" class="headerlink" title="5 Promise.all()"></a>5 Promise.all()</h2><p><code>Promise.all</code> 方法是将多个 Promise 对象实例包装成一个新的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>Promise.all()</code> 方法接受一个数组作为参数，p1, p2, p3 都是 Promise 对象的实例。如果不是，就会先调用下面讲到的 <code>Promise.resolve</code> 方法，将参数转换为 Promise 实例，再进一步处理（<code>Promise.all</code> 方法的参数不一定是数组，但是必须具有 <code>Iterator</code> 接口，且每个返回成员都是 Promise 实例）。</p>
<p>p 的状态由 p1, p2, p3 决定，分成两种情况</p>
<ol>
<li>只有 p1, p2, p3 的状态都变成 FulFilled，p 的状态才会变成 FulFilled，此时 p1, p2, p3 的返回值组成一个数组，传递给 p 的回调函数。</li>
<li>只要 p1，p2，p3 中有一个被 Rejected ，p 的状态就直接变成 Rejected，此时第一个被 Rejected 的实例的返回值会传递给 p 的回调函数。</li>
</ol>
<p>下面是一个具体例子。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promises = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(id)</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">      resolve</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先执行所有 promise 实例的异步操作，然后吧操作的结果打包数组返回</span></span><br><span class="line"><span class="comment">// 2 3 4 5 [undefined,undefined,undefined,undefined]</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，Promise 是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成 fulfilled，或者其中有 1 个变成 rejected，才会调用 <code>Promise.all</code> 方法后面的回调函数。</p>
<h2 id="6-Promise-race"><a href="#6-Promise-race" class="headerlink" title="6 Promise.race()"></a>6 Promise.race()</h2><p><code>Promise.race</code> 方法同样是将多个 Promise 实例包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([p1, p2, p])</span><br></pre></td></tr></table></figure>
<p>上面的代码中，只要 p1, p2, p3 中 <code>有一个实例</code> 率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值就传递给 p 的回调函数。<br><code>Promise.race</code> 方法的参数与 <code>Promise.all</code> 方法一样，如果不是 Promise 实例，就会先调用下面讲到的 <code>Promise.resolve</code> 方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子,如果指定时间内没有获得结果，就将 Promise 的状态变成 Rejected，否则就变为 Resolved。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果 5 秒之内 <code>fetch</code> 方法无法返回结果，变量 p 的状态就会变为 rejected，从而触发 <code>catch</code> 方法指定的回调函数。</p>
<h2 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7 Promise.resolve()"></a>7 Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve</code> 方法就起到这个作用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>
<p>上面代码将 jQuery 生成的 deferred 对象，转为一个新的 Promise 对象。</p>
<p><code>Promise.resolve</code> 等价于下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure>
<p>Promise.resolve方法的参数分成四种情况。</p>
<h3 id="7-1-参数是一个-Promise-实例"><a href="#7-1-参数是一个-Promise-实例" class="headerlink" title="7.1 参数是一个 Promise 实例"></a>7.1 参数是一个 Promise 实例</h3><p>如果参数是一个 Promise 实例，那么 <code>Promise.resolve</code> 将不做任何修改，原封不动的返回这个实例。</p>
<h3 id="7-2-参数是一个-thenable-对象"><a href="#7-2-参数是一个-thenable-对象" class="headerlink" title="7.2 参数是一个 thenable 对象"></a>7.2 参数是一个 thenable 对象</h3><p>thenable 对象是指具有 then 方法的对象，例如下面这个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Promise.resolve</code> 方法会将这个对象转为 Promise 对象，任何执行 thenable 对象的 then 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码中， thenable 对象的 then 方法执行后，对象 p1 的状态就变为 resolved，从而立即执行最后的 then 方法指定的回调函数。输出 42。</p>
<h3 id="7-3-参数不是具有-then-方法的对象，或根本就不是对象"><a href="#7-3-参数不是具有-then-方法的对象，或根本就不是对象" class="headerlink" title="7.3 参数不是具有 then 方法的对象，或根本就不是对象"></a>7.3 参数不是具有 then 方法的对象，或根本就不是对象</h3><p>如果参数是一个原始值，或者是一个不具有 then 方法的对象，那么 <code>Promise.resolved</code> 方法返回一个新的 Promise 对象，状态为 Resolved。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<p>上面代码生成一个新的 Promise 对象的实例 p。由于字符串 Hello 不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是 resolved，所以回调函数会立即执行。<code>Promise.resolve</code> 方法的参数，会同时传给回调函数。</p>
<h3 id="7-4-不带有任何参数"><a href="#7-4-不带有任何参数" class="headerlink" title="7.4 不带有任何参数"></a>7.4 不带有任何参数</h3><p><code>Promise.resolved</code> 方法允许在调用时不带有参数，而直接返回一个 Resolved 状态的 Promise 对象。</p>
<p>所以，如果你希望得到一个 Promise 对象，比较方便的方法就是直接调用 <code>Promise.resolve</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中的 p 就是一个 Promise 对象。<br>需要注意的是，立即 resolve 的 Promise 对象实在本轮 『事件循环』（event loop）结束时，而不是在下一轮『事件循环』开始时。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>setTimeout(fn, 0)</code> 在下一轮『事件循环』开始时执行，<code>Promise.resolve()</code> 在本轮『事件循环』结束时执行，<code>console.log(&#39;one&#39;)</code> 则是立即执行，因此最先输出。</p>
<h2 id="8-Promise-reject"><a href="#8-Promise-reject" class="headerlink" title="8 Promise.reject()"></a>8 Promise.reject()</h2><p><code>Promise.reject(resson)</code> 方法也会返回一个新的 Promise 实例，状态为 Rejected （这个就暂时想不懂怎么应用了）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>
<p>上面的代码生成一个 Promise 对象的实例 p，状态为 Rejected，回调函数会立即执行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于 Promise 学习的内容，如有错误的地方就请在下面评论处，发表一下看法，当然也可以放一下关于进阶学习 Promise 的文章，大家一起学习。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 模块化知识</title>
    <url>/2018/11/02/js-module/</url>
    <content><![CDATA[<p><strong>前言</strong><br>最近遇到很多朋友问 Javascript 模块化使用的问题，然后发现对这这个也是一知半解，偶尔还会搞混，在项目中使用的时候会出各种小错误，所以就写一下，复习一下 Javascript 模块化的知识和使用方式。</p>
<p>模块通常是指编程语言所提供的代码组织机制，利用此机制可将程序拆解为独立且通用的代码单元。所谓模块化主要是解决代码分割、作用域隔离、模块之间的依赖管理以及发布到生产环境时的自动化打包与处理等多个方面。</p>
<h2 id="1-模块化的优点"><a href="#1-模块化的优点" class="headerlink" title="1 模块化的优点"></a>1 模块化的优点</h2><ol>
<li>可维护性。因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进。</li>
<li>命名空间。在 JavaScript 里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化开发来封装变量，可以避免污染全局环境。</li>
<li>重用代码。我们有时候会喜欢从之前写过的项目中拷贝代码到新的项目，这没有问题，但是更好的方法是，通过模块引用的方式，来避免重复的代码库。</li>
</ol>
<h2 id="2-模块化规范"><a href="#2-模块化规范" class="headerlink" title="2 模块化规范"></a>2 模块化规范</h2><h3 id="2-1-CommonJS-规范"><a href="#2-1-CommonJS-规范" class="headerlink" title="2.1 CommonJS 规范"></a>2.1 CommonJS 规范</h3><p>CommonJS 是 Mozilla 的工程师于 2009 年开始的一个项目，他的目的是让浏览器之外的 Javascript （比如服务器端或者桌面端）能够通过模块化的方式来开发和协作。</p>
<p>在 CommonJS 规范中，每个 JS 文件就是一个独立的模块上下文（module context），在这个上下文中创建的属性都是私有的。也就是说，在一个文件定义的变量（包括函数和类），都是私有的，对其他文件是不可见的。</p>
<h4 id="2-1-1-实例"><a href="#2-1-1-实例" class="headerlink" title="2.1.1 实例"></a>2.1.1 实例</h4><p>这里分两种情况讲明吧，一种是一个文件中导出一个模块，这种我们引入模块的时候可以定义随便一个变量名去接入使用模块。另外则是一个文件中导出多个模块。这种情况的话，模块文件导出的是一个包含多个模块的对象，我们导入引用的时候只能是用一个对象 {} 引用，然后这边使用的模块名必须要和源文件中导出的模块名一致。（这边有点绕，具体看代码就明白了）</p>
<ul>
<li>一个文件导出一个模块</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sayHello.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = sayHello</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js 中引入 sayHello.js</span></span><br><span class="line"><span class="comment">// 引入单个模块，这里引入的时候可以 say，sayHello 等等变量名去定义导入的模块 </span></span><br><span class="line"><span class="keyword">const</span> say = <span class="built_in">require</span>(<span class="string">'./sayHello.js'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>一个文件导出多个模块</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// say.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayBye</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bye'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;sayBye,sayHi&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* main.js</span></span><br><span class="line"><span class="comment">*  这个时候引用的话，用&#123;&#125;去引用导出的模块，怎么导出我们就怎么引用，然后里面的模块名就只能是引用文件 say.js 里面定义的 sayBye，sayHi 变量名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> &#123;sayBye, sayHello&#125; = <span class="built_in">require</span>(<span class="string">'./say.js'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-注意事项"><a href="#2-1-2-注意事项" class="headerlink" title="2.1.2 注意事项"></a>2.1.2 注意事项</h4><p>因为 CommonJS 规范主要应用的场景是服务器端，所以采用同步加载模块的策略。如果我们依赖 3 个模块，代码会一个一个一次加载，这种的话就不适合浏览器端来使用了。</p>
<h3 id="2-2-AMD-规范"><a href="#2-2-AMD-规范" class="headerlink" title="2.2 AMD 规范"></a>2.2 AMD 规范</h3><p>AMD 是 Asynchronous Module Definition 的简称，即『异步模块定义 』，见名知义，AMD 优先照顾浏览器模块的加载场景，使用异步加载和回调的方式。<code>注意</code>使用模式需要 define 方法的支持。一般是引用 <a href="http://www.requirejs.cn/" target="_blank" rel="noopener">requireJS</a></p>
<h4 id="2-2-1-实例"><a href="#2-2-1-实例" class="headerlink" title="2.2.1 实例"></a>2.2.1 实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file lib/sayModule.js </span></span><br><span class="line"> </span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;            </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'hello'</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line"><span class="comment">//file main.js </span></span><br><span class="line"> </span><br><span class="line">define([<span class="string">'./lib/sayModule'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">say</span>)</span>&#123; </span><br><span class="line">    say.sayHello(); <span class="comment">//hello </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这种形式感觉有点烦，个人基本都没怎么用。</p>
<h3 id="2-3-CMD-规范"><a href="#2-3-CMD-规范" class="headerlink" title="2.3 CMD 规范"></a>2.3 CMD 规范</h3><p>CMD 是 Common Module Definition，公共模块定义，</p>
<h3 id="2-4-ES6-规范"><a href="#2-4-ES6-规范" class="headerlink" title="2.4 ES6 规范"></a>2.4 ES6 规范</h3><p>ES6 规范用的就比较多了，他的话比较简单清晰，就分为导出（export）与导入（import）两个模块 然后他的使用方式也是有很多种情况。</p>
<ol>
<li>直接用 export {模块，模块} 导出。引用的话就直接用 import from 导出就可以了。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;fn, bar&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar, fn&#125; <span class="keyword">from</span> <span class="string">'./module'</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>重命名导出与导入。有时候发现我引用了两个文件的模块的名字是一样的，然后就会出现命名冲突了，这个时候就需要重命名导出导入来解决这种情况了，具体就看代码了。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出重命名</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'name'</span>;</span><br><span class="line"><span class="comment">// 这个时候其他文件导入的时候就用 newName 导入了</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> newName&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入重命名</span></span><br><span class="line"><span class="comment">// 这样我们就用 newName 这个名字重命名原来的模块了。</span></span><br><span class="line"><span class="keyword">import</span> &#123; moduleName <span class="keyword">as</span> newName&#125; <span class="keyword">from</span> <span class="string">'test'</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>export default 匿名导出，如果只想导出一个 js 模块或者功能，可以直接用 export default 导出</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module.js 字符串，方法，对象，想导出啥就导出啥</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'string'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js XX YY，想用啥命名就用啥命名，毕竟导出的就只有一个对象</span></span><br><span class="line"><span class="keyword">import</span> XXX <span class="keyword">from</span> <span class="string">'./lib'</span></span><br><span class="line"><span class="built_in">console</span>.log(XXX) <span class="comment">// 'string'</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般就用 ES6 的规范和 CommonJS 的规范，AMD 和CMD 实在不熟，就没用过了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>CommonJS</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>Node 项目调试</title>
    <url>/2019/07/02/node-debug/</url>
    <content><![CDATA[<p><strong>前言</strong> 作为一个程序员，感觉我们其实打代码的时间不多，大部分时间都在在调试上，所以如何调高我们调试的效率，这就成了我们的一个大问题了，经过在网上的搜索与自己的探索，就推荐这两种好用的 Node 调试方法吧</p>
<h2 id="1-Chrome-调试"><a href="#1-Chrome-调试" class="headerlink" title="1 Chrome 调试"></a>1 Chrome 调试</h2><p>因为 V8 检查器集成允许使用 Chrome 调试协议将 Chrome DevTools 附加到 Node.js 实例以进行调试。所以我们可以直接用 Chrome 进行调试。<br>这个就最简单的的方法，直接在运行代码的地方加个前缀 <code>--inspect</code>，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node --inspect /bin/www</span><br></pre></td></tr></table></figure></p>
<p>这个时候我们在控制台会看到多出这么几个提示<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Debugger listening on ws://127.0.0.1:9229/f54d4cb8-56bc-46c4-9b8e-fd7f2163c73c</span><br><span class="line">For help, see: https://nodejs.org/en/docs/inspector</span><br><span class="line">Debugger attached.</span><br></pre></td></tr></table></figure></p>
<p>看到这个我们打开 Chrome，f12 打开控制台，点击上面的 Node 图标</p>
<p><img src="http:img.cdn.lijiayuan.top/node/node-debug1.png" alt="image"></p>
<p>我们就可以打开一个新的调试 Node 的浏览器窗口，我们在代码中打的 debugger 和 console.log 都会在那个窗口显示和输出出来。</p>
<p><img src="http:img.cdn.lijiayuan.top/node/node-debug2.png" alt="image"></p>
<h2 id="2-VS-Code-大法"><a href="#2-VS-Code-大法" class="headerlink" title="2 VS Code 大法"></a>2 VS Code 大法</h2><p>在 VS Code 中调试步骤也是比较简单，<br>1、 点击蜘蛛图标，打开调试控制台</p>
<p><img src="http:img.cdn.lijiayuan.top/node/node-debug3.png" alt="image"></p>
<p>2、选择一下调试环境</p>
<p>这里我们就直接选 Node的了的啦</p>
<p><img src="http:img.cdn.lijiayuan.top/node/node-debug4.png" alt="image"></p>
<p>3、配置调试模式<br>我们选择好环境之后，他会弹出一个 <code>launch.json</code> 的配置文件，这里面我们可以 VS Code 有很多调试模式，我们可以通过 <code>add configurations</code> 添加调试模式。等到我们要调试的时候就在 debug 菜单那边选模式，然后点击绿色三角开始调试。下面我们着重介绍一下几个常见的模式吧</p>
<h3 id="2-1-VS-Code-Node-调试模式"><a href="#2-1-VS-Code-Node-调试模式" class="headerlink" title="2.1 VS Code Node 调试模式"></a>2.1 VS Code Node 调试模式</h3><h4 id="2-1-1-attach-模式"><a href="#2-1-1-attach-模式" class="headerlink" title="2.1.1 attach 模式"></a>2.1.1 attach 模式</h4><p>这个先拉出来说，因为后面几个模式都是通过 VS Code 启动项目的，而这个模式是你项目已经启动的情况下启用的，并且那项目还是开启了 Chrome 调试的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// launch.json</span><br><span class="line">// port 填 Chrome 调试的端口地址，一般都是 9229</span><br><span class="line">&quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;type&quot;: &quot;node&quot;,</span><br><span class="line">        &quot;request&quot;: &quot;attach&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Attach to Port&quot;,</span><br><span class="line">        &quot;address&quot;: &quot;localhost&quot;,</span><br><span class="line">        &quot;port&quot;: 9229</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h4 id="2-1-2-node-模式"><a href="#2-1-2-node-模式" class="headerlink" title="2.1.2 node 模式"></a>2.1.2 node 模式</h4><p>这个其实一开始的时候生成的配置就是 node 启动形式，代码如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// launch.json</span><br><span class="line">&quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;type&quot;: &quot;node&quot;,</span><br><span class="line">        &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Launch Program&quot;,</span><br><span class="line">        &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/bin/www&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>选择后模式之后，我们点击调试控制台的绿三角就可以启动调试了。</p>
<h4 id="2-1-3-nodemon-模式"><a href="#2-1-3-nodemon-模式" class="headerlink" title="2.1.3 nodemon 模式"></a>2.1.3 nodemon 模式</h4><p>我们调试的时候肯定要修修改改，如果只是用 node 启动的话，我们每次修改后都要重新启动项目，这样是很费时间的，所以我们可以借助一些依赖来实现 node 项目的热重载，比如这个 nodemon， 然后 VS Code 也有这么一个对应的模式。</p>
<p>不过要注意，想用调用这个调试模式，你电脑必须全局 安装 nodemon，否跑不起来。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// launch.json</span><br><span class="line">&quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;type&quot;: &quot;node&quot;,</span><br><span class="line">        &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;nodemon&quot;,</span><br><span class="line">        &quot;runtimeExecutable&quot;: &quot;nodemon&quot;,</span><br><span class="line">       &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/bin/www&quot;,</span><br><span class="line">        &quot;restart&quot;: true,</span><br><span class="line">        &quot;console&quot;: &quot;integratedTerminal&quot;,</span><br><span class="line">        &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>和上面一样这个也是在 VS Code 里面启动调试的。</p>
<p>大概就是这些吧，当然 Node 调试还有很多方式，这些就看大家喜欢然后自己去摸索了。最后唠叨一句，debug 是个好东西，大家要用好他。</p>
]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>Node debug</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 Node 开发环境</title>
    <url>/2019/06/19/node-envi/</url>
    <content><![CDATA[<h2 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1 下载安装包"></a>1 下载安装包</h2><p>两种方式，<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">官网</a>下载最新 LTS 版本的或者到提取我的网盘文件（当前版本是 10.16.0） </p>
<p>链接：<a href="https://pan.baidu.com/s/1Ztsq550dPimkUAXsDyEoPA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Ztsq550dPimkUAXsDyEoPA</a> </p>
<p>提取码：pb2w </p>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h2><p>跟安装普通软件一样安装，到了下面这一步的时候，可以自己选择安装的位置</p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/no1.png" alt="image"></p>
<p>然后一路安装就可以了。</p>
<h2 id="3-检测"><a href="#3-检测" class="headerlink" title="3 检测"></a>3 检测</h2><p>往控制台中分别输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v, npm -v</span><br></pre></td></tr></table></figure></p>
<p>出现下面的结果的话，接表示我们已经可以使用 node 开发了。</p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/no2.1.png" alt="image"></p>
<h2 id="4-修改全局-npm-包的位置"><a href="#4-修改全局-npm-包的位置" class="headerlink" title="4 修改全局 npm 包的位置"></a>4 修改全局 npm 包的位置</h2><p>虽然做完上面的事情我们就已经可以开发了，但是它默认的全局 npm 包是放在系统盘的，要是我们以后安装太多全局 npm 包的话，会占系统盘很大空间的，这种情况肯定不好啦。所以我们要修改我们全局 npm 包的位置。（如果你系统盘留着非常多的空间的话那就随意了）</p>
<p>这个其实很简单，npm 自己可以设置，我们只要在控制台运行下面的脚本就可以修改全局 npm 包的位置了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\nodejs\npm_global&quot;</span><br><span class="line">npm config set cache &quot;D:\nodejs\npm_cache&quot;</span><br></pre></td></tr></table></figure></p>
<p>修改之后运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config ls</span><br></pre></td></tr></table></figure>
<p>查看配置</p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/no8.png" alt="image"></p>
<p>这样就差不多了。</p>
<p>然后我尝试全局安装一下 vue-cli 脚手架，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure>
<p>安装过后，我们到 npm_global 目录下的 node_modules 看一下，已经安装成功，事实上这就是全局包的安装路径</p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/no5.png" alt="image"></p>
<p>我们尝试在控制台运行一下 vue-cli</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue inti webpack demo</span><br></pre></td></tr></table></figure>
<p>但是会发现会报错，这是因为我们修改了路径，但是还没配环境变量，所以我们就需要打开环境变量配置。</p>
<p>首先新建一个 <code>NODE_PATH</code>,变量值为设置的安装路径下的 <code>node_modules</code> 文件夹</p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/no6.png" alt="image"></p>
<p>然后往 path 变量中添加一个值（值为全局安装路径的地址），如下图</p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/no7.png" alt="image"></p>
<p>然后我们就可以愉快的去使用全局 npm 包啦。</p>
<h2 id="5-安装-cnpm"><a href="#5-安装-cnpm" class="headerlink" title="5 安装 cnpm"></a>5 安装 cnpm</h2><p>由于 npm 的站点在国外，有时候网络不好安装依赖需要很久，这个时候我们可以使用淘宝的 cnpm 镜像来安装项目依赖。首先我们运行下面的指令安装 cnpm。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>然后我们输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure></p>
<p>来查看 cnpm 的版本，顺便确定是否成功安装了 cnpm ,如果能看到了 cnpm 的版本号，那就说明安装成功了，我们就可以使用 <code>cnpm install</code> 来替代 <code>npm install</code> 安装项目依赖了。</p>
<p><strong>友情提示</strong>:我们最好还是用 npm 去安装项目依赖，但是要是网络不好用 npm 装依赖久到怀疑人生的时候就用 cnpm 去安装项目依赖。</p>
<p>至此，我们 node 的环境也配置完成了，后面就可以进一步的去学习和使用了。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>搭建环境</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 父子组件间的通信</title>
    <url>/2018/11/25/parent-child-talk/</url>
    <content><![CDATA[<p><strong>前言</strong> 在 Vue 项目中父子组件的通信是非常常见的，最近做项目的时候发现对这方面的知识还不怎么熟练，在这边做一下笔记，系统学习一下吧。</p>
<h2 id="1-父组件传值给子组件"><a href="#1-父组件传值给子组件" class="headerlink" title="1 父组件传值给子组件"></a>1 父组件传值给子组件</h2><h3 id="1-1-传值写法"><a href="#1-1-传值写法" class="headerlink" title="1.1 传值写法"></a>1.1 传值写法</h3><p>父组件传值给子组件，这个就比较常见了，直接用 props 就可以了。但是就算是 props 子组件那边也有三种写法，如下面代码所示：<br>父组件<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 两种情况 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--静态传值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">name</span>=<span class="string">"xhm"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--动态传值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:name</span>=<span class="string">"userName"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>子组件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 简单粗暴就给个名称的情况</span></span><br><span class="line">props:[<span class="string">'name'</span>],</span><br><span class="line"><span class="comment">// 2 给个名称顺便指定个类型，如果父组件传递过来的值类型不对的话就会报错</span></span><br><span class="line">props:&#123;</span><br><span class="line">    name:<span class="built_in">String</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 3 给个名称不仅指定了类型，还顺便送了个默认值,当父组件传个空过来或者啥都没传过来的时候就用默认值了</span></span><br><span class="line">props: &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">'xhm'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>注意一下的话，如果是数组或者是对象要默认值的话，直接设置默认数组或者默认对象会报错，需要用工厂函数返回，如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  arr:&#123;</span><br><span class="line">    type:<span class="built_in">Array</span>,</span><br><span class="line">    <span class="keyword">default</span>:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 对象也是和上面一个用工厂函数</span></span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-子组件使用父组件的值"><a href="#1-2-子组件使用父组件的值" class="headerlink" title="1.2 子组件使用父组件的值"></a>1.2 子组件使用父组件的值</h3><p>由于单向数据流的限制，我们不能直接在子组件中修改 props 的值，当我们修改的时候会报错,官方的说法是：</p>
<blockquote>
<p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
</blockquote>
<blockquote>
<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
</blockquote>
<p>所以啊，如果你不只是想在子组件中简单的渲染父组件传过来的值的话，那么可以用下面的两种方法。</p>
<ol>
<li><p><code>这个 prop 用来传递一个初始值；</code>这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'name'</span>],</span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    userName:<span class="keyword">this</span>.name,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>这个 prop 以一种原始的值传入且需要进行转换。</code>在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'name'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  userName()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-子组件传值给父组件"><a href="#2-子组件传值给父组件" class="headerlink" title="2 子组件传值给父组件"></a>2 子组件传值给父组件</h2><p>虽然我们说是要单向数据流，但是很多时候，我们在子组件改变了某些值之后，还是要反馈给父组件，让父组件做一下修改，那么这个时候就要想着子组件向父组件传值啦。有下面这么两种方式</p>
<h3 id="2-1-emit-方法"><a href="#2-1-emit-方法" class="headerlink" title="2.1 emit 方法"></a>2.1 emit 方法</h3><p>这个基本都是用 emit 来传递了，用法直接看代码吧：<br>子组件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// props:['name]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// methods 里</span></span><br><span class="line">update()&#123;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">'update'</span>,<span class="string">'ljy'</span>);</span><br><span class="line">  <span class="comment">// 第一个参数：事件名，第二个参数：传递给事件方法的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>父组件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* template 里面的代码，监听子组件里面的 update 事件，调用父组件的 childUpdate 方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> &lt;child :name="userName" @update="childUpdate"&gt;&lt;/child&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// methods</span></span><br><span class="line">chidlUpdate(val)&#123;</span><br><span class="line">  <span class="comment">// val 参数就是子组件传递过来的数据</span></span><br><span class="line">  <span class="keyword">this</span>.userName = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然这样是可以实现子组件向父组件传值，但是写多一个方法感觉很烦，所以 vue 官方高出了一个 <code>以 update:myPropName 的模式触发事件。</code>，这个是啥，举个例子，我们的子组件中有一个 <code>name</code> 的 props，我们用下面这个形式通知父组件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:name'</span>, newName)</span><br><span class="line"><span class="comment">// this.$emit('update:props中的变量名', 新的值)</span></span><br></pre></td></tr></table></figure></p>
<p>然后父组件可以监听那个事件并根据需要更新一个本地的数据属性:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:name</span>=<span class="string">"userName"</span> @<span class="attr">update:name</span>=<span class="string">"userName = $event"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样当我们在子组件触发那个修改的方法的时候，父组件的 <code>userName</code> 变量就会更新为 <code>newName</code>了，然后为了方便起见，官方提供了一个缩写，即 <strong><code>.sync</code></strong> 修饰符。看代码吧：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:name.sync</span>=<span class="string">"userName"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码和前面的代码是一个效果，是不是方便了很多。舒服了吧。</p>
<h3 id="2-2-利用浅拷贝（不推荐）"><a href="#2-2-利用浅拷贝（不推荐）" class="headerlink" title="2.2 利用浅拷贝（不推荐）"></a>2.2 利用浅拷贝（不推荐）</h3><p>这个的话是针对于 对象和数组那些引用类型的数据而言的，由于这些存在浅拷贝的问题（不明白浅拷贝的看这篇<a href="https://lijiayuan.top/2018/11/25/deepcopy-shallowcopy-in-JS/" target="_blank" rel="noopener">文章</a>），所以可以利用这点来实现子父组件的「同生共死」，看代码吧<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 name 是一个对象或者数组</span></span><br><span class="line">props:[<span class="string">'name'</span>],</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  userName:<span class="keyword">this</span>.name,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>就这样？！ </p>
<p>没错就是这么简单粗暴，由于浅拷贝的问题，我们在子组件修改 <code>userName</code> 的时候，从父组件传递过来的那个值也会改变的，然后就会实现 props 的「双向绑定」了。但是一般没人会这么干，因为这样会造成维护上的问题，会让人觉得咋没干啥父组件的值咋就变了，会让人头秃啊，所以除非你项目中非得要搞这么一个子父组件 props 的「同生共死」，那就这么干吧。</p>
<h2 id="3-子组件调用父组件的方法"><a href="#3-子组件调用父组件的方法" class="headerlink" title="3 子组件调用父组件的方法"></a>3 子组件调用父组件的方法</h2><p>不知道这样的叫法对不对，反正就这样啦。总结之后又下面这几种方法</p>
<h3 id="3-1-emit"><a href="#3-1-emit" class="headerlink" title="3.1 emit"></a>3.1 emit</h3><p>其实本来 emit 就是用于子组件向父组件通信的，上面的子组件传值给父组件其实也就是父组件监听子组件的事件，然后触发父组件的方法的，换个说法，也就是子组件调用了父组件的方法，再写一下代码吧：</p>
<p>子组件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// methods 里</span></span><br><span class="line">update()&#123;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">'update'</span>,<span class="string">'ljy'</span>);</span><br><span class="line">  <span class="comment">// 第一个参数：事件名，第二个参数：传递给事件方法的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>父组件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* template 里面的代码，监听子组件里面的 update 事件，调用父组件的 childUpdate 方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> &lt;child :name="userName" @update="childUpdate"&gt;&lt;/child&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// methods</span></span><br><span class="line">chidlUpdate(val)&#123;</span><br><span class="line">  <span class="comment">// val 参数就是子组件传递过来的数据</span></span><br><span class="line">  <span class="keyword">this</span>.userName = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，从某种意义上来说，就是子组件调用了父组件的 <code>childUpdate</code> 方法。</p>
<h3 id="3-2-this-paarent-event"><a href="#3-2-this-paarent-event" class="headerlink" title="3.2 this.$paarent.event"></a>3.2 this.$paarent.event</h3><p>这个就比较简单了，我们假设我们在父组件定义了一个 <code>fatherMethod()</code> 方法，然后我们子组件就可以通过下面的代码实现调用  <code>fatherMethod()</code> 的方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">childClick()&#123;</span><br><span class="line">  <span class="keyword">this</span>.$parent.fatherMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-props"><a href="#3-3-props" class="headerlink" title="3.3 props"></a>3.3 props</h3><p>props 能传递 Function 类型的数据，所以，我们通过 props 当然也是可以直接的调用父组件传递过来的方法啦。不多说，直接撸代码：<br>父组件<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 假设父组件里定义了一个 fatherMethod() 方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:fatherMethod</span>=<span class="string">"fatherMethod"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>子组件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  fatherMethod: &#123;</span><br><span class="line">    type: <span class="built_in">Function</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  childClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.fatherMethod();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>这样我们也是调用了父组件的方法啦。</p>
<h2 id="4-父组件调用子组件的方法"><a href="#4-父组件调用子组件的方法" class="headerlink" title="4 父组件调用子组件的方法"></a>4 父组件调用子组件的方法</h2><p>这个，暂时没有遇到过这种情况，不过以备不时之需，也写一下吧。父组件调用子组件的方法的话是利用 ref 获取到子组件实例，从而调用子组件的方法，假设我们子组件有这么一个 <code>childMethod()</code> 方法。那么我们的父组件就可以这么来调用子组件的方法了<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &lt;child ref="con"&gt;&lt;/child&gt; 子组件 */</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.con.childMethod();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，关于父子组件通信的的话题就聊到这边了，如果有啥错误或者遗漏的，欢迎在下面斧正啦。</p>
]]></content>
  </entry>
  <entry>
    <title>搭建 Python 开发环境</title>
    <url>/2019/06/19/python-envi/</url>
    <content><![CDATA[<h2 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1 下载安装包"></a>1 下载安装包</h2><p>Python 的话有很多个版本，我们自己学习的话就用用的比较多的 Python 3.5 的版本，官网 3.5 版本已经没有安装包了，只有源代码了，所以大家就到我百度网盘去下载 3.5 的版本。</p>
<p>链接：<a href="https://pan.baidu.com/s/1s-dRnouVI_eojPKnJYDAoQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1s-dRnouVI_eojPKnJYDAoQ</a> </p>
<p>提取码：8kgy </p>
<h2 id="2-安装配置"><a href="#2-安装配置" class="headerlink" title="2 安装配置"></a>2 安装配置</h2><p>不得不说，Python 用起来方便，安装配置也是相当方便，我们直接打开安装包，勾选下面的“Add Python 3.5 to PATH”，如下图。</p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/py1.png" alt="image"></p>
<p>接着我们可以选择默认的直接安装到系统盘，或者点击那个“Customize installation”自定义安装目录再直接安装，安装好了就可以直接使用 Python 开发了。</p>
<h2 id="3-检测"><a href="#3-检测" class="headerlink" title="3 检测"></a>3 检测</h2><p>安装完环境，老规矩，检查一下成功没。我们打开控制台输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -v</span><br></pre></td></tr></table></figure></p>
<p>如果和下面一样出现 Python 的版本号就代表我们已经成功搭建好 Python 的开发环境了。</p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/py3.png" alt="image"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>搭建环境</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化使用 Vuex</title>
    <url>/2019/07/30/module-use-vuex/</url>
    <content><![CDATA[<p><strong>前言</strong> 上回我们说了一下 vuex 的简单使用，最后面的时候有说了，由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割，今天我们也来简单了解一下他的使用，深入学习可能还是要去看<a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="1-文件结构"><a href="#1-文件结构" class="headerlink" title="1 文件结构"></a>1 文件结构</h2><p>文件结构的话，模块化的使用要多一个 modules 的文件夹，里面放着细分模块的 js 文件/模块名文件夹。</p>
<p>这里官方的标准是一个模块一个 js 文件，但是要是模块太复杂的话，也可以把里面的代码拆分出来。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// store 文件夹 </span><br><span class="line">│  actions.js</span><br><span class="line">│  getters.js</span><br><span class="line">│  index.js</span><br><span class="line">│  mutations.js</span><br><span class="line">│  state.js</span><br><span class="line">│</span><br><span class="line">└─modules</span><br><span class="line">    │  moduleB.js</span><br><span class="line">    │</span><br><span class="line">    └─moduleA</span><br><span class="line">            index.js</span><br><span class="line">            mutation.js</span><br><span class="line">            state.js</span><br></pre></td></tr></table></figure></p>
<p>然后在创建 store 的 js 文件中引入这些模块，直接<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> moduleA <span class="keyword">from</span> <span class="string">'./modules/moduleA/index'</span></span><br><span class="line"><span class="keyword">import</span> moduleB <span class="keyword">from</span> <span class="string">'./modules/moduleB'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    getters,</span><br><span class="line">    mutations,</span><br><span class="line">    actions,</span><br><span class="line">    modules: &#123;</span><br><span class="line">        moduleA,</span><br><span class="line">        moduleB,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="2-模块的局部状态对象的定义"><a href="#2-模块的局部状态对象的定义" class="headerlink" title="2 模块的局部状态对象的定义"></a>2 模块的局部状态对象的定义</h2><p>模块内部的 getter，mutation 和 action，他们方法接收的参数会和根状态的不一样，我们一个一个来</p>
<ul>
<li>getter</li>
</ul>
<p>getter 的话，他会有三个参数，第一个是模块内的 state，第二个是 模块内的 getters，第三个是根节点状态 rootState，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  bFullName: <span class="function">(<span class="params">state, getters, rootState</span>) =&gt;</span> <span class="string">`full<span class="subst">$&#123;state.bName&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mutation</li>
</ul>
<p>mutation 里面的回调函数传入的第一个参数也是 模块内的 state，其他和根状态定义的时候一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="comment">// 这里的 `state` 对象是模块的局部状态</span></span><br><span class="line">  SET_B_NAME(state, payload) &#123;</span><br><span class="line">    <span class="keyword">debugger</span></span><br><span class="line">    state.bName = payload.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>action</li>
</ul>
<p>最后的 action 的话，他传入还是只有 context 对象，然后咧，这个对象里面的 state 属性指模块内的状态，rootState 指根状态，如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  ASYNC_SET_NAME(&#123; state, commit, rootState &#125;, payload) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      state.bName = <span class="string">'asyncName'</span></span><br><span class="line">    &#125;, <span class="number">4000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h2><h3 id="3-1-state-获取"><a href="#3-1-state-获取" class="headerlink" title="3.1 state 获取"></a>3.1 state 获取</h3><p>这个的话要在原来状态名前面加一个模块名才能放到到模块内的对象。具体如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原先的基础上加个模块名</span></span><br><span class="line"><span class="keyword">this</span>.$store.state.moduleB.bName;</span><br><span class="line"><span class="comment">// 辅助函数也一样，name 前面加个模块名 Deno</span></span><br><span class="line">...mapState(&#123;</span><br><span class="line">    name: <span class="function"><span class="params">state</span> =&gt;</span> state.moduleB.bName,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-命名空间"><a href="#3-3-命名空间" class="headerlink" title="3.3 命名空间"></a>3.3 命名空间</h3><p>getter，mutation，action 他们默认都是注册在全局命名空间的，所以我们默认是可以和使用根状态一样去使用他们，但是这样不可避免会出现命名冲突的问题，所以使模块有更高的封装性与复用性，我们可以通过添加 <code>namespaced: true</code> 使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// moduleB 模块导出的时候加个 namespaced: true,</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-1-辅助函数的使用"><a href="#3-3-1-辅助函数的使用" class="headerlink" title="3.3.1 辅助函数的使用"></a>3.3.1 辅助函数的使用</h4><p>因为有了命名空间这么一层封装，所以我们在用辅助函数的时候都要多加那么一层模块名，具体看下面代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getter</span></span><br><span class="line"><span class="keyword">this</span>.$store.getters[<span class="string">'moduleB/bFullName'</span>]; </span><br><span class="line"></span><br><span class="line">...mapGetters(&#123;</span><br><span class="line">  bGetter2: <span class="string">'moduleB/bFullName'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutation </span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'moduleB/SET_B_NAME'</span>, &#123;</span><br><span class="line">  name: <span class="string">'QQ'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...mapMutations(&#123;</span><br><span class="line">  setBname: <span class="string">'moduleB/SET_B_NAME'</span></span><br><span class="line">&#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">// action</span></span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'moduleB/ASYNC_SET_NAME'</span>, &#123; <span class="attr">name</span>: <span class="string">"JJ"</span> &#125;);</span><br><span class="line"></span><br><span class="line">...mapActions(&#123;</span><br><span class="line">  aSetAge: <span class="string">'moduleB/ASYNC_SET_NAME'</span>,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>每次都要写模块名，这样写下来很烦，所以这些辅助函数给我们提供了一个参数位来绑定命名空间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// moduleB 模块内的 bName</span></span><br><span class="line">...mapState(<span class="string">'moduleB'</span>, &#123;</span><br><span class="line">  name: <span class="function"><span class="params">state</span> =&gt;</span> state.bName</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理 mapAction mapMutation 也可以这个样子</span></span><br><span class="line">...mapAction(<span class="string">'moduleB'</span>,[</span><br><span class="line">  <span class="string">'/ASYNC_SET_NAME'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>除了这个之外，如果你当前组件用的 vuex 状态都是一个模块的话，我们可以使用 <code>createNamespacedHelpers</code> 创建基于某个命名空间辅助函数，如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapActions &#125; = createNamespacedHelpers(<span class="string">'moduleB'</span>) <span class="comment">// moduleName</span></span><br></pre></td></tr></table></figure></p>
<p>这样创建之后，我们就可以用之前的写法来访问到模块的状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...mapState(&#123;</span><br><span class="line">  bName: <span class="function"><span class="params">state</span> =&gt;</span> state.bName,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-在带命名空间的模块内访问全局内容"><a href="#3-3-2-在带命名空间的模块内访问全局内容" class="headerlink" title="3.3.2 在带命名空间的模块内访问全局内容"></a>3.3.2 在带命名空间的模块内访问全局内容</h4><p>如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。</p>
<p>若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。具体看下面代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    getters: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块的 getter 中，`getters` 被局部化了</span></span><br><span class="line">      <span class="comment">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span></span><br><span class="line">      someGetter (state, getters, rootState, rootGetters) &#123;</span><br><span class="line">        getters.someOtherGetter <span class="comment">// -&gt; 'foo/someOtherGetter 模块内的 getter'</span></span><br><span class="line">        rootGetters.someOtherGetter <span class="comment">// -&gt; 'someOtherGetter 全局的getter'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherGetter: <span class="function"><span class="params">state</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    actions: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span></span><br><span class="line">      <span class="comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span></span><br><span class="line">      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class="line">        getters.someGetter <span class="comment">// -&gt; 'foo/someGetter'</span></span><br><span class="line">        rootGetters.someGetter <span class="comment">// -&gt; 'someGetter'</span></span><br><span class="line"></span><br><span class="line">        dispatch(<span class="string">'someOtherAction'</span>) <span class="comment">// -&gt; 'foo/someOtherAction' 模块内的 action</span></span><br><span class="line">        dispatch(<span class="string">'someOtherAction'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt;'someOtherAction' 全局的 action </span></span><br><span class="line"></span><br><span class="line">        commit(<span class="string">'someMutation'</span>) <span class="comment">// -&gt; 'foo/someMutation' 模块内的 action</span></span><br><span class="line">        commit(<span class="string">'someMutation'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; 'someMutation' 全局 mutation</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-将模块内的-action-注册为全局"><a href="#3-3-3-将模块内的-action-注册为全局" class="headerlink" title="3.3.3 将模块内的 action 注册为全局"></a>3.3.3 将模块内的 action 注册为全局</h4><p>这个感觉和维护模块的封装性有点冲突，但是既然作者提出来了，那就学吧，当我们想要我们模块内的某个 action 提升为全局 action 的时候，在他声明的时候，添加 <code>root: true</code>，并将 action 的定义放到 hanler 函数中，具体如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">// 模块内 action</span></span><br><span class="line">    [ASET_AGE](&#123; commit &#125;, payload) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            commit(<span class="string">'SET_B_NAME'</span>, payload.name);</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 提升到全局的 action </span></span><br><span class="line">    globalAction: &#123;</span><br><span class="line">        root: <span class="literal">true</span>,</span><br><span class="line">        handler(&#123; commit &#125;, payload) &#123;</span><br><span class="line">            <span class="keyword">debugger</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                commit(<span class="string">'SET_B_NAME'</span>, payload.name);</span><br><span class="line">            &#125;, <span class="number">2000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于模块使用 Vuex 的介绍就说到这里了，这两篇笔记的项目源码我发到了 <a href="https://github.com/lijiayuan365/use-vuex" target="_blank" rel="noopener">GitHub</a> 上面，大家可以去看一下，要是项目中有啥不明白的或者我说的有问题的，欢迎大家留言指正。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
        <tag>项目经验</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack3 迁移到 Webpack4</title>
    <url>/2018/10/16/update-webpack4/</url>
    <content><![CDATA[<h2 id="为什么要迁移"><a href="#为什么要迁移" class="headerlink" title="为什么要迁移"></a>为什么要迁移</h2><p>其实我是不知道的，只是实习的公司的项目要迁移，所以采取了解这方面的东西，公司的原因是由于公司项目越来越大，需要的依赖越来越多，导致开发的时候重新构建的时候速度十分缓慢，开发效率很低。</p>
<h2 id="升级-webpack4"><a href="#升级-webpack4" class="headerlink" title="升级 webpack4"></a>升级 webpack4</h2><p> 直奔主题，直接开始升级</p>
<p>首先升级 webpack4 到 4.8.1 （当然其他 4 的版本都是可以的），顺便安装一下 webpack-cli<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack@4.8.1 webpack-cli -D</span><br></pre></td></tr></table></figure></p>
<p>然后我们 npm run dev 一下。 『报错啦！』</p>
<p><img src="http://img.cdn.lijiayuan.top/update-webpack4/1.png" alt="image"></p>
<p>这个是因为 webpack 和 webpack-dev-server 版本不兼容，升级一下就好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-server@3.1.4 -D</span><br></pre></td></tr></table></figure>
<p>再次启动，又报错了。。。</p>
<p><img src="http://img.cdn.lijiayuan.top/update-webpack4/2.png" alt="image"></p>
<p>这里是因为 html-webpack-plugin 版本不兼容导致的，网上给出的解决方案大部分是说执行 <code>yarm add webpack-contrib/html-webpack-plugin -D</code></p>
<p>但是现在作者已经更新版本了，直接升级版本就可以了，不需要再去安装 webpack 官方的替代版本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin@3.2.0 -D</span><br></pre></td></tr></table></figure></p>
<p>再次启动，再次报错</p>
<p><img src="http://img.cdn.lijiayuan.top/update-webpack4/3.png" alt="image"></p>
<p>升级一下 eslint 和 eslint-loader 吧<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install eslint eslint-loader@2.0.0 -D</span><br></pre></td></tr></table></figure></p>
<p>继续报错</p>
<p><img src="http://img.cdn.lijiayuan.top/update-webpack4/4.png" alt="image"></p>
<p>升级 vue-loader 吧<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-loader@15.0.10 -D</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.cdn.lijiayuan.top/update-webpack4/5.png" alt="image"></p>
<p>错的更彻底了</p>
<p>这是因为新版的 vue-loader 需要加入一个新的配置 VueLoaderPlugin。所以要在下面这些文件修改一下配置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.conf.js 文件</span></span><br><span class="line"><span class="comment">// 引入 VueLoaderPlugin</span></span><br><span class="line"><span class="keyword">const</span> &#123; VueLoaderPlugin &#125; = <span class="built_in">require</span>(<span class="string">'vue-loader'</span>)</span><br><span class="line"><span class="comment">// 在下面的插件中添加 VueLoaderPlugin </span></span><br><span class="line"> plugins: [ </span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin(), </span><br><span class="line">    ... </span><br><span class="line"> ]</span><br><span class="line"> </span><br><span class="line"><span class="comment">// webpack.prod.conf.js 文件</span></span><br><span class="line"><span class="comment">// 这个和上面的文件一样处理了</span></span><br><span class="line"><span class="comment">// 引入 VueLoaderPlugin</span></span><br><span class="line"><span class="keyword">const</span> &#123; VueLoaderPlugin &#125; = <span class="built_in">require</span>(<span class="string">'vue-loader'</span>)</span><br><span class="line"><span class="comment">// 在下面的插件中添加 VueLoaderPlugin </span></span><br><span class="line"> plugins: [ </span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin(), </span><br><span class="line">    ... </span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>
<p>再来，再来</p>
<p><img src="http://img.cdn.lijiayuan.top/update-webpack4/6.png" alt="image"></p>
<p>这个是 webpack4 需要指定一下打包的模式（mode），指定一下就好，直接该配置就行了。『不要慌，小问题』</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.conf.js文件</span></span><br><span class="line"><span class="keyword">const</span> devWebpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;...&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//同理在 webpack.prod.conf.js 文件</span></span><br><span class="line"><span class="keyword">const</span> devWebpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;...&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>疲惫的手再次按起了 npm run dev</p>
<p><img src="http://img.cdn.lijiayuan.top/update-webpack4/7.png" alt="image"></p>
<p><strong>震惊</strong>！居然没错了，居然可以运行了。好的，webpack4 升级结束，撒花！！</p>
<p>然而当我默默敲起了 <code>npm run build</code></p>
<p><img src="http://img.cdn.lijiayuan.top/update-webpack4/8.png" alt="image"></p>
<p>该错的终究还是要错的啊。。</p>
<p>这部分的错误是因为 webpack.optimize.CommonsChunkPlugin 已经被弃用，需要使用新的配置 config.optimization.splitChunks，在下面的文件再改一下配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.conf.js 文件</span></span><br><span class="line"><span class="comment">// 在 plugins 同级下添加下面代码</span></span><br><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          name: <span class="string">'vendor'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        manifest: &#123;</span><br><span class="line">          name: <span class="string">'manifest'</span>,</span><br><span class="line">          minChunks: <span class="literal">Infinity</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 嗯，就在上面加这一段代码</span></span><br><span class="line">  plugins:[...]</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 分割线</span></span><br><span class="line"><span class="comment">// 再去掉该文件中 plugins 中的这部分代码</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'vendor'</span>,</span><br><span class="line">      minChunks(<span class="built_in">module</span>) &#123;</span><br><span class="line">        <span class="comment">// any required modules inside node_modules are extracted to vendor</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">          /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">          <span class="built_in">module</span>.resource.indexOf(</span><br><span class="line">            path.join(__dirname, <span class="string">'../node_modules'</span>)</span><br><span class="line">          ) === <span class="number">0</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// extract webpack runtime and module manifest to its own file in order to</span></span><br><span class="line">    <span class="comment">// prevent vendor hash from being updated whenever app bundle is updated</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'manifest'</span>,</span><br><span class="line">      minChunks: <span class="literal">Infinity</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// This instance extracts shared chunks from code splitted chunks and bundles them</span></span><br><span class="line">    <span class="comment">// in a separate chunk, similar to the vendor chunk</span></span><br><span class="line">    <span class="comment">// see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'app'</span>,</span><br><span class="line">      <span class="keyword">async</span>: <span class="string">'vendor-async'</span>,</span><br><span class="line">      children: <span class="literal">true</span>,</span><br><span class="line">      minChunks: <span class="number">3</span></span><br><span class="line">    &#125;),</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// 不要客气，全删了，怕错就先注释掉呗。</span></span><br></pre></td></tr></table></figure>
<p>让我们再次打包</p>
<p><img src="http://img.cdn.lijiayuan.top/update-webpack4/9.png" alt="image"></p>
<p>『这个是大问题，要慌！』这个是因为官方已经不推荐使用 extract-text-webpack-plugin 提取 css 样式，可以使用 mini-css-extract-plugin 替代<br>如果不想改变的话可以升级 extract-text-webpack-plugin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;extract-text-webpack-plugin&quot;: &quot;^4.0.0-beta.0&quot;,</span><br></pre></td></tr></table></figure>
<p>但是，我们还是要用推荐的 mini-css-extract-plugin </p>
<p>首先安装一下插件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure></p>
<p>记得去掉 package.json 中的包 “extract-text-webpack-plugin”: “^4.0.0-beta.0”</p>
<p>然后我们又来改配置了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build 里面的util.js 文件</span></span><br><span class="line"><span class="comment">// 1 去掉 extract-text-webpack-plugin</span></span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>) <span class="comment">// 走好了您咧</span></span><br><span class="line"><span class="comment">// 2 引入新大佬</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"><span class="comment">// 3 修改下面的 generateLoaders 函数</span></span><br><span class="line"><span class="comment">// 删掉原来的即我注释的代码，修改成下面这个样子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateLoaders</span> (<span class="params">loader, loaderOptions</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (options.extract) &#123;</span><br><span class="line">      <span class="comment">// return ExtractTextPlugin.extract(&#123;</span></span><br><span class="line">      <span class="comment">//   use: loaders,</span></span><br><span class="line">      <span class="comment">//   fallback: 'vue-style-loader'</span></span><br><span class="line">      <span class="comment">// &#125;)</span></span><br><span class="line">      <span class="keyword">return</span> [MiniCssExtractPlugin.loader].concat(loaders)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">'vue-style-loader'</span>].concat(loaders)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.prod.conf.js文件</span></span><br><span class="line"><span class="comment">// 1 去掉 extract-text-webpack-plugin</span></span><br><span class="line"><span class="comment">// 删这个</span></span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>) </span><br><span class="line"><span class="comment">// 加下面的</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 去掉 plugins 里的配置 </span></span><br><span class="line"><span class="keyword">new</span> ExtractTextPlugin(&#123; </span><br><span class="line">    filename: utils.assetsPath(<span class="string">'css/[name].[contenthash].css'</span>),</span><br><span class="line">    allChunks: <span class="literal">true</span>, </span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 3 在 plugins 加入新的插件配置</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: utils.assetsPath(<span class="string">'css/[name].[contenthash:12].css'</span>),</span><br><span class="line">      allChunks: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure>
<p>最后再打包。。。</p>
<p><img src="http://img.cdn.lijiayuan.top/update-webpack4/10.png" alt="image"></p>
<p>欢乐女神，圣洁美丽，webpack4 升级完成咧，如有其他问题，留言加百度，我们一起研究研究。</p>
]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>升级Webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title>正则练习题</title>
    <url>/2018/06/30/reg-trian/</url>
    <content><![CDATA[<a id="more"></a>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我们在上次说到了一些关于正则表达式的基本知识，然后学啥东西都一样，要会用，不然干看着概念，就算你厉害把所有的知识点都背下来了，但是一段时间不看就会忘记了，所以咧，还是要找一点题练一下，这次的话就随便找了几道我做项目的时候做的正则的题型，权当复习吧<br><strong>邮箱校验</strong></p>
<p>要求：能够识别判断当前使用比较多的免费邮箱，企业邮箱不熟，以后再考虑<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> demo = <span class="string">"123@qq.com"</span>;</span><br><span class="line"><span class="keyword">let</span> pataern = <span class="regexp">/^[a-zA-Z0-9_.]+@[a-zA-Z0-9-]+(\.[a-zA-Z0-9]+)*\.[a-zA-Z0-9]&#123;2,6&#125;/</span>;</span><br><span class="line"><span class="keyword">let</span> res = pataern.test(demo);</span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>账户姓名校验</strong></p>
<p>要求：1-n个以字母开头的字符串<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> user1 = <span class="string">'ssh'</span>;</span><br><span class="line"><span class="keyword">let</span> user2 = <span class="string">'1word'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> reg =  <span class="regexp">/^[a-zA-Z][a-zA-Z0-9_]&#123;0,4&#125;$/</span>;</span><br><span class="line">	<span class="keyword">let</span> result = reg.test(user);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(UserName(user1));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(UserName(user2));<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>密码校验</strong></p>
<p>要求：6-12字母、数字、下划线<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pwd1 = <span class="string">'s'</span>;</span><br><span class="line"><span class="keyword">let</span> pwd2 = <span class="string">'1_word'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Password</span>(<span class="params">pwd</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> reg =  <span class="regexp">/[a-zA-Z0-9_]&#123;6,12&#125;$/</span>;</span><br><span class="line">	<span class="keyword">let</span> result = reg.test(pwd);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Password(pwd1));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(Password(pwd2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>格式化金额</strong></p>
<p>要求：将数字转换为形如￥2,000.12的形式<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span></span><br></pre></td></tr></table></figure></p>
<p><strong>获取金额中的有效数字</strong></p>
<p>要求：将￥2,000.20中的有效数字提取出来，如2000.2<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`CNY 1,000.0`</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tiqu</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> reg = <span class="regexp">/[^0-9\.]/g</span>;<span class="comment">//去掉货币符号和逗号</span></span><br><span class="line">	str = str.replace(reg,<span class="string">''</span>);</span><br><span class="line">	str = <span class="built_in">parseFloat</span>(str);<span class="comment">//如果去掉无效的小数数据</span></span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = tiqu(str);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手用 express 搭建后台</title>
    <url>/2018/12/08/express-project-1/</url>
    <content><![CDATA[<p><strong>前言</strong> 想必很多小伙伴开始学 node 的时候想搞个项目出来却不知道怎么下手吧，这个教程的话就是教大家用 express 框架简单粗暴搭建一个可以用的后台出来，然后关于 node 和 express 的其他知识，大家还是需要自己去看看文档了解一下。</p>
<h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1 环境准备"></a>1 环境准备</h2><p>express 既然是基于 node 的开发框架，首先 node 那些肯定都配好了吧，这个就自己搞去。然后下面就是要搞 express 的东西了。</p>
<p>1、全局安装 express，方便后面直接导入 express 模块。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install express -g</span><br></pre></td></tr></table></figure></p>
<p>2、再全局安装 express 的脚手架工具，装完我们就可以很舒服的生成一个 express 项目了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install express-generator -g</span><br></pre></td></tr></table></figure></p>
<h2 id="2-项目"><a href="#2-项目" class="headerlink" title="2 项目"></a>2 项目</h2><h3 id="2-1-搭建"><a href="#2-1-搭建" class="headerlink" title="2.1 搭建"></a>2.1 搭建</h3><p>环境配好后，搭建项目就很舒服啦，直接就是一条指令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">express express-demo</span><br></pre></td></tr></table></figure></p>
<p>接下来就是，安装依赖，运行项目<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure></p>
<p>然后我们打开浏览器查看 3000 端口，看到下面的页面就说明我们 express 后台已经跑起来了<br><img src="http://img.cdn.lijiayuan.top/express-project/2.png" alt="image"></p>
<h3 id="2-2-项目结构"><a href="#2-2-项目结构" class="headerlink" title="2.2 项目结构"></a>2.2 项目结构</h3><p>生成的项目结构如下图所示<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">│  app.js</span><br><span class="line">│  package.json</span><br><span class="line">│</span><br><span class="line">├─.idea</span><br><span class="line">│  │  express-demo.iml</span><br><span class="line">│  │  modules.xml</span><br><span class="line">│  │  vcs.xml</span><br><span class="line">│  │  workspace.xml</span><br><span class="line">│  │</span><br><span class="line">│  └─inspectionProfiles</span><br><span class="line">├─bin</span><br><span class="line">│      www</span><br><span class="line">│</span><br><span class="line">├─public</span><br><span class="line">│  │  index.html</span><br><span class="line">│  │</span><br><span class="line">│  ├─images</span><br><span class="line">│  ├─javascripts</span><br><span class="line">│  └─stylesheets</span><br><span class="line">│          style.css</span><br><span class="line">│</span><br><span class="line">├─routes</span><br><span class="line">│      index.js</span><br><span class="line">│      users.js</span><br><span class="line">│</span><br><span class="line">└─views</span><br><span class="line">        error.jade</span><br><span class="line">        index.jade</span><br><span class="line">        layout.jade</span><br></pre></td></tr></table></figure></p>
<p>我们一个一个来说明哈。</p>
<p>1、<code>bin</code> 文件夹</p>
<p>里面的话有 <code>www</code> 文件，那个就是项目的启动脚本文件，监听端口在里面设置，一般情况不管这个文件。</p>
<p>2、<code>public</code> 文件夹</p>
<p>静态资源文件夹，放着 css，js，img 那些，然后如果在里面写个 <code>index.html</code> 的话，我们访问 3000 端口的时候就会直接访问 <code>index.html</code> 的那个页面。所以这边的话，可以把我们前端开发打包好的代码。</p>
<p>3、<code>routes</code> 文件夹</p>
<p>这个是重点啦，路由文件夹，里面的文件用于生成路由实例，这个路由实例用来响应前端发过的请求，按照现在前后端分离的思想，我们在这里面写后台的那些接口了。我们抓一个文件来看一下<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理前端请求</span></span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line"><span class="comment">/* 这边的 router.get 是接收前端的 get 请求</span></span><br><span class="line"><span class="comment">  第一个参数是路由地址，这边的 '/' 就指根路由，也就是http://localhost:3000 啦</span></span><br><span class="line"><span class="comment">  第二个参数是一个响应接口的回调函数，里面有三个参数，分别是 请求头request 响应体response，和一个next</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123; <span class="attr">title</span>: <span class="string">'Express'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 导出路由模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p>
<p>上面这个是系统默认的给的，他的话是根据模板（下面会讲）生成了一个页面渲染回去，但是我们现在前后端都分离啦，一般都是后台写接口丢给前端就好啦，所以我们要改成下面这个样子<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理好要返回给前端的数据</span></span><br><span class="line">  <span class="keyword">let</span> data = &#123;</span><br><span class="line">      name:<span class="string">'xhm'</span>,</span><br><span class="line">      age:<span class="number">12</span> &#125;</span><br><span class="line">  <span class="comment">// 用 res.json 方法写接口</span></span><br><span class="line">  res.json(&#123;</span><br><span class="line">    code:<span class="number">0</span>,</span><br><span class="line">    msg:<span class="string">'ok'</span>,</span><br><span class="line">    data:data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>安装上面这样搞，我们重新访问 3000 端口的时候就会发现这个时候返回就是一个 json 的数据啦（如下图），这样就写了一个简单的后台接口，后面的不同业务逻辑的接口，就看你前面怎么去处理那些数据啦。</p>
<p>4、<code>views</code> 文件夹<br>这个用于存放 jade 模板，这个的话，不懂也比较少会用到，只知道这个可以作为页面的模板来使用，渲染一下报错页面和主页，其他就没有用了。</p>
<p>5、<code>app.js</code> 文件<br>这个是项目的入口文件，这边有着项目的一下配置，也在此整合了项目的模块，其中要注意的就是里面关于路由模块的配置了。看下面代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 routes 文件夹中的路由文件</span></span><br><span class="line"><span class="keyword">var</span> indexRouter = <span class="built_in">require</span>(<span class="string">'./routes/index'</span>);</span><br><span class="line"><span class="keyword">var</span> usersRouter = <span class="built_in">require</span>(<span class="string">'./routes/users'</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 设置这些路由的地址</span></span><br><span class="line">app.use(<span class="string">'/'</span>, indexRouter);</span><br><span class="line">app.use(<span class="string">'/users'</span>, usersRouter);</span><br></pre></td></tr></table></figure></p>
<p>这边做一点说明吧：</p>
<ul>
<li>这边设置路由的地址是相对于项目的，然后在 routes 文件夹里面的地址是相对于这边的，用上面的代码来说，假设那个 <code>./routes/users</code> 文件里面定义了 <code>&#39;/login&#39;</code> 这么一个路由地址，那么由于整个 <code>users</code> 的地址是 <code>&#39;/users&#39;</code>，所以我们在外面要访问那个 <code>login</code> 的话，该访问的地址是 <code>http://localhost:3000/users/login</code>。</li>
<li>后面要再想加其他路由模块的时候，就按照上面先引入路由模块，再用 <code>app.use</code> 设置好地址，后面就可以用了。</li>
</ul>
<p>6、<code>package.json</code> 文件</p>
<p>这个就是整个项目的配置文件啦。项目的名字啦，版本号和项目所需的那些依赖全都写在这里面的啦，但是一般我们是不用管的。</p>
<h2 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3 数据库"></a>3 数据库</h2><p>既然搭建了后台，数据库肯定是要连接的，不同的数据库的话，就安装不同的插件来使用，如果你使用的是 mongoDB 的话，就推荐使用 mongoose 来操作数据库，关于 mongoose 的使用可以看我另外一篇<a href="https://lijiayuan.top/2018/10/23/using-mongoose/" target="_blank" rel="noopener">教程</a></p>
<h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4 后记"></a>4 后记</h2><p>源代码的话我放到我的 <a href="https://github.com/lijiayuan365/express-demo" target="_blank" rel="noopener">Github</a> 上面去了,可以去 clone 下来看一下。关于 express 项目的简单开发就讲到这边啦，但是如果是这么简单的设置这个项目的目录结构的话，可扩展性不高，代码复用也不好，所以我们要看下一篇文章啦–<a href="https://lijiayuan.top/2018/12/08/express-project-2/" target="_blank" rel="noopener">express 项目分层实践</a></p>
]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>express</tag>
        <tag>分层架构</tag>
      </tags>
  </entry>
  <entry>
    <title>正则基础知识</title>
    <url>/2018/10/13/reg-knowledge/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="1-定义正则"><a href="#1-定义正则" class="headerlink" title="1 定义正则"></a>1 定义正则</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"G"</span>);<span class="comment">//RegExp对象，参数就是我们要制定的规则</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/G/</span>; <span class="comment">//一般写法，推荐使用，性能更好</span></span><br></pre></td></tr></table></figure>
<h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2 常用方法"></a>2 常用方法</h3><ul>
<li><strong>test()</strong>：在字符串中查找符合正则的内容，找到返回true，反之返回false</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断数字是否有非数字</span></span><br><span class="line"><span class="keyword">let</span> str =<span class="string">'1233456'</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\D/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>exec()</strong> </li>
</ul>
<p>RegExp的exec()方法和String的match()方法很类似，<br>它对一个指定的字符串执行一个正则表达式匹配，如果没有找到任何一个匹配，<br>它将返回null，否则返回一个数组，这个数组的第一个元素包含的是与正则表达<br>式相匹配的字符串,余下的所有元素包含的是匹配的各个分组。而且，正则表达式<br>对象的index属性还包含了匹配发生的字符串的位置，属性input引用的则是被检<br>索的字符串。如果正则表达式具有g标志，它将把该对象的lastIndex属性设置到<br>紧接着匹配字符串的位置开始检索，如果exec()没有发现任何匹配，它将把<br>lastIndex属性重置为0，这一特殊的行为可以使你可以反复调用exec()遍历一个字<br>符串中所有的正则表达式匹配。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str5 = <span class="string">'cat,fat,bat,sat,cct'</span>;</span><br><span class="line"><span class="keyword">let</span> reg5 = <span class="regexp">/.at/g</span>;</span><br><span class="line">reg5.lastIndex = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg5.exec(str5));<span class="comment">//[ 'cat', index: 0, input: 'cat,fat,bat,sat,cct' ]</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>replace()</strong>:查找符合正则的字符串，替换成对应的字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换关键字</span></span><br><span class="line"><span class="keyword">let</span> str4 = <span class="string">'七夕，JJ，我在月下等你'</span>;</span><br><span class="line"><span class="keyword">let</span> reg4 = <span class="regexp">/七夕|JJ/g</span>;</span><br><span class="line"><span class="comment">/*str4 = str4.replace(reg4,'*');</span></span><br><span class="line"><span class="comment">console.log(str4);//*，*，我在月下等你.有点问题啊，那么就不要直接替换，我们用个回调函数解决</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">str4 = str4.replace(reg4,<span class="function"><span class="keyword">function</span> (<span class="params">str4</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> res = <span class="string">''</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;str4.length;i++)&#123;</span><br><span class="line">		res +=<span class="string">'*'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str4);<span class="comment">//**，**，我在月下等你</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>search()</strong>:在字符串搜索符合正则的内容，搜索到就返回出现的位置<strong>注意：如果找到多个，则只会返回第一个找到的字符的位置</strong>，找不到就返回-</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在字符串中找到字母b，且不区分大小写</span></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">'abcbdef'</span>;</span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="regexp">/B/gi</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str2.search(reg2));<span class="comment">//2 找到的第一个字符的位置</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>match()</strong>:在字符串中搜索符合规则的内容，搜索成功就返回内容，反之则返回null</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到指定格式的所有数字</span></span><br><span class="line"><span class="keyword">let</span> str3 = <span class="string">'haj123sdk54hask33dkhalsd879'</span>;</span><br><span class="line"><span class="keyword">let</span> reg3 = <span class="regexp">/\d+/g</span>;<span class="comment">//每次至少匹配一个数字</span></span><br><span class="line"><span class="built_in">console</span>.log(str3.match(reg3));<span class="comment">//[ '123', '54', '33', '879' ]</span></span><br></pre></td></tr></table></figure>
<h3 id="3-常见字符"><a href="#3-常见字符" class="headerlink" title="3 常见字符"></a>3 常见字符</h3><ul>
<li><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4></li>
</ul>
<p>这几个常见转义字符还是要的顺手记下滴<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\s :空格</span><br><span class="line">\S :非空格</span><br><span class="line">\d :数字</span><br><span class="line">\D :非数字</span><br><span class="line">\w :字符（字母，数字，下划线那些）</span><br><span class="line">\W :非字符</span><br><span class="line">. :任意字符</span><br><span class="line">\. :真正的点</span><br></pre></td></tr></table></figure></p>
<ul>
<li><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;n,m&#125; :出现n~m次</span><br><span class="line">&#123;n,&#125; :至少n次</span><br><span class="line">&#123;n&#125; :出现n次</span><br><span class="line">* :任意次</span><br><span class="line">? :1次或者0次，相当于&#123;0,&#125;</span><br><span class="line">+ :1~n次</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="其他符号"><a href="#其他符号" class="headerlink" title="其他符号"></a>其他符号</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^ :匹配输入串的开始位置</span><br><span class="line">$ :匹配输入串的结束位置</span><br><span class="line">[] :[]里面的任意字符</span><br><span class="line">[^] :非[]里面的任意字符</span><br><span class="line">() :分组符，小括号中的项叫做正则的子项</span><br><span class="line">$1($n) :正则式中的第1（n）个子项</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>正则</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>mongose 插件的简单使用</title>
    <url>/2018/10/23/using-mongoose/</url>
    <content><![CDATA[<p><strong>摘要</strong> 由于毕业设计要做小程序·云开发，它那边的云数据库是非关系数据库，所以就要用一下非关系型的数据库来开发了，这里的话，我就使用比较常用的 mongoDB 这个非关系型的数据库了。然后调用它的话一般使用 mongoose 这个插件来用，趁着做毕设，就学习一下怎么用这个家伙吧。</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2><h3 id="2-1-连接-mongoDB"><a href="#2-1-连接-mongoDB" class="headerlink" title="2.1 连接 mongoDB"></a>2.1 连接 mongoDB</h3><p>在后台跑起来后或者是初始化请求的时候，引入mongoose，连接数据库，以我搭的 express 框架为例，在路由的 index 文件中连接数据库。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接 mongoDB 的 user 数据库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/user'</span>);</span><br><span class="line"><span class="keyword">const</span> db = mongoose.connection;</span><br><span class="line"><span class="comment">// 连接失败</span></span><br><span class="line">db.on(<span class="string">'error'</span>, <span class="built_in">console</span>.error.bind(<span class="built_in">console</span>, <span class="string">'connection error:'</span>));</span><br><span class="line"><span class="comment">// 连接成功</span></span><br><span class="line">db.once(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"mongoDB connected success"</span>);</span><br><span class="line">  <span class="comment">// we're connected!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-2-创建连接"><a href="#2-2-创建连接" class="headerlink" title="2.2 创建连接"></a>2.2 创建连接</h3><p>Mongoose 里，一切都始于 <code>Schema</code>。 现在我们来看一个我项目中例子。（鉴于篇幅，删减了哈）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  userId:<span class="built_in">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们就创建了一个 带有 <code>String</code> 类型 <code>userId</code> 属性的 schema。接着我们需要把这个 schema 编译成一个 <code>Model</code>。通过这个 Model 我们就能够直接操纵数据库里面的数据了 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*model 的参数1 导出的模块名， </span></span><br><span class="line"><span class="comment">参数2 创建的 Schema，</span></span><br><span class="line"><span class="comment">参数3 指定数据库中的集合的名字，若不加的，则抹默认取‘第一个参数s’的集合*/</span></span><br><span class="line"><span class="built_in">module</span>.exports = mongoose.model(<span class="string">'User'</span>,user,<span class="string">'user'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-3-做个小查询"><a href="#2-3-做个小查询" class="headerlink" title="2.3 做个小查询"></a>2.3 做个小查询</h3><p>首先我们需要先引入模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">'./../../models/user'</span>);</span><br></pre></td></tr></table></figure>
<p>接下来就是直接查询了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 user 表中的所有数据</span></span><br><span class="line">User.find(<span class="function"><span class="keyword">function</span> (<span class="params">err, doc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 打印查询到的内容，后面要怎么操作这些数据就看具体的业务需求了</span></span><br><span class="line">  <span class="built_in">console</span>.log(doc);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果我们想获取特定的数据，这个时候就了解有一下 <a href="https://mongoosedoc.top/docs/queries.html" target="_blank" rel="noopener">query</a> 的用法了,下面给出一个简单的小例子。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这么写可以获取所有 name 为 "Fluff" 开头的数据,然后在 callback 里面去写怎么处理那些数据咯</span></span><br><span class="line">User.find(&#123; <span class="attr">name</span>: <span class="regexp">/^fluff/</span> &#125;, callback);</span><br></pre></td></tr></table></figure></p>
<p>关于 mongoose 的简单使用就差不多这个样子了</p>
]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex 基础使用</title>
    <url>/2019/07/27/use-vuex/</url>
    <content><![CDATA[<p><strong>前言</strong> vuex 是 vue 官方出的一个全局的状态管理模式，可以理解为一个 vuex 项目的全局变量吧，再构建大型项目的时候，我们可能会需要用到它。下面就来学一下怎么去使用它吧（本文偏向于具体使用，如要深入学习，请看<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">官方文档</a>）。</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><p>我们要用啥就要先装啥，直接 npm install 就行了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vuex</span><br></pre></td></tr></table></figure></p>
<h2 id="2-文件结构"><a href="#2-文件结构" class="headerlink" title="2 文件结构"></a>2 文件结构</h2><p>vuex 的也是 vue 项目中的一个模块，使用我们一般会用一个 store 文件夹去存放属于 vuex 的文件。他一般是有下面这些模块</p>
<h3 id="2-1-state-js"><a href="#2-1-state-js" class="headerlink" title="2.1 state.js"></a>2.1 state.js</h3><p>这个的里面就放着 vuex 的 state 数据，个人理解这个就是一个一个全局变量库。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> state = &#123;</span><br><span class="line">    dept: <span class="string">'TT'</span>,</span><br><span class="line">    num: <span class="string">'S0171'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> state;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-getters-js"><a href="#2-2-getters-js" class="headerlink" title="2.2 getters.js"></a>2.2 getters.js</h3><p>除了我们默认的 state 状态之外，还会有一些类似组件中的计算属性的派生的状态，他定义的时候和定义计算属性是一样的，但是要传入一个 state 作为参数。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用箭头函数，简洁好看</span></span><br><span class="line"><span class="keyword">let</span> getters = &#123;</span><br><span class="line">    deptNo: <span class="function"><span class="params">state</span> =&gt;</span> state.dept + state.num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getters;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-mutations-js"><a href="#2-3-mutations-js" class="headerlink" title="2.3 mutations.js"></a>2.3 mutations.js</h3><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数,然后还可以传入一个额外的参数，即载荷（payload），我们一般可以使用这个 payload 传入一些修改时需要的参数。</p>
<p>此外 vuex 官方是推荐用常量作为事件类型，使用我们一般也就按照推荐的来咯，当项目足够大的时候，我们还会搞多一个 mutation-type.js 文件来存放这些事件类型，但是现在我们就先把他们都写一起了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 事件类型</span><br><span class="line">const SET_DEPT = &apos;SET_DEPT&apos;</span><br><span class="line"></span><br><span class="line">const mutation = &#123;</span><br><span class="line">    // 回调函数，就处理 state 的方法啦</span><br><span class="line">    [SET_DEPT](state, payload) &#123;</span><br><span class="line">        state.dept = payload.dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default mutation;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-actions-js"><a href="#2-4-actions-js" class="headerlink" title="2.4 actions.js"></a>2.4 actions.js</h3><p>由于 mutation 里面不支持异步操作，所以当我们需要在 vuex 里面执行异步操作的时候,就要用到 action 了，不过要注意 action 只是提供异步操作的机会，但是如果要修改 state 的数据的时候，还是要用到 mutation 里面的同步事件。</p>
<p>他的声明方式和 action 是差不多的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ASET_DEPT = <span class="string">'ASET_DEPT'</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    [ASET_DEPT](context,payload)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            context.commit(<span class="string">'SET_DEPT'</span>,payload.dept);</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> actions;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-5-index-js"><a href="#2-5-index-js" class="headerlink" title="2.5 index.js"></a>2.5 index.js</h3><p>这个就直接 vuex 的入口文件了，在这边要创建 store 实例，并将其导出,我们就要把我们之前搞的所有都丢到这里面来，然后创建一个 store 实例。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">'./getters'</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    getters,</span><br><span class="line">    mutations,</span><br><span class="line">    actions,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>最后我们只要在创建 vue 的实例的 main.js 文件里面导入 store 模块，并在初始化 vue 实例的时候引进去就成功搭建了一个全局的状态仓库了。</p>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h2><p>前面我们说了这么去搭这个仓库，现在我们已经搭好了，就要知道这么去使用这个仓库的数据。</p>
<h3 id="3-1-state-数据的获取"><a href="#3-1-state-数据的获取" class="headerlink" title="3.1 state 数据的获取"></a>3.1 state 数据的获取</h3><p>这个由于我们是在根 vue 实例就引入了 store，然后我们一般是在计算属性中去拿取 vuex 的状态<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed :&#123;</span><br><span class="line">    dept()&#123;</span><br><span class="line">        <span class="keyword">this</span>.$store.state.dept</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了减少我们的工作量，vuex 还给我们贴心准备了辅助函数 mapState<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      name: <span class="function"><span class="params">state</span> =&gt;</span> state.Deno.name,</span><br><span class="line">      dept: <span class="function"><span class="params">state</span> =&gt;</span> state.dept,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 当 computed 里面的计算属性的名称和 state 里面名称一样时，还可以这么写</span></span><br><span class="line">    ...mapState([</span><br><span class="line">      <span class="string">'name'</span>,<span class="string">'dept'</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h3 id="3-2-getter-的获取"><a href="#3-2-getter-的获取" class="headerlink" title="3.2 getter 的获取"></a>3.2 getter 的获取</h3><p>这个和 state 差不多，直接发代码了<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    deptNo() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.deptNo;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后他也有一个辅助函数 mapGetters。用法就<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">      deptNo: <span class="string">'deptNo'</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 当 computed 里面的计算属性的名称和 state 里面名称一样时，还可以这么写</span></span><br><span class="line">    ...mapState([</span><br><span class="line">      <span class="string">'deptNo'</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-mutation-的使用"><a href="#3-3-mutation-的使用" class="headerlink" title="3.3 mutation 的使用"></a>3.3 mutation 的使用</h3><p>mutation 是事件，也就是方法啦，所以我们用方法的形式去使用它。我们可以直接使用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'SET_DEPT'</span>, &#123;</span><br><span class="line">  dept: <span class="string">'QQ'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>也可以用辅助函数 mapMutations 映射为本地方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...mapMutations([<span class="string">"SET_DEPT"</span>]),</span><br><span class="line">...mapMutations(&#123;</span><br><span class="line">    setDept: <span class="string">"SET_DEPT"</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></p>
<p>然后直接调用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.SET_DEPT(<span class="string">'QQ'</span>);</span><br><span class="line"><span class="keyword">this</span>.setDept(<span class="string">'QQ'</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-4-action-的使用"><a href="#3-4-action-的使用" class="headerlink" title="3.4 action 的使用"></a>3.4 action 的使用</h3><p>action 也是方法啦，所以他的使用和 mutation 是差不多的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'ASET_DEPT'</span>,&#123;<span class="attr">dept</span>:<span class="string">'QQ'</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p>它的辅助函数是 mapActions，用它映射为本地方法。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...mapActions(&#123;</span><br><span class="line">  aSetDept: <span class="string">'ASET_DEPT'</span>,</span><br><span class="line">&#125;),</span><br><span class="line">...mapActions([</span><br><span class="line">  <span class="string">'ASET_DEPT'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<p>关于 vuex 的简单使用就说明到这边了，但是由于有时候我们的项目是非常大，使用单一的一个 state 来存数据可能会导致数据太多，太杂，所以 vuex 还有一个 module 的机制，大家可以去官网看文档或者看我的下一篇文章。文章就写到这里啦，如果大家发现我哪边写错的话，还望指出勘误，期待与大家一起学习进步。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 自定义指令</title>
    <url>/2018/11/26/vue-custom-directive/</url>
    <content><![CDATA[<p><strong>前言</strong> 最近搞了毕设，需要实现一个场景，点击一块区域，弹出一个编辑区域，点击页面的其他地方的时候，这个编辑区域就隐藏，本想想之前写模态框一样写个方法的时候，突然<br><img src="http://img.cdn.lijiayuan.top/custom-directive/timg.jfif" alt="image"></p>
<p>觉得可以尝试用 vue 相关的东西优雅的解决这个事情，然后就学了下面的自定义指令了。</p>
<h2 id="1-Vue-自定义指令"><a href="#1-Vue-自定义指令" class="headerlink" title="1 Vue 自定义指令"></a>1 Vue 自定义指令</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>直接看<a href="https://cn.vuejs.org/v2/guide/custom-directive.html#ad" target="_blank" rel="noopener">官网的介绍</a>吧（觉得官方文档说的很清楚了，所以我基本都是抄他的了）。</p>
<blockquote>
<p>除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p>
</blockquote>
<h3 id="1-2-基础实现"><a href="#1-2-基础实现" class="headerlink" title="1.2 基础实现"></a>1.2 基础实现</h3><p>这个在分两种情况，如果你想定义一个全局的自定义组件的话,那么就在项目中的 <code>main.js</code> 里面定义了，例如定义一个官网中的自动聚焦的指令<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>要是你只是想定义一个局部的指令在某个组件内部用的话，那么就在相应的组件内定义了<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跟 data(),methods:&#123;&#125; 那些同级写了</span></span><br><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义完后我们就能愉快的使用了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-钩子函数"><a href="#1-2-钩子函数" class="headerlink" title="1.2 钩子函数"></a>1.2 钩子函数</h3><p>当然这个自定义指令不会就这么一点东西啦，为了解决一些现实中场景，Vue 给我们一堆钩子函数用来实现我们的一些骚操作。具体如下 (均为可选)：</p>
<ul>
<li><p><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
</li>
<li><p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>
</li>
<li><code>update</code>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li>
<li><code>componentUpdated</code>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li>
<li><code>unbind</code>：只调用一次，指令与元素解绑时调用。<br>接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。</li>
</ul>
<p>当然要想好好用用这写钩子函数，就要懂得用下面的这些参数</p>
<h3 id="1-3-钩子函数参数"><a href="#1-3-钩子函数参数" class="headerlink" title="1.3 钩子函数参数"></a>1.3 钩子函数参数</h3><p>指令钩子函数会被传入以下参数：</p>
<ul>
<li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM 。</li>
<li><code>binding</code>：一个对象，包含以下属性：<ul>
<li><code>name</code>：指令名，不包括 v- 前缀。</li>
<li><code>value</code>：指令的绑定值，例如：- v-my-directive=”1 + 1” 中，绑定值为 2。</li>
<li><code>oldValue</code>：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li>
<li><code>expression</code>：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。</li>
<li><code>arg</code>：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</li>
<li><code>modifiers</code>：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { - foo: true, bar: true }。</li>
</ul>
</li>
<li><code>vnode</code>：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。</li>
<li><code>oldVnode</code>：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>
</ul>
<p>然后官网有话说</p>
<blockquote>
<p>除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。</p>
</blockquote>
<p>然后下面我们给一个简单的例子<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在组件内部定义一个局部指令</span></span><br><span class="line">directives:&#123;</span><br><span class="line">  demo:&#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify;</span><br><span class="line">      el.innerHTML = </span><br><span class="line">        <span class="string">`name: <span class="subst">$&#123;s(binding.name)&#125;</span> &lt;br&gt;</span></span><br><span class="line"><span class="string">        value: <span class="subst">$&#123;s(binding.value)&#125;</span> &lt;br&gt;</span></span><br><span class="line"><span class="string">        expression: <span class="subst">$&#123;s(binding.expression)&#125;</span> &lt;br&gt;</span></span><br><span class="line"><span class="string">        argument: <span class="subst">$&#123;s(binding.arg)&#125;</span> &lt;br&gt;</span></span><br><span class="line"><span class="string">        modifiers: <span class="subst">$&#123;s(binding.modifiers)&#125;</span> &lt;br&gt;</span></span><br><span class="line"><span class="string">        vnode keys: <span class="subst">$&#123;<span class="built_in">Object</span>.keys(vnode).join(<span class="string">', '</span>)&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 绑定到组件中的一个 div 中</span></span><br><span class="line">&lt;div v-demo:foo.a.b=<span class="string">"message"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们在网页中就可以看到这么一堆文字了(当然下面的注释是我自己写的)<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">name: <span class="string">"demo"</span> </span><br><span class="line"><span class="comment">// 指定名称</span></span><br><span class="line">value: <span class="string">"Welcome to Your Vue.js App"</span> </span><br><span class="line"><span class="comment">// 指令绑定值</span></span><br><span class="line">expression: <span class="string">"message"</span> </span><br><span class="line"><span class="comment">// 字符串形式的指令表达式</span></span><br><span class="line">argument: <span class="string">"foo"</span> </span><br><span class="line"><span class="comment">// 传给指令的参数</span></span><br><span class="line">modifiers: &#123;<span class="string">"a"</span>:<span class="literal">true</span>,<span class="string">"b"</span>:<span class="literal">true</span>&#125; </span><br><span class="line"><span class="comment">// 修饰符的对象</span></span><br><span class="line">vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder</span><br><span class="line">Vue 编译生成的虚拟节点</span><br></pre></td></tr></table></figure></p>
<h3 id="1-4-函数简写"><a href="#1-4-函数简写" class="headerlink" title="1.4 函数简写"></a>1.4 函数简写</h3><p>在很多时候，你可能想在 <code>bind</code> 和 <code>update</code> 时触发相同行为，而不关心其它的钩子。比如这样写:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">colorSwatch: <span class="function"><span class="keyword">function</span> <span class="title">colorSwitch</span>(<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  el.style.backgroundColor = binding.value</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h3 id="1-5-对象字面量"><a href="#1-5-对象字面量" class="headerlink" title="1.5 对象字面量"></a>1.5 对象字面量</h3><p>如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-demo</span>=<span class="string">"&#123; color: 'white', text: 'hello!' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'demo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(binding.value.color) <span class="comment">// =&gt; "white"</span></span><br><span class="line">  <span class="built_in">console</span>.log(binding.value.text)  <span class="comment">// =&gt; "hello!"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>就差不多这样吧，想看个实例的话就看一下我的另外一篇笔记<a href>《Vue 自定义指令实现点击元素外触发事件》</a>吧</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>自定义指令</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 Java 开发环境</title>
    <url>/2019/06/19/java-envi/</url>
    <content><![CDATA[<h2 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1 下载安装包"></a>1 下载安装包</h2><p>这个的话直接去 Java <a href="https://www.java.com/zh_CN/download/windows-64bit.jsp" target="_blank" rel="noopener">官网</a> 下载就行，或者到我的百度网盘</p>
<p>链接：<a href="https://pan.baidu.com/s/19F0w9wWkbQMGdBk5bf4dBw" target="_blank" rel="noopener">https://pan.baidu.com/s/19F0w9wWkbQMGdBk5bf4dBw</a> </p>
<p>提取码：425p </p>
<p>下载下来。</p>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h2><p>安装真的没啥好说的，就和我们装个 QQ 微信那样，直接一直点击下一步，一直到安装就行了。</p>
<p>推荐是一直默认安装，但是如果有些小伙伴不想装到默认的 C 盘的话，可以在下面这个步骤的时候点击更改，改到你想安装的地方，就是要记得你安装到哪个位置，下面配环境的时候需要用到。</p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/ja2.png" alt="image"></p>
<p>我们一开始是安装的是 jdk，后面装到一半会弹出下面这个安装 jre 的窗口。</p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/ja3.1.png" alt="image"><br>如果你上面安装的时候是一直默认装的话，这个也默认就行，否则这边也要更改安装路径到前面的 jdk 的同级目录，如下所示</p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/ja3.2.png" alt="image"></p>
<h2 id="3-配置系统变量"><a href="#3-配置系统变量" class="headerlink" title="3 配置系统变量"></a>3 配置系统变量</h2><p>安装完 Java 后，我们要配置环境变量后才能开始开发。下面就安装步骤来了。</p>
<ol>
<li>右键点击计算机进入“属性-&gt; 高级系统设置-&gt;高级-&gt;环境变量”，如下图所示</li>
</ol>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/ja6.png" alt="image"></p>
<ol start="2">
<li>新建变量名“JAVA_HOME”，变量值 “D:\Java\jdk1.8.0_152”的环境变量。</li>
<li>编辑 <code>Path</code> 变量的值，在原来的值后面加“;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin”<br><strong>注意</strong> 在 win10 那边的话要像下面这样添加。</li>
</ol>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/ja6.2.png" alt="image"></p>
<ol start="4">
<li>新建变量名“CLASSPATH”，变量值“.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”的环境变量。</li>
</ol>
<p>这样我们就配好了环境变量。</p>
<h2 id="4-检测"><a href="#4-检测" class="headerlink" title="4 检测"></a>4 检测</h2><p>配置完后，我们检查一下是否还有问题，我们打开控制台分别输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java, javac, java -version</span><br></pre></td></tr></table></figure></p>
<p>如果出现下面所示的提示信息，那就没啥问题了，如果出问题的话，去看环境变量那边是不是搞错了。</p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/ja7.png" alt="image"></p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/ja8.png" alt="image"></p>
<p><img src="http://img.cdn.lijiayuan.top/pzhhj/ja9.png" alt="image"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>搭建环境</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号写作备忘</title>
    <url>/2018/12/11/wechat-writing/</url>
    <content><![CDATA[<p><strong>前言</strong> 相信很多人除了在博客网站分享之外还会在微信公众号上进行分享，当然我也不例外，所以今天就写一下关于方面的内容。</p>
<h2 id="优雅的展示代码"><a href="#优雅的展示代码" class="headerlink" title="优雅的展示代码"></a>优雅的展示代码</h2><p>相信现在大部分开发者写博客都是用 markdown 语法来写的，但是微信公众号并不支持 markdown 写作，这不是难受吗？所以一般都是现在其他支持 markdown 的平台先写好，然后再复制过去微信那个，文本是没问题的，但是代码就让人很难受了，鄙人尝试过各种方式，Hexo 博客，简书，有道云笔记平台上的效果，VScode 的 「Markdown preview Enhanced」插件 和 Md2All 网站的转换，结果都不行。。。</p>
<p>有的复制过来就出问题<br><img src="http://img.cdn.lijiayuan.top/writing/3.png" alt="image"><br>有的是在手机上看出问题<br><img src="http://img.cdn.lijiayuan.top/writing/1.jpg" alt="image"><br>还有些是很完美了，一般手机看都 OK 了，但是，到了 iOS。。。<br><img src="http://img.cdn.lijiayuan.top/writing/2.jpg" alt="image"><br>好吧，我要奔溃了，我只是想写个实例代码而已，不用这么坑吧！终于，我找到了一个网站 <strong><a href="http://blog.didispace.com/tools/online-markdown/" target="_blank" rel="noopener">程序猿DD 在线 markdwon 转换</a></strong>，他终于啥都没问题了，终于连 iOS 都可以正常显示一代码了，那个网站如下图所示<br><img src="http://img.cdn.lijiayuan.top/writing/4.png" alt="image"><br>这个是一群大佬开源的一个项目，专治微信公众号不服了，用了不忘给人家一个 star 吧，毕竟还是要感谢人家给这么一个好用的工具是吧。</p>
<p>他那边可以选代码主题，我是选择 <code>atelier-seaside-light</code> 这个主题，觉得这个看起来舒服，然后就不管了，毕竟咱们写博客重要的是内容，排版的话也不用讲究啥最好啦，看起来舒服就可以了。从此就过上了本地 VScode 写博客，写完复制到那边格式化，然后一键复制到微信公众号，这就舒服啦。</p>
<h2 id="其他排版标准"><a href="#其他排版标准" class="headerlink" title="其他排版标准"></a>其他排版标准</h2><p>这里的话就顺便放一下我从 「stormzhang」那边偷学过来的排版标准啦，希望万一哪天张哥发现这边了不要打我</p>
<ol>
<li>空格</li>
</ol>
<p>我们写博客会写中文、英文还有各种符号等等，如果没有一定空格隔离，看起来真的有点难受，所以不要省了下面这些情况的空格。</p>
<ul>
<li>中英文之间需要加空格</li>
</ul>
<p>eg. 我们注意一下 Object 类型的浅拷贝问题。</p>
<ul>
<li>中文与数字之间需要加空格</li>
</ul>
<p>eg. Javascript 中有 5 种基本数据类型。</p>
<ul>
<li>数字与单位之间需要加空格</li>
</ul>
<p>eg. 一个包含了 Vuex + Vue Router 的 Vue 项目 (gzip 之后 30 KB) </p>
<ul>
<li>完整的英文整句时标点与单词之间需要加空格</li>
</ul>
<p>eg. Stay hungry, stay foolish.</p>
<p>但是也有一些例外。</p>
<ul>
<li>度的标志、百分号不加空格</li>
</ul>
<p>eg. 今天广州温度只有 10°。<br>eg. 我们一生有 50% 的时间都在睡觉。</p>
<ul>
<li>全角标点与其他字符之间不加空格</li>
</ul>
<p>eg. 我先学 HTML，然后再学 CSS。</p>
<ol start="2">
<li>标点</li>
</ol>
<p>说到标点，简单说下全角和半角，简单来说，全角占两个字节，半角占一个字节，按照我们现在的输入法，你可以理解成中文汉字是全角，英文字母是半角，</p>
<ul>
<li>使用全角中文标点</li>
</ul>
<p>中文排版中所有的标点都应该使用中文全角中文标点</p>
<p>eg. 你看这个碗，它又大又圆。</p>
<ul>
<li>遇到英文整句、特殊名词时使用半角标点。</li>
</ul>
<p>eg. 乔布斯说过：「Stay hungry, stay foolish.」</p>
<ul>
<li>使用直角引号</li>
</ul>
<p>我国国家标准要求弯引号，但是新媒体排版时使用直角引号看起来舒服一点。</p>
<p>eg. 乔布斯说过：「Stay hungry, stay foolish.」</p>
<p>如果引号再使用引号使用直角双引号。</p>
<p>eg. 我和你讲，「你可以关注『异乡小红帽』这个公众号。」</p>
<ol start="3">
<li>其他</li>
</ol>
<p>初以上之外，还有一些其他标准推荐大家使用的。</p>
<ul>
<li>英文名词首字母尽量大写</li>
</ul>
<p>eg. Javascript, HTML, CSS</p>
<ul>
<li>专有名词使用正确的大小写</li>
</ul>
<p>eg. GitHub、iOS、iPhone 6S</p>
<ul>
<li>首行不要缩进</li>
</ul>
<p>这个的话，看技术文档和前台公众号的文章就能看到基本人家都不会缩进，这是为啥咧，其实「首行缩进两字符」也就是为了区分一下自然段，看文章的时候能分个层次出来，但是我们现在微信公众号还是文档， 大家一般都采用「空出一行」来区分自然段，这种就很省事很多啦，就不用再去多敲那两个空格啦，看起来也很整齐舒服。</p>
<p>当然如果是写正式的电子文件和我们日常书写，肯定还是要首行缩进两字符的啦。</p>
<p>差不多就是这样啦。有啥遗漏或者出错的地方就麻烦大家在下面留言评论哈。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>微信公众号，排版</tag>
      </tags>
  </entry>
  <entry>
    <title>用 python 群发新年祝福</title>
    <url>/2019/01/31/wechat-wish/</url>
    <content><![CDATA[<p>快过年啦，又到了团圆的日子，在这个普天同庆的日子里面，相信很多人和我一样会碰到一年问题 – 拜年（手动捂脸）。</p>
<p>大过年的，大家都会发个微信拜年联络联络感情，炸一炸万年不见的老朋友。但是问题就来了，如果是用微信的群发助手群发的话，感觉有点审美疲劳或者说感觉有点没诚意（总之感觉不舒服就对了），但是如果说你要有诚意，一个一个人写名字，一个一个发的话，我觉得你手指会残的。之前我干过两次，其中我中途休息两回，发完之后手指基本快废了。</p>
<p>后来发觉我是一个 IT 男，应该想个办法解决这种重复性的操作，拯救我那双一年被摧残一次的双手，于是乎，经过一番学习，用现在比较火的 Python 解决了我这个问题。下面就和大家聊聊怎么操作吧。</p>
<h2 id="1-所需资料"><a href="#1-所需资料" class="headerlink" title="1 所需资料"></a>1 所需资料</h2><ol>
<li>python 安装程序</li>
<li>有相关代码的 python 文件</li>
</ol>
<p>这些材料我都放在下面的云盘中了</p>
<p>链接：<a href="https://pan.baidu.com/s/1zt11zzmJUCA8pTijg1mv1w" target="_blank" rel="noopener">https://pan.baidu.com/s/1zt11zzmJUCA8pTijg1mv1w</a> </p>
<p>提取码：m6oh </p>
<h2 id="2-配置-Python"><a href="#2-配置-Python" class="headerlink" title="2 配置 Python"></a>2 配置 Python</h2><p>既然用 Python，肯定要装一下 Python 的环境啦。</p>
<p>到 Python 的<a href="https://www.python.org/getit/" target="_blank" rel="noopener">官网</a>,下载 3.5 版本的 Python 或者到我百度云那个搞咯。</p>
<p>下载完后就直接打开安装</p>
<p><code>注</code> 请选中 把 Python 添加到环境变量，这样以后在windows命令提示符下面也可以运行Python</p>
<p><img src="http://img.cdn.lijiayuan.top/wechat-wish/1.png" alt="image"></p>
<p>下面这些除了修改一下安装路径外，其他默认就好（下图的情况我忘记截图了，从网上找了张图片）</p>
<p><img src="https://images2017.cnblogs.com/blog/1117202/201707/1117202-20170728231130477-439253115.png" alt="image"></p>
<h2 id="3-敲代码"><a href="#3-敲代码" class="headerlink" title="3 敲代码"></a>3 敲代码</h2><p>如果想直接用的小伙伴这一步就不用看了，直接拿网盘的 <code>wish.py</code> 文件，按照下面的<code>第 4 步</code>去运行。</p>
<p>后面的操作，喜欢玩 Python 或者学过的同学可以用 Pycharm 或者其他 IDE 去运行。我这边的话就直接用最原始的方法咯。</p>
<p>首先新建一个 <code>txt</code> 文件，修改它的后缀名为 <code>.py</code> 变成一个 Python 文件咯，用记事本或者 NotePad++ 直接打开，复制下面的代码进去，我在代码里面写了一点注释，要看哦<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"><span class="keyword">import</span> itchat, time, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># SINCERE_WISH = u'祝%s新年快乐！'</span></span><br><span class="line"><span class="comment"># REAL_SINCERE_WISH = u'祝%s新年快乐！！'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 祝福语数组 %s 后面替换为好友昵称或者好友备注</span></span><br><span class="line">wishList = [</span><br><span class="line">    <span class="string">u'祝%s新年快乐！'</span>,</span><br><span class="line">    <span class="string">u'%s，祝你新年快乐！'</span>,</span><br><span class="line">    <span class="string">u'%s，新年快乐！'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 群发所有好友</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_wishes</span><span class="params">()</span>:</span></span><br><span class="line">    friendList = itchat.get_friends(update=<span class="literal">True</span>)[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">for</span> friend <span class="keyword">in</span> friendList:</span><br><span class="line">        <span class="comment"># 如果不是演示目的，把下面的print方法改为itchat.send即可</span></span><br><span class="line">        print(random.choice(wishList) % (friend[<span class="string">'RemarkName'</span>]), friend[<span class="string">'UserName'</span>])</span><br><span class="line">        time.sleep(<span class="number">.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 群发指定群（该群要保存到通讯录）的好友</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_special_wishes</span><span class="params">(chatroomName=<span class="string">'微信群名'</span>)</span>:</span></span><br><span class="line">    itchat.get_chatrooms(update=<span class="literal">True</span>)</span><br><span class="line">    chatrooms = itchat.search_chatrooms(name=chatroomName)</span><br><span class="line">    <span class="keyword">if</span> chatrooms <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">u'没有找到群聊：'</span> + chatroomName)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        chatroom = itchat.update_chatroom(chatrooms[<span class="number">0</span>][<span class="string">'UserName'</span>])</span><br><span class="line">        <span class="keyword">for</span> friend <span class="keyword">in</span> chatroom[<span class="string">'MemberList'</span>]:</span><br><span class="line">            friend = itchat.search_friends(userName=friend[<span class="string">'UserName'</span>])</span><br><span class="line">            <span class="comment"># 如果不是演示目的，把下面的print方法改为itchat.send即可</span></span><br><span class="line">            <span class="comment"># RemarkName 你对好友的备注  NickName 好友自己的昵称</span></span><br><span class="line">            print(random.choice(wishList) % (friend[<span class="string">'RemarkName'</span>]), friend[<span class="string">'UserName'</span>])</span><br><span class="line">            time.sleep(<span class="number">.5</span>)</span><br><span class="line"></span><br><span class="line">itchat.auto_login(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要一次性群发给所有好友，把下面的注释去掉（删除 # 号）</span></span><br><span class="line"><span class="comment"># send_wishes()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要群发给指定群（已保存到通讯录的群）的好友，把下面的注释去掉（删除 # 号）</span></span><br><span class="line">send_special_wishes()</span><br></pre></td></tr></table></figure></p>
<h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4 运行"></a>4 运行</h2><p>按住 <code>shift</code> 键右键，选择「在此处打开  powershell（或者 cmd）」，输入下面命令安装 <code>itchat</code> 包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install itchat</span><br></pre></td></tr></table></figure>
<p>等待它安装后，输入下面的指令运行代码（假设我那个 python 文件是 wish.py）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python wish.py</span><br></pre></td></tr></table></figure></p>
<p>运行之后会弹出一个二维码，那个是用于登录网页版微信的，扫码确认登录</p>
<p>登录之后，代码就会自动跑起来了，为了防止翻车，或者忘记给好友的迷之备注，我在发之前先在本地测试一下，用 <code>print</code> 方法打印出要发送的信息，看看好会不会出啥问题。</p>
<p>先在我这边的话是选择了发送给「微信群名」这个群的好友，控制台这边就打印出来，如下：</p>
<p><img src="http://img.cdn.lijiayuan.top/wechat-wish/5.png" alt="image"></p>
<p>控制台的输出</p>
<p><img src="http://img.cdn.lijiayuan.top/wechat-wish/4.png" alt="image"></p>
<p>第一个那个没有备注的是本人的微信，别怕，其次后面的那串字符是用户的id，到时候真正群发的时候当参数使用，不会发给好友，别怕。测试没有问题之后，我们就可以按照注释的说明，将代码中的 <code>print</code> 改成 <code>itchat.send</code> 方法，重新运行代码，然后真正的群发给好友了，如下</p>
<p><img src="http://img.cdn.lijiayuan.top/wechat-wish/6.png" alt="image"></p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><ol>
<li>本次我用的是 <code>itchat</code> 这个开源的 Python 微信库，里面还有很多玩法，挺好玩的，大家可以去它 <a href="https://itchat.readthedocs.io/zh/latest/" target="_blank" rel="noopener">官网</a> 看看，有 github 的朋友也可以去到 github 上给它个 star 呗，饮水思源嘛。</li>
<li>告诉大家一个残忍的事实吧，其实这个也是有点麻烦的。如果是带好友自己的昵称的话，虽然方便，但是感觉也没有那么亲切啊。要是带自己给好友的备注的话，鬼知道你会给你那些损友起啥备注咧，让好友知道你对他的备注感觉会有翻车的危险啊。</li>
<li>给好友拜年还是要真诚啊，这样虽然也算用心了，但是也是用了点小技巧啊。如果是要给某些很重要的人（手动滑稽，别想歪哦 ~(@^_^@)~ ）发过年祝福的话，还是要自己手打一句，再发个红包啦。只希望以后有个群发红包的功能，这个不用说啦，红包都发了，谁还敢说不真诚！</li>
</ol>
<p>最后的最后，过年嘛，也不要老是手机联络感情啦。直接拉出来三五好友聚聚餐，吹吹水，这才好玩嘛！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>微信群发</tag>
        <tag>新年祝福</tag>
      </tags>
  </entry>
</search>
