<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[express 项目分层实践]]></title>
    <url>%2F2018%2F12%2F08%2Fexpress-project-2%2F</url>
    <content type="text"><![CDATA[前言 上次我们搭建了一个基本的 express 后台，但是这样的项目结构的可扩展性，维护性和代码复用性都不是很好，参照之前学习 JavaWeb 时候的四层架构设计，用分层的思想来对 express 进行一点小优化，进一步提高代码的可拓展性。本文的源代码在 Github 上，建议看着代码来看这篇文章。 1 四（五）层结构概念这个就简单说一下，所谓四层架构就是 Model实体层，Dao层（数据访问层也就是从数据库中查数据），Service层（业务逻辑层，也就是处理好数据），Controller层（视图控制层，在前后端分离的情况下就是写接口响应前端请求）和前端的 view（视图层），为啥要搞分层咧，说到底就是要解耦合，提高拓展性和维护性，写代码的时候，思路清晰一点，后面改代码的时候也知道要改哪边。 但是我们这次只是涉及后台的，视图层我们就不用管了，只需看前面的就行了。 2 分层首先看一下项目结构哈12345678910111213141516171819202122232425262728293031323334353637383940414243444546│ app.js│ package.json│ README.md│├─.idea│ │ express-project.iml│ │ misc.xml│ │ modules.xml│ │ vcs.xml│ │ watcherTasks.xml│ │ workspace.xml│ ││ └─inspectionProfiles├─bin│ www│├─config│ db.json│├─dao│ BaseDao.js│ UserDao.js│├─models│ user.js│├─public│ ├─images│ ├─javascripts│ └─stylesheets│ style.css│├─routes│ index.js│ users.js│├─services│ UserService.js│├─utils│ db-util.js│└─views error.jade index.jade layout.jade 按照分层思想，我们新建几个文件夹哈，首先是 Model层的 models 文件夹，dao 层的 dao 文件夹，service 层的 services 文件夹，controller 层的话就用原来的 routes 文件夹就可以了，为了方便，我加了一个全局配置的 config 文件夹和工具函数 utils 文件夹。具体项目如下，我们从最底层开始来一个一个来分析 2.1 config这个就放着各种配置文件，例如我的 db.json 里面就放了mongodb 的端口号，数据库名那些，反正就是各种配置啦 2.2 utils这个就是有一些创建型的方法或者其他公共方法，像创建数据库连接池的方法我就放在这边的 db-util 里面了。 2.3 models实体层,针对 mongodb 来说，一个集合对应一个 model，然后都是这样的形式啦。123456789101112131415const mongoose = require('mongoose');const &#123; mongoClient &#125; = require('../utils/db-util');// 创建 user Schemaconst user = new mongoose.Schema(&#123; name: String, id: String,&#125;,&#123;versionKey: false&#125;);/*model 的参数1 导出的模块名，参数2 创建的 Schema，参数2 指定数据库中的集合的名字，若不加的，则抹默认取‘第一个参数s’的集合*/let User = mongoClient.model('User', user, 'user');module.exports = User; 2.4 dao创建完实体层，接下来就是 dao 层了，这边我封装了一个 BaseDao，基本的数据库操作都有了，后面我们创建其他 dao 的时候就很舒服啦，直接继承一下 BaseDao 就好了。例如下面的这个 UserDao：123456789101112let BaseDao = require('./BaseDao');// 导入对应的实体let User = require('../models/user');class UserDao extends BaseDao&#123; constructor() &#123; super(User); &#125; //如果有啥特殊需求的话，自己再重写方法咯&#125;module.exports = UserDao; 这样就写好了一个基本的 dao 了，增删改查这些他都从 BaseDao 中继承了， 2.5 servicesservice 层是业务逻辑层，这么写就看你项目的业务啦。我下面就简单些一个查询所有 user 数据的方法啦。1234567891011121314151617const UserDao = require('../dao/UserDao');let userDao = new UserDao();class UserService &#123; async getUserList() &#123; try &#123; // 调用 dao 层查询数据 let userList = await userDao.findAll(); return userList; &#125; catch (err) &#123; console.log(`getUserList error--&gt; $&#123;error&#125;`); return error; &#125; &#125;&#125;module.exports = UserService; 2.6 routescontroller 层，写接口用，这个写起来简单，就拿一下 service 层的数据返回就可以啦。12345678910111213141516171819202122232425var express = require('express');var router = express.Router();const UserService = require('../services/UserService');let userService = new UserService();/* GET users listing. */router.get('/', function(req, res, next) &#123; userService.getUserList().then((data)=&gt;&#123; res.json(&#123; code:0, msg:'OK', data:data &#125;) &#125;); // res.send('respond with a resource');&#125;);router.get('/login',(req,res,next)=&gt;&#123; res.json(&#123; code:0, msg:'OK', data:&#123;result:true&#125; &#125;)&#125;);module.exports = router; 然后这边的话，我有一个想法，就是想着每次多一个路由实例（controller）的时候，就要往 app.js 里面导入并引入，觉得这样 controller 多了的时候，app.js 里面代码会很多，所以就想着把模块导入的代码移到 routes 文件夹里面的 index.js 里面来，app.js 就引入个 index 就好啦。所以就有了下面 index.js 的代码。1234567891011var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;);// user 路由模块// 当我在 user 文件里面写一个 '/login' 的时候，前端访问就要访问 '/user/login'router.use('/user', require('./users'));module.exports = router; 至此，全文就结束啦，对于 express 框架的分层实践如果有更好的建议或者我这样分层有啥问题的话，欢迎在在下方留言哈，大家一起学习一下。]]></content>
      <categories>
        <category>项目实践</category>
      </categories>
      <tags>
        <tag>express</tag>
        <tag>分层架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手用 express 搭建后台]]></title>
    <url>%2F2018%2F12%2F08%2Fexpress-project-1%2F</url>
    <content type="text"><![CDATA[前言 想必很多小伙伴开始学 node 的时候想搞个项目出来却不知道怎么下手吧，这个教程的话就是教大家用 express 框架简单粗暴搭建一个可以用的后台出来，然后关于 node 和 express 的其他知识，大家还是需要自己去看看文档了解一下。 1 环境准备express 既然是基于 node 的开发框架，首先 node 那些肯定都配好了吧，这个就自己搞去。然后下面就是要搞 express 的东西了。 1、全局安装 express，方便后面直接导入 express 模块。1npm install express -g 2、再全局安装 express 的脚手架工具，装完我们就可以很舒服的生成一个 express 项目了1npm install express-generator -g 2 项目2.1 搭建环境配好后，搭建项目就很舒服啦，直接就是一条指令1express express-demo 接下来就是，安装依赖，运行项目12npm installnpm run start 然后我们打开浏览器查看 3000 端口，看到下面的页面就说明我们 express 后台已经跑起来了 2.2 项目结构生成的项目结构如下图所示1234567891011121314151617181920212223242526272829│ app.js│ package.json│├─.idea│ │ express-demo.iml│ │ modules.xml│ │ vcs.xml│ │ workspace.xml│ ││ └─inspectionProfiles├─bin│ www│├─public│ │ index.html│ ││ ├─images│ ├─javascripts│ └─stylesheets│ style.css│├─routes│ index.js│ users.js│└─views error.jade index.jade layout.jade 我们一个一个来说明哈。 1、bin 文件夹 里面的话有 www 文件，那个就是项目的启动脚本文件，监听端口在里面设置，一般情况不管这个文件。 2、public 文件夹 静态资源文件夹，放着 css，js，img 那些，然后如果在里面写个 index.html 的话，我们访问 3000 端口的时候就会直接访问 index.html 的那个页面。所以这边的话，可以把我们前端开发打包好的代码。 3、routes 文件夹 这个是重点啦，路由文件夹，里面的文件用于生成路由实例，这个路由实例用来响应前端发过的请求，按照现在前后端分离的思想，我们在这里面写后台的那些接口了。我们抓一个文件来看一下12345678910111213141516// index.js// 引入依赖var express = require('express');var router = express.Router();// 处理前端请求/* GET home page. *//* 这边的 router.get 是接收前端的 get 请求 第一个参数是路由地址，这边的 '/' 就指根路由，也就是http://localhost:3000 啦 第二个参数是一个响应接口的回调函数，里面有三个参数，分别是 请求头request 响应体response，和一个next*/router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;);// 导出路由模块module.exports = router; 上面这个是系统默认的给的，他的话是根据模板（下面会讲）生成了一个页面渲染回去，但是我们现在前后端都分离啦，一般都是后台写接口丢给前端就好啦，所以我们要改成下面这个样子123456789101112router.get('/', function(req, res, next) &#123; // 处理好要返回给前端的数据 let data = &#123; name:'xhm', age:12 &#125; // 用 res.json 方法写接口 res.json(&#123; code:0, msg:'ok', data:data &#125;)&#125;); 安装上面这样搞，我们重新访问 3000 端口的时候就会发现这个时候返回就是一个 json 的数据啦（如下图），这样就写了一个简单的后台接口，后面的不同业务逻辑的接口，就看你前面怎么去处理那些数据啦。 4、views 文件夹这个用于存放 jade 模板，这个的话，不懂也比较少会用到，只知道这个可以作为页面的模板来使用，渲染一下报错页面和主页，其他就没有用了。 5、app.js 文件这个是项目的入口文件，这边有着项目的一下配置，也在此整合了项目的模块，其中要注意的就是里面关于路由模块的配置了。看下面代码1234567// 引入 routes 文件夹中的路由文件var indexRouter = require('./routes/index');var usersRouter = require('./routes/users');...// 设置这些路由的地址app.use('/', indexRouter);app.use('/users', usersRouter); 这边做一点说明吧： 这边设置路由的地址是相对于项目的，然后在 routes 文件夹里面的地址是相对于这边的，用上面的代码来说，假设那个 ./routes/users 文件里面定义了 &#39;/login&#39; 这么一个路由地址，那么由于整个 users 的地址是 &#39;/users&#39;，所以我们在外面要访问那个 login 的话，该访问的地址是 http://localhost:3000/users/login。 后面要再想加其他路由模块的时候，就按照上面先引入路由模块，再用 app.use 设置好地址，后面就可以用了。 6、package.json 文件 这个就是整个项目的配置文件啦。项目的名字啦，版本号和项目所需的那些依赖全都写在这里面的啦，但是一般我们是不用管的。 3 数据库既然搭建了后台，数据库肯定是要连接的，不同的数据库的话，就安装不同的插件来使用，如果你使用的是 mongoDB 的话，就推荐使用 mongoose 来操作数据库，关于 mongoose 的使用可以看我另外一篇教程 4 后记源代码的话我放到我的 Github 上面去了,可以去 clone 下来看一下。关于 express 项目的简单开发就讲到这边啦，但是如果是这么简单的设置这个项目的目录结构的话，可扩展性不高，代码复用也不好，所以我们要看下一篇文章啦–express 项目分层实践]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>express</tag>
        <tag>分层架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 自定义指令]]></title>
    <url>%2F2018%2F11%2F26%2Fvue-custom-directive%2F</url>
    <content type="text"><![CDATA[前言 最近搞了毕设，需要实现一个场景，点击一块区域，弹出一个编辑区域，点击页面的其他地方的时候，这个编辑区域就隐藏，本想想之前写模态框一样写个方法的时候，突然 觉得可以尝试用 vue 相关的东西优雅的解决这个事情，然后就学了下面的自定义指令了。 1 Vue 自定义指令1.1 定义直接看官网的介绍吧（觉得官方文档说的很清楚了，所以我基本都是抄他的了）。 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 1.2 基础实现这个在分两种情况，如果你想定义一个全局的自定义组件的话,那么就在项目中的 main.js 里面定义了，例如定义一个官网中的自动聚焦的指令12345678// 注册一个全局自定义指令 `v-focus`Vue.directive('focus', &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 要是你只是想定义一个局部的指令在某个组件内部用的话，那么就在相应的组件内定义了123456789// 跟 data(),methods:&#123;&#125; 那些同级写了directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 定义完后我们就能愉快的使用了1&lt;input v-focus&gt; 1.2 钩子函数当然这个自定义指令不会就这么一点东西啦，为了解决一些现实中场景，Vue 给我们一堆钩子函数用来实现我们的一些骚操作。具体如下 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。 当然要想好好用用这写钩子函数，就要懂得用下面的这些参数 1.3 钩子函数参数指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：- v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { - foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 然后官网有话说 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 然后下面我们给一个简单的例子1234567891011121314151617// 在组件内部定义一个局部指令directives:&#123; demo:&#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify; el.innerHTML = `name: $&#123;s(binding.name)&#125; &lt;br&gt; value: $&#123;s(binding.value)&#125; &lt;br&gt; expression: $&#123;s(binding.expression)&#125; &lt;br&gt; argument: $&#123;s(binding.arg)&#125; &lt;br&gt; modifiers: $&#123;s(binding.modifiers)&#125; &lt;br&gt; vnode keys: $&#123;Object.keys(vnode).join(', ')&#125;` &#125; &#125;&#125; // 绑定到组件中的一个 div 中&lt;div v-demo:foo.a.b="message"&gt;&lt;/div&gt; 然后我们在网页中就可以看到这么一堆文字了(当然下面的注释是我自己写的)123456789101112name: "demo" // 指定名称value: "Welcome to Your Vue.js App" // 指令绑定值expression: "message" // 字符串形式的指令表达式argument: "foo" // 传给指令的参数modifiers: &#123;"a":true,"b":true&#125; // 修饰符的对象vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholderVue 编译生成的虚拟节点 1.4 函数简写在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:123colorSwatch: function colorSwitch(el, binding) &#123; el.style.backgroundColor = binding.value&#125;, 1.5 对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。1&lt;div v-demo="&#123; color: 'white', text: 'hello!' &#125;"&gt;&lt;/div&gt; 1234Vue.directive('demo', function (el, binding) &#123; console.log(binding.value.color) // =&gt; "white" console.log(binding.value.text) // =&gt; "hello!"&#125;) 就差不多这样吧，想看个实例的话就看一下我的另外一篇笔记《Vue 自定义指令实现点击元素外触发事件》吧]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>自定义指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[parent-child-talk]]></title>
    <url>%2F2018%2F11%2F25%2Fparent-child-talk%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Vue 自定义指令实现点击元素外触发事件]]></title>
    <url>%2F2018%2F11%2F25%2Fcustom-directive-clickoutside%2F</url>
    <content type="text"><![CDATA[前言 最近搞了毕设，需要实现一个场景，点击一块区域，弹出一个编辑区域，点击页面的其他地方的时候，这个编辑区域就隐藏，本想想之前写模态框一样写个方法的时候，突然觉得可以尝试用 vue 相关的东西优雅的解决这个事情，然后就学了下面的自定义指令了。 前置知识既然要用 Vue 的自定义指令，那么肯定要了解一下 Vue 自定义指令的相关知识啦，关于这部分的内容，看我之前写过的《Vue 自定义指令》或者直接看官方文档就可以啦，这里我就不再多讲了。 解决思路这个按照我之前写模态框的经验，我的做法是给 document 绑定一个点击事件，然后判断触发点击事件的那个元素是不是模态框所在的目标区域，如果不是，那么就触发隐藏事件。看一下代码吧123456$(document).mouseup(function(e)&#123; var _con = $(' 目标区域 '); // 设置目标区域 if(!_con.is(e.target))&#123; // 判断是不是目标区域 some code... // 功能代码 &#125;&#125;); 实现有了思路，实现起来就简单了。就直接放定义的代码啦12345678910111213141516171819202122232425262728const clickOutside = &#123; // 初始化指令 bind(el, binding, vnode) &#123; function clickHandler(e) &#123; // 这里判断点击的元素是否是本身，是本身，则返回 if (el.contains(e.target)) &#123; return false; &#125; // 判断指令中是否绑定了函数 if (binding.expression) &#123; // 如果绑定了函数 则调用那个函数，此处binding.value就是handleClose方法 binding.value(e); &#125; &#125; // 给当前元素绑定个私有变量，方便在unbind中可以解除事件监听 el.__vueClickOutside__ = clickHandler; document.addEventListener('click', clickHandler); &#125;, update() &#123;&#125;, unbind(el, binding) &#123; // 解除事件监听 document.removeEventListener('click', el.__vueClickOutside__); delete el.__vueClickOutside__; &#125;,&#125;;directives: &#123;clickOutside&#125;, 接下来就可以就可以在组件内直接使用啦1&lt;div v-click-outside="closeDialog"&gt;&lt;/div&gt; 我实现的效果 然后关于这个点击元素外触发某个事件，如果还有啥其他优雅的方式的话，下面留言分享一下哈。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS 中的深拷贝与浅拷贝]]></title>
    <url>%2F2018%2F11%2F25%2Fdeepcopy-shallowcopy-in-JS%2F</url>
    <content type="text"><![CDATA[前言 最近在写项目的时候涉及到一些父子组件传递个对象或者数组通信啥的，或者是直接复制添加对象啥的，直接使用赋值的时候总会出错 1 什么是深拷贝&amp;浅拷贝见名知义，无论是深拷贝还是浅拷贝，都是 copy 的问题。就是 copy 的时候出现的两种情况。区分起来也挺简单的，举个例子，假设 B 是 A 复制过来的，当我们修改 A 的时候，B 也随之改变了，那么这个就是浅拷贝，那要是 B 没有随 A 一起改变的话，那么这个就深拷贝了。 2 现实场景首先呢，我们先要明白在 Javascript 中，有 5 种简单数据类型（也称为基本数据类型），分别是 Undefined，Null，String，Number，Boolean,还有 1 种复杂数据类型即 Object，（ES6 新出的 Symbol 数据类型就先不讨论了） 2.1 基本数据类型对于基本数据类型的复制就谈不上什么深拷贝和浅拷贝了，对于基本数据类型来说，他们的值在栈内存中占据着固定大小的空间，并被保存在栈内存中。假设 变量 b 复制 基本数据类型变量 a，那么 b 会内存中占据自己的空间，和 a 就没啥关系了，大家各管各的，互不干涉。12345let a = 2; let b = a;b = 4;console.log(a); // 2console.log(b); // 4 2.2 复杂数据类型（Object）对于对象的话，他是引用类型，复制起来就要区分浅拷贝和深拷贝了，因为 Object 是引用类型，他真正的值保存在堆内存中，他在栈内存存储是变量名和指向该对象值的指针（就是一个地址），如下图所示。所以当我们用平常用一个变量去复制一个 Object 类型的变量的时候，复制的是他的指针地址而已，所以两个变量最终都指向同一个变量，大家要改一起改，这就是浅拷贝啦，如下12345let obj1 = &#123;name:'kk',age:12,desc:'源对象'&#125;let obj2 = obj1;obj2.desc = '目标对象'console.log(obj1); //&#123;name:'kk',age:12,desc:'目标对象'&#125; 此处源对象跟着一起变了console.log(obj2); // &#123;name:'kk',age:12,desc:'目标对象'&#125; 啥，不信？！，那就看图如何但是在我们日常的使用当中，Object 类型的浅拷贝的行为会让我们很迷，我复制这个对象就是想复制他的值而已啦，不要复制人家个值就和他绑到一块了，跟他一起「同生共死」。所以啊，当我们想按照我们复制的想法，就只复制他的值用来自己用，他的是他的，我的是我的，大家井水不犯河水。接下来就要说咋办了。 3 实现对象类型的深拷贝对于对象的深拷贝，搜集了网上的资料，就有下面三种方法 3.1 slice()&amp;concat()这个是针对数组的深拷贝，可以通过这两个方法实现对数组的深拷贝,如下1234567891011121314151617let arr = [1,2,3,4]let arr2 = arr.slice();arr[0] = 0;console.log(arr); //[1,2,3,4]console.log(arr2); //[1,2,3,4]``` `concat` 同理可得，不过这两个方法有个问题，`slice()` 和 `concat()` 方法能够深拷贝的就只有数组的一级属性，但是如果是多维数组的话，那么只有一级属性的值是深拷贝，往下就都是浅拷贝了，如下所示```javascriptlet arr = [[1,2],2,3,4]let arr2 = arr.concat();arr[0][0] = 0;arr[1] = 1;console.log(arr); //[[0,2],1,3,4]console.log(arr2); //[[0,2],2,3,4]// arr2[1] 没变，但是 arr2[0] 跟着一起改了 3.2 JSON 的骚操作通过 JSON 的 stringify， parase 操作也可以实现对象的深拷贝。123456789101112131415161718192021222324252627282930313233let obj1 = &#123;name:&apos;kk&apos;,age:12,desc:&apos;源对象&apos;&#125;let obj2 = JSON.parase(JSON.stringify(obj1));obj2.desc = &apos;目标对象&apos;;console.log(obj1); //&#123;name:&apos;kk&apos;,age:12,desc:&apos;源对象&apos;&#125; 此处源对象就没有一起变了console.log(obj2); // &#123;name:&apos;kk&apos;,age:12,desc:&apos;目标对象&apos;&#125;``` 此法数组和对象都可以用。### 3.3 自己写一个深拷贝函数自己动手，丰衣足食```javascriptfunction deepCopy(obj) &#123; let newObj = Array.isArray(obj) ? [] : &#123;&#125;; if (obj &amp;&amp; typeof obj === &quot;object&quot;) &#123; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; //判断ojb子元素是否为对象，如果是，递归复制 if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123; newObj[key] = deepCopy(obj[key]); &#125; else &#123; //如果不是，简单复制 newObj[key] = obj[key]; &#125; &#125; &#125; &#125; return newObj;&#125;let a = [1,2,3];let b = deepCopy(a);a[0] = 0;console.log(a); //[0,2,3]console.log(a); // [1,2,3] 3.4 JQ 的 extend 方法这个就直接放文档了$.extend( [deep ], target, object1 [, objectN ] )deep:如果设为true，则递归合并即深拷贝。target:待修改对象。object1:待合并到第一个对象的对象。objectN:待合并到第一个对象的对象。使用如下 let a = [1,2,3], let b = $.extend(true,[],a); a[0]=1; console.log(a); // [0,2,3] console.log(b); // [1,2,3] 以上就是关于 JS 中的深拷贝与浅拷贝的知识和如何进行深拷贝的知识了，如果有错或者有其他方式的话，欢迎在下面留言评论啦。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
        <tag>浅拷贝</tag>
        <tag>对象复制</tag>
        <tag>对象传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 模块化知识]]></title>
    <url>%2F2018%2F11%2F02%2Fjs-module%2F</url>
    <content type="text"><![CDATA[前言最近遇到很多朋友问 Javascript 模块化使用的问题，然后发现对这这个也是一知半解，偶尔还会搞混，在项目中使用的时候会出各种小错误，所以就写一下，复习一下 Javascript 模块化的知识和使用方式。 模块通常是指编程语言所提供的代码组织机制，利用此机制可将程序拆解为独立且通用的代码单元。所谓模块化主要是解决代码分割、作用域隔离、模块之间的依赖管理以及发布到生产环境时的自动化打包与处理等多个方面。 1 模块化的优点 可维护性。因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进。 命名空间。在 JavaScript 里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化开发来封装变量，可以避免污染全局环境。 重用代码。我们有时候会喜欢从之前写过的项目中拷贝代码到新的项目，这没有问题，但是更好的方法是，通过模块引用的方式，来避免重复的代码库。 2 模块化规范2.1 CommonJS 规范CommonJS 是 Mozilla 的工程师于 2009 年开始的一个项目，他的目的是让浏览器之外的 Javascript （比如服务器端或者桌面端）能够通过模块化的方式来开发和协作。 在 CommonJS 规范中，每个 JS 文件就是一个独立的模块上下文（module context），在这个上下文中创建的属性都是私有的。也就是说，在一个文件定义的变量（包括函数和类），都是私有的，对其他文件是不可见的。 2.1.1 实例这里分两种情况讲明吧，一种是一个文件中导出一个模块，这种我们引入模块的时候可以定义随便一个变量名去接入使用模块。另外则是一个文件中导出多个模块。这种情况的话，模块文件导出的是一个包含多个模块的对象，我们导入引用的时候只能是用一个对象 {} 引用，然后这边使用的模块名必须要和源文件中导出的模块名一致。（这边有点绕，具体看代码就明白了） 一个文件导出一个模块 123456789// sayHello.jsfunction sayHello()&#123; console.log('hello')&#125;module.exports = sayHello//main.js 中引入 sayHello.js// 引入单个模块，这里引入的时候可以 say，sayHello 等等变量名去定义导入的模块 const say = require('./sayHello.js'); 一个文件导出多个模块 12345678910111213// say.jsfunction sayHi()&#123; console.log('hello'); &#125;function sayBye()&#123; console.log('bye');&#125;module.exports = &#123;sayBye,sayHi&#125;/* main.js* 这个时候引用的话，用&#123;&#125;去引用导出的模块，怎么导出我们就怎么引用，然后里面的模块名就只能是引用文件 say.js 里面定义的 sayBye，sayHi 变量名*/const &#123;sayBye, sayHello&#125; = require('./say.js'); 2.1.2 注意事项因为 CommonJS 规范主要应用的场景是服务器端，所以采用同步加载模块的策略。如果我们依赖 3 个模块，代码会一个一个一次加载，这种的话就不适合浏览器端来使用了。 2.2 AMD 规范AMD 是 Asynchronous Module Definition 的简称，即『异步模块定义 』，见名知义，AMD 优先照顾浏览器模块的加载场景，使用异步加载和回调的方式。注意使用模式需要 define 方法的支持。一般是引用 requireJS 2.2.1 实例123456789101112131415// file lib/sayModule.js define(function ()&#123; return &#123; sayHello: function () &#123; console.log('hello'); &#125; &#125;; &#125;); //file main.js define(['./lib/sayModule'], function (say)&#123; say.sayHello(); //hello &#125;) 这种形式感觉有点烦，个人基本都没怎么用。 2.3 CMD 规范CMD 是 Common Module Definition，公共模块定义， 2.4 ES6 规范ES6 规范用的就比较多了，他的话比较简单清晰，就分为导出（export）与导入（import）两个模块 然后他的使用方式也是有很多种情况。 直接用 export {模块，模块} 导出。引用的话就直接用 import from 导出就可以了。 123456789// module.jslet fn = function()&#123; console.log('test');&#125;let bar = 'bar';export &#123;fn, bar&#125;// main.jsimport &#123;bar, fn&#125; from './module'; 重命名导出与导入。有时候发现我引用了两个文件的模块的名字是一样的，然后就会出现命名冲突了，这个时候就需要重命名导出导入来解决这种情况了，具体就看代码了。 12345678// 导出重命名let name = 'name';// 这个时候其他文件导入的时候就用 newName 导入了export &#123; name as newName&#125;// 导入重命名// 这样我们就用 newName 这个名字重命名原来的模块了。import &#123; moduleName as newName&#125; from 'test' export default 匿名导出，如果只想导出一个 js 模块或者功能，可以直接用 export default 导出 123456// module.js 字符串，方法，对象，想导出啥就导出啥export default 'string';// main.js XX YY，想用啥命名就用啥命名，毕竟导出的就只有一个对象import XXX from './lib'console.log(XXX) // 'string' 总结一般就用 ES6 的规范和 CommonJS 的规范，AMD 和CMD 实在不熟，就没用过了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>CommonJS</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单学习 Promise 对象]]></title>
    <url>%2F2018%2F10%2F24%2Flearn-promise%2F</url>
    <content type="text"><![CDATA[引言 Promise 是异步编程的一种解决方案，比传统的解决方案——回调和事件——更合理且强大。最近的项目要用到这个，就参考阮一峰老师的《ES6标准入门》这本书简单学一下了。 1 Promise 的含义所谓 Promise ，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上来看，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise 对象有以下两个特点。 对象的状态不受外界影响。 一旦状态改变就不会再变。 2 基本用法ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。举个例子。 123456789var promise = new Promise(function (resolve, reject) &#123; // some code if (/* 异步操作成功*/) &#123; resolve(value); &#125; else &#123; // 异步操作失败 reject(error); &#125;&#125;); Promise 构造函数接收一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。他们是两个函数，由 Javascript 引擎提供，不用自己部署。 resolve 函数的作用是将 Promise 对象的状态从『未完成』（Pending）变为『成功』（Resolved），在异步操作成功的时候调用，并将异步操作的结果作为参数传递过去。 reject 函数的作用是，将 Promise 对象的状态从『未完成』（Pending）变为『失败』（Rejected） 当我们生成了一个 Promise 实例之后。就可以用 then 方法分别指定 Resolved 状态和 Rejected 状态的回调函数。 1234567promise.then(function (value) &#123; // success console.log(value);&#125;, function (error) &#123; // failed console.log(error);&#125;); then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 Resolved 时调用，第二个回调函数是 Promise 对象的状态变为 Rejected 时调用。其中第二个参数是可选的，不一定要提供。这两个函数都接收 Promise 对象传出的值作为参数。 我们来个小例子 1234567891011121314let promise = new Promise(function(resolve,reject)&#123; console.log('Promise'); let value = 'value'; resolve(value);&#125;);promise.then(function(value)&#123; console.log(value);&#125;);console.log('Hi');// Promise// Hi// value 上面的代码中，Promise 新建后会立即执行，所以首先输出的是 Promise。然后，then 方法指定的回调函数将当前脚本所有同步任务执行完成后才会执行，所以 Resolved 最后输出。 3 Promise.prototype.then()Promise 实例具有 then 方法，即 then 方法是定义在原型对象 Promise.prototype 上的。它的作用是为 Promise 实例添加改变状态时的回调函数。前面说过，then 方法的第一个参数是 Resolved 状态的回调函数，第二个参数（可选）是 Rejected 状态的回调函数。 then 方法返回的是一个新的 Promise 实例（注意 不是原来的那个 Promise 实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。 12345getJSON("/posts.json").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 上面的代码使用 then 方法依次指定了两个回调函数。第一个回调函数完成以后，将会返回结果作为参数，传入第二个回调函数。 然后采用链式的 then 可以指定一组按顺序调用的回调函数。这时，前一个回调函数有可能返回的还是一个 Promise 对象（即有异步操作），而后一个回调函数就会等待该 Promise 对象的状态发生变化，再被调用。 4 Promise.prototype.catch()Promise.prototype.catch 方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面的代码中，getJSON 方法返回一个 Promise 对象，如果该对象状态变为 Resolved，则会调用 then 方法指定的回调函数；如果异步操作抛出错误，状态就会变成 Rejected，然后调用 catch 方法指定的回调函数处理这个错误。另外， then 方法指定的回调函数如果在运行中抛出错误，也会被 catch 方法捕获。 123456p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err)); // 等同于 p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err)); 下面是一个例子。 1234567const promise = new Promise(function(resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// Error: test 上面的代码中，Promise 抛出一个错误就被 catch 方法指定的回调函数所捕获。注意，上面的写法和下面两种写法是等价的。12345678910111213141516171819// 写法一const promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error('test'); &#125; catch(e) &#123; reject(e); &#125;&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// 写法二const promise = new Promise(function(resolve, reject) &#123; reject(new Error('test'));&#125;);promise.catch(function(error) &#123; console.log(error);&#125;); 由上面可以看出， reject 方法的作用等同于抛出错误。如果 Promise 状态已经变成 Resolved，在抛出错误是无效的。123456789const promise = new Promise(function(resolve, reject) &#123; resolve('ok'); // Promise 状态已变成 已完成 throw new Error('test');&#125;);promise .then(function(value) &#123; console.log(value) &#125;) .catch(function(error) &#123; console.log(error) &#125;);// ok 注意 一般来说，不要在 then 方法中定义 Reject 状态的回调函数（即 then 的第二个参数），而是使用 catch 方法。 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error&#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面 then 方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用 catch 方法，而不使用 then 方法的第二个参数。 5 Promise.all()Promise.all 方法是将多个 Promise 对象实例包装成一个新的实例。 1var p = Promise.all([p1, p2, p3]); 上面的代码中，Promise.all() 方法接受一个数组作为参数，p1, p2, p3 都是 Promise 对象的实例。如果不是，就会先调用下面讲到的 Promise.resolve 方法，将参数转换为 Promise 实例，再进一步处理（Promise.all 方法的参数不一定是数组，但是必须具有 Iterator 接口，且每个返回成员都是 Promise 实例）。 p 的状态由 p1, p2, p3 决定，分成两种情况 只有 p1, p2, p3 的状态都变成 FulFilled，p 的状态才会变成 FulFilled，此时 p1, p2, p3 的返回值组成一个数组，传递给 p 的回调函数。 只要 p1，p2，p3 中有一个被 Rejected ，p 的状态就直接变成 Rejected，此时第一个被 Rejected 的实例的返回值会传递给 p 的回调函数。 下面是一个具体例子。12345678910111213var promises = [2,3,4,5].map(function(id)&#123; console.log(id) &#125;); Promise.all(promises).then(function(res)&#123; console.log(res); resolve &#125;).catch(function(error)&#123; console.log(error); &#125;);// 先执行所有 promise 实例的异步操作，然后吧操作的结果打包数组返回// 2 3 4 5 [undefined,undefined,undefined,undefined] 上面的代码中，Promise 是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成 fulfilled，或者其中有 1 个变成 rejected，才会调用 Promise.all 方法后面的回调函数。 6 Promise.race()Promise.race 方法同样是将多个 Promise 实例包装成一个新的 Promise 实例。 1var p = Promise.race([p1, p2, p]) 上面的代码中，只要 p1, p2, p3 中 有一个实例 率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值就传递给 p 的回调函数。Promise.race 方法的参数与 Promise.all 方法一样，如果不是 Promise 实例，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。 下面是一个例子,如果指定时间内没有获得结果，就将 Promise 的状态变成 Rejected，否则就变为 Resolved。 12345678910const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error); 上面代码中，如果 5 秒之内 fetch 方法无法返回结果，变量 p 的状态就会变为 rejected，从而触发 catch 方法指定的回调函数。 7 Promise.resolve()有时需要将现有对象转为 Promise 对象，Promise.resolve 方法就起到这个作用。 1const jsPromise = Promise.resolve($.ajax('/whatever.json')); 上面代码将 jQuery 生成的 deferred 对象，转为一个新的 Promise 对象。 Promise.resolve 等价于下面的写法。 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.resolve方法的参数分成四种情况。 7.1 参数是一个 Promise 实例如果参数是一个 Promise 实例，那么 Promise.resolve 将不做任何修改，原封不动的返回这个实例。 7.2 参数是一个 thenable 对象thenable 对象是指具有 then 方法的对象，例如下面这个对象 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve 方法会将这个对象转为 Promise 对象，任何执行 thenable 对象的 then 方法。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 上面的代码中， thenable 对象的 then 方法执行后，对象 p1 的状态就变为 resolved，从而立即执行最后的 then 方法指定的回调函数。输出 42。 7.3 参数不是具有 then 方法的对象，或根本就不是对象如果参数是一个原始值，或者是一个不具有 then 方法的对象，那么 Promise.resolved 方法返回一个新的 Promise 对象，状态为 Resolved。 123456const p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello 上面代码生成一个新的 Promise 对象的实例 p。由于字符串 Hello 不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是 resolved，所以回调函数会立即执行。Promise.resolve 方法的参数，会同时传给回调函数。 7.4 不带有任何参数Promise.resolved 方法允许在调用时不带有参数，而直接返回一个 Resolved 状态的 Promise 对象。 所以，如果你希望得到一个 Promise 对象，比较方便的方法就是直接调用 Promise.resolve 方法。 12345const p = Promise.resolve();p.then(function () &#123; // ...&#125;); 上面代码中的 p 就是一个 Promise 对象。需要注意的是，立即 resolve 的 Promise 对象实在本轮 『事件循环』（event loop）结束时，而不是在下一轮『事件循环』开始时。 12345678910111213setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three 上面代码中，setTimeout(fn, 0) 在下一轮『事件循环』开始时执行，Promise.resolve() 在本轮『事件循环』结束时执行，console.log(&#39;one&#39;) 则是立即执行，因此最先输出。 8 Promise.reject()Promise.reject(resson) 方法也会返回一个新的 Promise 实例，状态为 Rejected （这个就暂时想不懂怎么应用了）。 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 上面的代码生成一个 Promise 对象的实例 p，状态为 Rejected，回调函数会立即执行。 总结以上就是关于 Promise 学习的内容，如有错误的地方就请在下面评论处，发表一下看法，当然也可以放一下关于进阶学习 Promise 的文章，大家一起学习。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongose 插件的简单使用]]></title>
    <url>%2F2018%2F10%2F23%2Fusing-mongoose%2F</url>
    <content type="text"><![CDATA[摘要 由于毕业设计要做小程序·云开发，它那边的云数据库是非关系数据库，所以就要用一下非关系型的数据库来开发了，这里的话，我就使用比较常用的 mongoDB 这个非关系型的数据库了。然后调用它的话一般使用 mongoose 这个插件来用，趁着做毕设，就学习一下怎么用这个家伙吧。 1 安装1npm i mongoose 2 使用2.1 连接 mongoDB在后台跑起来后或者是初始化请求的时候，引入mongoose，连接数据库，以我搭的 express 框架为例，在路由的 index 文件中连接数据库。 12345678910111213const mongoose = require('mongoose');/** * 连接 mongoDB 的 user 数据库 */mongoose.connect('mongodb://localhost/user');const db = mongoose.connection;// 连接失败db.on('error', console.error.bind(console, 'connection error:'));// 连接成功db.once('open', function() &#123; console.log("mongoDB connected success"); // we're connected!&#125;); 2.2 创建连接Mongoose 里，一切都始于 Schema。 现在我们来看一个我项目中例子。（鉴于篇幅，删减了哈） 123const user = new mongoose.Schema(&#123; userId:String&#125; 现在我们就创建了一个 带有 String 类型 userId 属性的 schema。接着我们需要把这个 schema 编译成一个 Model。通过这个 Model 我们就能够直接操纵数据库里面的数据了 1234/*model 的参数1 导出的模块名， 参数2 创建的 Schema，参数3 指定数据库中的集合的名字，若不加的，则抹默认取‘第一个参数s’的集合*/module.exports = mongoose.model('User',user,'user'); 2.3 做个小查询首先我们需要先引入模块 1const User = require('./../../models/user'); 接下来就是直接查询了 12345678// 获取 user 表中的所有数据User.find(function (err, doc) &#123; if (err)&#123; return console.error(err); &#125; // 打印查询到的内容，后面要怎么操作这些数据就看具体的业务需求了 console.log(doc);&#125;) 如果我们想获取特定的数据，这个时候就了解有一下 query 的用法了,下面给出一个简单的小例子。12// 这么写可以获取所有 name 为 "Fluff" 开头的数据,然后在 callback 里面去写怎么处理那些数据咯User.find(&#123; name: /^fluff/ &#125;, callback); 关于 mongoose 的简单使用就差不多这个样子了]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack3 迁移到 Webpack4]]></title>
    <url>%2F2018%2F10%2F16%2Fupdate-webpack4%2F</url>
    <content type="text"><![CDATA[为什么要迁移其实我是不知道的，只是实习的公司的项目要迁移，所以采取了解这方面的东西，公司的原因是由于公司项目越来越大，需要的依赖越来越多，导致开发的时候重新构建的时候速度十分缓慢，开发效率很低。 升级 webpack4 直奔主题，直接开始升级 首先升级 webpack4 到 4.8.1 （当然其他 4 的版本都是可以的），顺便安装一下 webpack-cli1npm install webpack@4.8.1 webpack-cli -D 然后我们 npm run dev 一下。 『报错啦！』 这个是因为 webpack 和 webpack-dev-server 版本不兼容，升级一下就好了 1npm install webpack-dev-server@3.1.4 -D 再次启动，又报错了。。。 这里是因为 html-webpack-plugin 版本不兼容导致的，网上给出的解决方案大部分是说执行 yarm add webpack-contrib/html-webpack-plugin -D 但是现在作者已经更新版本了，直接升级版本就可以了，不需要再去安装 webpack 官方的替代版本1npm install html-webpack-plugin@3.2.0 -D 再次启动，再次报错 升级一下 eslint 和 eslint-loader 吧1npm install eslint eslint-loader@2.0.0 -D 继续报错 升级 vue-loader 吧1npm install vue-loader@15.0.10 -D 错的更彻底了 这是因为新版的 vue-loader 需要加入一个新的配置 VueLoaderPlugin。所以要在下面这些文件修改一下配置。 1234567891011121314151617181920// webpack.dev.conf.js 文件// 引入 VueLoaderPluginconst &#123; VueLoaderPlugin &#125; = require('vue-loader')// 在下面的插件中添加 VueLoaderPlugin plugins: [ ... new VueLoaderPlugin(), ... ] // webpack.prod.conf.js 文件// 这个和上面的文件一样处理了// 引入 VueLoaderPluginconst &#123; VueLoaderPlugin &#125; = require('vue-loader')// 在下面的插件中添加 VueLoaderPlugin plugins: [ ... new VueLoaderPlugin(), ... ] 再来，再来 这个是 webpack4 需要指定一下打包的模式（mode），指定一下就好，直接该配置就行了。『不要慌，小问题』 1234567891011// webpack.dev.conf.js文件const devWebpackConfig = merge(baseWebpackConfig, &#123; mode: 'development', module: &#123;...&#125;&#125;,//同理在 webpack.prod.conf.js 文件const devWebpackConfig = merge(baseWebpackConfig, &#123; mode: 'production', module: &#123;...&#125;&#125;, 疲惫的手再次按起了 npm run dev 震惊！居然没错了，居然可以运行了。好的，webpack4 升级结束，撒花！！ 然而当我默默敲起了 npm run build 该错的终究还是要错的啊。。 这部分的错误是因为 webpack.optimize.CommonsChunkPlugin 已经被弃用，需要使用新的配置 config.optimization.splitChunks，在下面的文件再改一下配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// webpack.prod.conf.js 文件// 在 plugins 同级下添加下面代码optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; test: /[\\/]node_modules[\\/]/, name: 'vendor', chunks: 'all' &#125;, manifest: &#123; name: 'manifest', minChunks: Infinity &#125;, &#125; &#125;, &#125;, // 嗯，就在上面加这一段代码 plugins:[...] // 分割线// 再去掉该文件中 plugins 中的这部分代码 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks(module) &#123; // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, '../node_modules') ) === 0 ) &#125; &#125;), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', minChunks: Infinity &#125;), // This instance extracts shared chunks from code splitted chunks and bundles them // in a separate chunk, similar to the vendor chunk // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk new webpack.optimize.CommonsChunkPlugin(&#123; name: 'app', async: 'vendor-async', children: true, minChunks: 3 &#125;), ...// 不要客气，全删了，怕错就先注释掉呗。 让我们再次打包 『这个是大问题，要慌！』这个是因为官方已经不推荐使用 extract-text-webpack-plugin 提取 css 样式，可以使用 mini-css-extract-plugin 替代如果不想改变的话可以升级 extract-text-webpack-plugin 1&quot;extract-text-webpack-plugin&quot;: &quot;^4.0.0-beta.0&quot;, 但是，我们还是要用推荐的 mini-css-extract-plugin 首先安装一下插件1npm install mini-css-extract-plugin -D 记得去掉 package.json 中的包 “extract-text-webpack-plugin”: “^4.0.0-beta.0” 然后我们又来改配置了 1234567891011121314151617181920212223242526272829303132333435363738//build 里面的util.js 文件// 1 去掉 extract-text-webpack-pluginconst ExtractTextPlugin = require('extract-text-webpack-plugin') // 走好了您咧// 2 引入新大佬const MiniCssExtractPlugin = require('mini-css-extract-plugin')// 3 修改下面的 generateLoaders 函数// 删掉原来的即我注释的代码，修改成下面这个样子function generateLoaders (loader, loaderOptions) &#123; ... if (options.extract) &#123; // return ExtractTextPlugin.extract(&#123; // use: loaders, // fallback: 'vue-style-loader' // &#125;) return [MiniCssExtractPlugin.loader].concat(loaders) &#125; else &#123; return ['vue-style-loader'].concat(loaders) &#125;&#125;// webpack.prod.conf.js文件// 1 去掉 extract-text-webpack-plugin// 删这个const ExtractTextPlugin = require('extract-text-webpack-plugin') // 加下面的const MiniCssExtractPlugin = require('mini-css-extract-plugin')// 2 去掉 plugins 里的配置 new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].[contenthash].css'), allChunks: true, &#125;),// 3 在 plugins 加入新的插件配置 new MiniCssExtractPlugin(&#123; filename: utils.assetsPath('css/[name].[contenthash:12].css'), allChunks: true, &#125;), 最后再打包。。。 欢乐女神，圣洁美丽，webpack4 升级完成咧，如有其他问题，留言加百度，我们一起研究研究。]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>升级Webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则基础知识]]></title>
    <url>%2F2018%2F10%2F13%2Freg-knowledge%2F</url>
    <content type="text"><![CDATA[正则表达式1 定义正则12let reg = new RegExp("G");//RegExp对象，参数就是我们要制定的规则let reg = /G/; //一般写法，推荐使用，性能更好 2 常用方法 test()：在字符串中查找符合正则的内容，找到返回true，反之返回false 1234//判断数字是否有非数字let str ='1233456';let reg = /\D/;console.log(reg.test(str));//false exec() RegExp的exec()方法和String的match()方法很类似，它对一个指定的字符串执行一个正则表达式匹配，如果没有找到任何一个匹配，它将返回null，否则返回一个数组，这个数组的第一个元素包含的是与正则表达式相匹配的字符串,余下的所有元素包含的是匹配的各个分组。而且，正则表达式对象的index属性还包含了匹配发生的字符串的位置，属性input引用的则是被检索的字符串。如果正则表达式具有g标志，它将把该对象的lastIndex属性设置到紧接着匹配字符串的位置开始检索，如果exec()没有发现任何匹配，它将把lastIndex属性重置为0，这一特殊的行为可以使你可以反复调用exec()遍历一个字符串中所有的正则表达式匹配。1234let str5 = 'cat,fat,bat,sat,cct';let reg5 = /.at/g;reg5.lastIndex = 10;console.log(reg5.exec(str5));//[ 'cat', index: 0, input: 'cat,fat,bat,sat,cct' ] replace():查找符合正则的字符串，替换成对应的字符串 1234567891011121314//替换关键字let str4 = '七夕，JJ，我在月下等你';let reg4 = /七夕|JJ/g;/*str4 = str4.replace(reg4,'*');console.log(str4);//*，*，我在月下等你.有点问题啊，那么就不要直接替换，我们用个回调函数解决*/str4 = str4.replace(reg4,function (str4) &#123; let res = ''; for(let i =0;i&lt;str4.length;i++)&#123; res +='*'; &#125; return res;&#125;);console.log(str4);//**，**，我在月下等你 search():在字符串搜索符合正则的内容，搜索到就返回出现的位置注意：如果找到多个，则只会返回第一个找到的字符的位置，找不到就返回- 1234//在字符串中找到字母b，且不区分大小写let str2 = 'abcbdef';let reg2 = /B/gi;console.log(str2.search(reg2));//2 找到的第一个字符的位置 match():在字符串中搜索符合规则的内容，搜索成功就返回内容，反之则返回null 1234//找到指定格式的所有数字let str3 = 'haj123sdk54hask33dkhalsd879';let reg3 = /\d+/g;//每次至少匹配一个数字console.log(str3.match(reg3));//[ '123', '54', '33', '879' ] 3 常见字符 转义字符 这几个常见转义字符还是要的顺手记下滴12345678\s :空格\S :非空格\d :数字\D :非数字\w :字符（字母，数字，下划线那些）\W :非字符. :任意字符\. :真正的点 量词 123456&#123;n,m&#125; :出现n~m次&#123;n,&#125; :至少n次&#123;n&#125; :出现n次* :任意次? :1次或者0次，相当于&#123;0,&#125;+ :1~n次 其他符号 123456^ :匹配输入串的开始位置$ :匹配输入串的结束位置[] :[]里面的任意字符[^] :非[]里面的任意字符() :分组符，小括号中的项叫做正则的子项$1($n) :正则式中的第1（n）个子项]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[配置自己的github博客]]></title>
    <url>%2F2018%2F10%2F10%2Fdeploy-hexo%2F</url>
    <content type="text"><![CDATA[1 项目结构1.1 _config.yml网站的配置信息，在这边配置网站的大部分信息 1.2 scaffolds模板文件夹，新建文件会根据里面的模板创建新的文件 1.3 source资源文件夹是存放用户资源的地方，然后 _posts 是存放 markdown 文章的地方 1.4 themes主题文件夹，hexo 会根据主题生成静态文件夹。本次我们使用的主题是 Next 主题主题网站 2 _config.yml 的配置2.1 网站我们可以在 _config.yml 文件 中修改大部分的配置，具体咋配置，我就偷个懒了。直接贴中文文档的图了。其中，language 就设置为 zh-Hans 啦，毕竟咱还是用中文写博客的，当然如果有大佬想搞个国际化的全英博客的话就另当别论了。 description 主要用于SEO，告诉搜索引擎一个关于我们站点的简单描述，官方是推荐在里面写我们站点的关键字，主题啥的，但是个人咧还是比较喜欢直接写个个人签名╭(╯^╰)╮ author 参数就是来说这个博客的是谁家的孩子啦。 2.2 网址如果你的网站存放在子目录中，例如 http://yoursite.com/blog，则请将你的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 2.3 目录这里是高端局，我这种菜鸡就老老实实跟着官方走，不乱改了。 2.4 文章默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 example.com，您有一篇文章名为 hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 2.5 其他 3 其他配置3.1 标签、分类、关于设置仔细看了一下上面关于目录的配置，然后又看了其他人的 hexo 博客，心头是不是一阵疑惑，咦，咋感觉自己少了那么多目录结构咧。咋整啊？自己装呗。123hexo new page &quot;tags&quot;hexo new page &quot;categories&quot;hexo new page &quot;about&quot; 执行完这三条命令后，在站点的source 的目录下就生成了 tags，about，categories 三个文件夹然后就分别到 source 文件夹中新生成的 about 文件夹里面的 index.md 中添加下面的代码type: “tags”重新运行之后是不是就出来了，什么？出不来？好吧，我错了，这样的话就要去看你选择的 theme 里面的配置了，把 menu 里面对这三个菜单项的注释去掉，就可以了。再不行的话，那就那就，百度吧。 3.2 关联到 github pages 修改 _config.yml, 在文件最底部添加如下代码 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: ssh://git@github.com/你的github名/你的github名.github.io.git branch: master 安装一个 hexo 插件 1npm install hexo-deployer-git --save 部署项目，就直接运行下面三条命令就行了 123hexo clean // 清除原来打包的项目hexo g // 生成新的项目hexo d // 上传项目到github 最后的最后，让我们打开浏览器，输入 https://你的github用户名.github.io，例如我的 https://lijiayuan365.github.io\ 4 真正的最后强烈推荐下面这位大佬的博客 Hexo 博客主题的设置与完善，可以说是相当的全面与仔细了，快速配置好你的博客。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>配置博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2018%2F08%2F26%2Fflex-knowledge%2F</url>
    <content type="text"><![CDATA[语法篇一、flex是啥?flex即Flexible Box，意为弹性盒布局，用来为盒状模型提供最大的灵活性。（任何一个容器都可以被指定为flex布局）用法：display:flex 注意设置为flex布局之后，子元素的float，clear，vertical-align属性将失效 二、基本概念采用flex布局的元素，称为flex容器（flex container）简称“容器”，它的所有子元素自动成为容器成员，称为flex项目（flex item），简称“项目”。容器默认存在两根轴，水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start,结束位置叫做mainend；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列，单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下有六个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性flex-direction属性决定主轴方向（即项目的排列方向）它可能有四个值 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称轴线）上，flex-wrap属性定义，如果一条轴线排不下，如何换行。它可能取三个值 nowrap(默认)：不换行 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方 3.3 flex-flowflex-flow属性是flex-direction属性与flex-wrap属性的简写形式，默认值为row nowrap（水平排列，不换行） 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。（主轴如果是水平的话，那么就是定义项目是否水平居中那些的了）它可能取5个值，具体对齐方式与主轴的方向有关，下面假设主轴为从左到右 flex-start（默认值）：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等。所以，每个项目之间的间隔比项目与边框的间隔大一倍 3.5 align-items属性align-it属性定义项目在交叉轴上如何对齐。（默认的就是垂直方向的居中那些问题啦）它可能有五个值 flex-start:交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐（一般的话就是垂直居中啦） baseline：项目的第一行文字的基线对齐。 stretch（默认）：如果项目未设置高度或设为auto，将占满整个容器的高度 3.6 align-content属性align-content属性定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用它可能的值有 flex-start：与交叉轴的起点对齐 flex-end：与交叉轴的终点对齐 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间平均分布 space-around:每根轴线两侧的间隔都相等，所以轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink blex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序，数值越小，排列越靠前，默认为0. 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 注 如果所有的项目的flex-grow属性都为一，则它们将等分剩余空间(如果有的话)，如果每个项目的属性值不同，那么首先就是先把剩余空间等分成所有项目flex-grow值之和份，然后每个项目根据自己的flex-grow值分剩余空间。例：三个项目，两个flex-grow值为1，一个值为2，则将剩余空间4等份，其中那个flex-grow值为2的项目分得2/4的剩余空间 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 注如果所有项目的flex-shrink属性都为1负值对该属性无效 4.4 flex-basis属性flex-basis属性定义了再分配多余空间之前，项目占据主轴的空间。浏览器根据这个属性，计算主轴是否有多余的空间，它默认为auto，即项目的本来大小。 4.5flex属性flex属性是flex-grow，flex-shrink，flex-basis的简写，默认值为0 1 auto，后两个属性可选。（一般也是直接用这个） 该属性有两个快捷键值：auto（1 1 auto）和none（0 0 auto）然后肯定推荐用这个啦。 4.6 align-self属性align-self属性允许单个项目有着与其他项目不一样的对齐方式，可覆盖align-item属性，默认为auto，表示继承父元素的align-items属性，如果没有父元素，等同于stretch。该属性和容器的align-items属性一样可能取6个值，除了auto，其他都和它一样。 后记本文学习自阮一峰老师的flex布局教程语法篇（完）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端布局</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则练习题]]></title>
    <url>%2F2018%2F06%2F30%2Freg-trian%2F</url>
    <content type="text"><![CDATA[前言我们在上次说到了一些关于正则表达式的基本知识，然后学啥东西都一样，要会用，不然干看着概念，就算你厉害把所有的知识点都背下来了，但是一段时间不看就会忘记了，所以咧，还是要找一点题练一下，这次的话就随便找了几道我做项目的时候做的正则的题型，权当复习吧邮箱校验 要求：能够识别判断当前使用比较多的免费邮箱，企业邮箱不熟，以后再考虑1234let demo = "123@qq.com";let pataern = /^[a-zA-Z0-9_.]+@[a-zA-Z0-9-]+(\.[a-zA-Z0-9]+)*\.[a-zA-Z0-9]&#123;2,6&#125;/;let res = pataern.test(demo);console.log(res);//true 账户姓名校验 要求：1-n个以字母开头的字符串12345678910const n = 5;let user1 = 'ssh';let user2 = '1word';function UserName(user) &#123; let reg = /^[a-zA-Z][a-zA-Z0-9_]&#123;0,4&#125;$/; let result = reg.test(user); return result;&#125;console.log(UserName(user1));//trueconsole.log(UserName(user2));//false 密码校验 要求：6-12字母、数字、下划线123456789let pwd1 = 's';let pwd2 = '1_word';function Password(pwd) &#123; let reg = /[a-zA-Z0-9_]&#123;6,12&#125;$/; let result = reg.test(pwd); return result;&#125;console.log(Password(pwd1));//falseconsole.log(Password(pwd2));//true 格式化金额 要求：将数字转换为形如￥2,000.12的形式1let 获取金额中的有效数字 要求：将￥2,000.20中的有效数字提取出来，如2000.2123456789let str = `CNY 1,000.0`;function tiqu(str)&#123; let reg = /[^0-9\.]/g;//去掉货币符号和逗号 str = str.replace(reg,''); str = parseFloat(str);//如果去掉无效的小数数据 return str;&#125;let res = tiqu(str);console.log(res);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>正则</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建自己的github博客]]></title>
    <url>%2F2018%2F06%2F25%2Fbuild-hexo%2F</url>
    <content type="text"><![CDATA[1 什么是 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2 开始搭建博客2.1 前提电脑安装好 Node 和 Git 2.2 安装直接用 npm 全局安装（嫌慢的话就用 cnpm 吧）1npm install -g hexo-cli 2.3 搭建博客网站完成 Hexo 的安装之后，就可以执行下面的命令，在指定文件夹内生成系列的网站文件123hexo init folderNamecd folderNamenpm install // 安装依赖 注意好像新版本的 hexo-cli 在初始化项目的时候会自动安装依赖，如下图\鉴于网络因素，直接用npm 安装依赖实在是太慢了，想快一点的同学看到他在装依赖的时候，不要怂，直接就是 Ctrl+C 断了它进程，然后自己进入文件夹用 cnpm install 装依赖。 3 查看效果运行下面代码，开启博客1hexo server 最后打开4000端口就可以看到自己的博客网站啦 4 项目结构新建个项目之后，指定的文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 4.1 _config.yml网站的 配置 信息，小伙伴们可以在这边配置大部分的参数。 4.2 package.json这个就不说了，就是这个项目的信息了。 4.3 scaffold 文件夹模板 文件夹。当我们新建文章的时候，Hexo 会根据 scaffold 来建议文件\Hexo 的模板是指在新建的 markdown 文件中默认填充的内容。例如，如果我们修改 scaffold/post.md 中的 Front-matter 内容，那么没一次新建一篇文章都会包含这个修改 4.4 source 文件夹资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _(下划线)的文件/文件夹和隐藏的文件将会被忽略（意思就是在这里不要以下划线开头去命名新建的文件/文件夹）。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 4.5 themes 文件夹主题 文件夹。Hexo会根据主题来生成静态页面。这里的话，推荐一个主题吧。 next 我也不知道为啥要推荐它，反正就瞅他顺眼+多人用+文档全吧。不过想用其他也随便吧，反正写博客嘛，咱们还是多关注内容，外观的话，顺眼舒服就行了。 5 开始写博客这个就很简单了，三步走直接搞定啦。 直接找个能写 markdown 的工具就开始写我们的博客了。这里的话我推荐用一下 『有道云笔记』吧（『有道云笔记』的工作人员看到了麻烦给点广告费啊~(@^_^@)~），平常就可以在上面做做笔记，写写博客，写完直接导出来一个 markdown 文件。当然其他编辑器一般也是可以方便的写 markdown 的。\『注意：这里有道云笔记有个坑点，不是会员不给 markdown 引入本地的图片，如果想用图片的话只能引入网上外链，这时候就要使用图床了，这边推荐用一下『七牛云』吧，有免费 10 G 的空间可以用。（『七牛云』的小姐姐看到麻烦给我叫个鸡腿），里面还有一些使用技巧，这里就不说了，大家自己再去百度玩一下吧。』 将写完的 markdowm 文件直接丢到 source/_posts 文件夹内，但是为了方便分类和管理自己的文章，在导出的 markdown 文件加入下面这些东西 1234567891011---#文章标题title: flex布局#文章发布时间date: 2018-08-26 21:37:55#文章的标签，可多写几个tags: 前端布局#文章分类categories: flex---#下面就是我们的文章正文啦 上面然后就可以在我们的站点中看到我们新增的博客啦。 6 后续讲到这里，我们的博客已经搭建起来的了，如果还有不明白的东西可以去翻翻 hexo 中文文档。最后咧，虽然博客搭起来了，也能写了，但是不自己配置一下的话，还是有点简陋的，所以下次就来讲讲如何去配置我们的 Hexo 博客吧。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
