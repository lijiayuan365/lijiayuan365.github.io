<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小红帽学前端 | 1.1 HTML 简介]]></title>
    <url>%2F2019%2F08%2F25%2Fcxqd-1-1-htmlDesc%2F</url>
    <content type="text"><![CDATA[前言 从今天开始，小红帽开始了学习前端的道路（假装从头开始）。开始第一天，定个小目标，理清 HTML 是一门怎么样的东西。知道他里面有什么玩意，在自己整一个 「Hello World ！」的 HTML 文本出来先。 1 HTML 是啥？老套路，学啥东西先看看人家是啥玩意，这里的话。HTML 全称 HyperText Markup Language，翻译成中文是「超文本标记语言」。看翻译就知道，他并不是一门编程语言，而是一种标记语言，一种告知浏览器如何组织页面的标记语言。 啥玩意，你可以理解这玩意是一个文本，然后咧，我们在这里文本外面套层皮下去，做点小标记，来告诉浏览器去渲染解析他的时候，知道这个标记的渲染出来是一个标题，那个文本渲染出来的是一个加粗的文本。眼熟不，像不像大学期末考在书上画重点，做满了标记，你像浏览器一样，一翻书，看到这些标记的文本，就知道「哦，这玩意是重点，搞出来的要不一样」 现在我们整一个 HTML 文件出来，开始我们对 HTML 的摸索。我们先右键新建一个文本文档，然后吧他的后缀名 .txt 改为 .html（不知道改后缀名自个百度去），然后用 notepad++ 打开进行编辑。下面所展示的代码均在我们现在创建的 HTML 文件中编写。开始我们对 HTML 的摸索之旅吧。 这边一开始，大家就先老老实实用个 notepad++ 或者直接记事本来写代码啦，就不要用啥子 IDE，有点杀鸡用牛刀的感觉。此外大家刚开始学，不要偷懒，认真打好每一串代码，不要用 IDE 偷懒。这样对刚开始的学习才好。等到你学入门知识的时候就可以用那些 IDE 去帮你偷懒啦。当然现在你要用也随你。建议用 VSCode 等这种轻量级的 IDE，Webstorm 这种就算了，好用！但是是真的浪费，且那玩意真的很吃内存。 2 剖析 HTML 元素2.1 元素组成要素HTML 是由一个个 HTML 元素组成的，那么我们看看一个 HTML 元素是怎么样的。我们就拿一个段落元素为例吧。 1&lt;p&gt;我是一个段落&lt;/p&gt; 这上面这个元素主要有下面几个部分 开始标签（Opening tag） 他由一个小于号 &lt; 和一个大于号 &gt;，包裹这一个元素名称（本例为 p）组成。本例中 &lt;p&gt; 就是我们的开始标签。他告诉浏览器「兄弟，注意啦，从这开始这是一个段落，你要按照段落的样子渲染」 结束标签（Closing tag） 与开始标签一样，只是在其元素名前面加了一个斜杠，表示元素的结尾。也就是本例中的 &lt;/p&gt;。他就告诉浏览器「大兄弟，段落渲染在这边就可以啦。后面的咋渲染就不关我的事情啦」 内容（Content） 元素的内容啊，就是被标签包裹住的东西。这边的话就是中间的那段文本。但他也可以是另外一个元素，这个是可以层层嵌套的。 元素（Element） 上面的东西凑起来就是一个元素啦。 当然不一定每个元素都是有这些构成要素的，例如我们的 空元素 就只有标签举例的话就是我们的图片标签 img 了，如下：1&lt;img src=&quot;xxx.jpg&quot;&gt; 他整个元素就这么一点东西。就只有一个标签。 2.2 元素属性元素也有着属性的，属性里面包含元素的额外信息，这些信息不会显示在实际的内容中。我们看下面的代码。写法也简单，就是在开始标签里面加 属性名=“属性值” 的这种写法，就是要注意互相之间要有个空格，不然就不知道会出现什么奇怪的情况了。1&lt;p class=&quot;desc&quot; id=“de2”&gt;描述&lt;/p&gt; 这上面 p 元素有两个属性，分别是 id 和 class。其中 class 的属性，值为 desc，在页面中我们是看不到这些东西，这个 class 属性一般是用来识别此元素的样式信息或者也可以用于识别元素等作用。 元素的属性太多了，这边就不想一一说了，到时候用多了就知道了。 3 创建一个完整的 HTML 文件学习了一些 HTML 元素的基础知识，但是这些元素单独是没有意义的。HTML 是有自己的一套规则的。我们就看一下一个完整的 HTML 文件是怎么样的。我们再搞一个 HTML 文件，然后把下面的代码放到里面去。12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 看起来一堆代码，其实我们用浏览器打开他的话就只有一句 Hello World! 显示在我们的页面上。为啥子咧。我们分析一下他的组成你就知道为啥了。 1 &lt;!DOCTYPE html&gt; 声明文档类型。他的作用就是告诉我们的语言解析器，也就是我们的浏览器要用什么样的文档类型定义来解析下面的文档。之前声明这个的时候贼多东西，现在你知道直接第一行加 &lt;!DOCTYPE html&gt; 这个就行啦。 2 &lt;html&gt;&lt;/html&gt; html 元素。这个元素包裹了整个完整的页面，是一个根元素，前期基本不用去理他。后面用到的时候再说。 3 &lt;head&gt;&lt;/head&gt; 头元素。这个元素是一个容器，它包含了所有你想包含在HTML页面中但不想在HTML页面中显示的内容。这些内容包括你想在搜索结果中出现的关键字和页面描述，CSS样式，字符集声明等等。这块内容很重要，所以我们在在下一篇文章里面去介绍他。 4 &lt;body&gt;&lt;/body&gt; body 元素。包含了你访问页面时所有显示在页面上的内容，文本，图片，音频，游戏等等。反正你在页面上看到的东西全在这里面就对啦。 所有 HTML 都应该要有上面的那些东西，我们要搞事的地方基本就在 body 元素里面。现在你可以尝试自己搞一个 HTML 文件，搞点事情。例如一级标题的元素名是 h1,段落的元素名是 p。先拿这两个元素去玩一下。或者自己再去找找其他元素玩玩。 4 写在最后重学之后发现其实自己还是不懂这些基础的东西，因为发现自己会用但是不知道如何说出来。果然还是一个小辣鸡。这边的话，如果大家想学前端的话可以去 MDN 找教程好好看，如果觉得看文字教程觉得有点难消化的，可以我公众号那边回复「前端」，就会有一些前端的视频教程，大家可以结合着来学习。咋说咧，自己当初学前端的时候没有踏实学好，现在我真的是一个以一个初学者的态势来学习了，如果有啥不懂或者我哪边理解错了，欢迎留言指正，大家一起学习进步啦。]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小红帽学前端教程（0） 开头瞎BB]]></title>
    <url>%2F2019%2F08%2F17%2Fcxqd-0-bb%2F</url>
    <content type="text"><![CDATA[大家好，我是小红帽，一个前端小辣鸡。为了能够更好学习整理自己所学的前端知识，所以我打算不要脸的写一个初级前端学习的系列文章，同时也算作为一个分享和交流吧。至于为啥是初级前端学习咧，我想说 我也想写个中高级前端的进阶教程啊，奈何我只是一个小辣鸡，写不了哇。 1 What学习一个东西前，我们先解决一个「what」的问题，啥是前端咧？前端开发是干啥的？ 简单粗暴来讲，前端就是所有呈现在用户面前与用户进行交互的东西，一个电脑网页，一个手机 APP 界面，一个游戏的界面等等等。差不多的意思就是你所看到的东西就是互联网的前端。 要是原始一点讲，就是一个写网页的切图仔就对了。当然现在时代不一样了，前端不在是之前那个写网页的切图仔了，这点你到后面就会发现了。不过我们基础还是和之前一样，是 HTML（结构），CSS（表现），JavaScript（行为）这三样技术。 那么这三个东西是啥啊？我们拿人作为例子。 1.1 HTML首先是 HTML（超文本标记语言），HTML 是一个页面的基本结构，定下了整个页面的页面骨架。就类似我们人的骨架吧，如下图 1.2 CSS其次是 CSS（层叠样式表），如其名，样式表。加样式的变好看的。 我们前面只有这么一个骨架太吓人了，我们要我们的人（页面）好看一点，咋办，当然是用我们的 CSS 啦，它的话就是用来给 HTML 添加一层样式，进行美化的。我们用 CSS 给他一身好看的皮囊啦，当然根据不同产品的审美需求，我们可以有各种「好看的」皮囊。 有这样的 当然还有这样的 1.3 JavaScript最后就是我们的 JavaScript 了，JS 是行为层，最简单的说法就是给予网页动态交互的行为。 就像我们人一样，长的再好，穿的再好看，结果是个植物人，那其他人咋想会跟你打交道咧，所以就要加点动作啦。这样更富有层次感。你看下面帅如发哥，动态图看起来是不是比静态的，更帅更富有层次咧。 这三个就是前端三剑客的，也就是我们前端开发要学的东西。后面我们学啥框架，啥新技术啊，搞来搞去都是这三个家伙。 2 Why为啥要学前端咧，这个问题很重要，因为这是一条不归路，没有一个可以说服自己的理由，要想坚持下去还是有点难度的。在此给大家准备了几个理（jie）由（kou） 我喜欢开发，并且前端开发是一种看得着摸得到的开发，你写啥电脑就给你搞出个啥效果，很有趣。 前端开发也是软件开发，以后工作时候的工资还是很诱人的。 前端开发简单易上手。内心OS：算是个理由吧，前端入门的确很简单，但是学到后面你肯定会对我说「我信你个鬼！你个糟老头子坏得很！」 没有理由，劳资就是要学，爱咋咋地。 3 How3.1 概述这个就是我们本次系列文章的中心了，我们要这么去学前端呢。我们前面看到前端开发主要就是用 HTML + CSS + JS。所以我们的前端学习也是围绕这三个东西进行的。这边的话，我自己瞎分了三个部分：基础知识，入门知识，初级知识。其中基础知识必须是要先学好的，入门知识和初级知识也建议耐着性子逐步来，当然你交叉来学问题也不大。 然后前端开发嘛，也是编程，学编程，就一点，多敲代码！甭管啥知识，代码敲多了，很多前面不懂的后面敲敲就懂了。切忌只看不敲啊。咱这毕竟是偏应用的学科。大佬请忽视这一段 3.2 基础知识这一块也可以叫做基础常识吧，因为我们要学的就是最最基本的 HTML + CSS 的基础知识，知道这两个家伙怎么用，怎么去写出一个网页来，怎么去布局一个网页，写出一个带样式的网页来。最后还要知道 JavaScript 这门语言最最基本的语法操作，和用 JavaScript 进行简单的 DOM 操作。 这一块知识的话，学到后面，知道这些东西这么用，能写几个简单的页面就算了。（例如一个简单的登陆框页面）也不要求你看到一个网页你就能自己把他实现出来，虽然这个是可以的，但是过程会比较痛苦。就不要磨灭你的信心啦。但是还是要好好学习这一段的知识，不然你后面你还得回来学！想想就知道啦。你站都站不稳，还想学跑步？ 3.3 入门前端知识这一块的话，就要学一下新的 HTML5、CSS3 的知识,了解他们的新特性，最好的话找本专门介绍 JavaScript 的书或者教程系统的学一下 JS。再学一下 JQuery 的用法，经历过前面刀耕火种的开发，你会发现 JQ 的出现是多么神圣的一件事情（当然后面你就不会这么觉得了）。除却这些基本的知识，你也可以开始偷懒去了解一下如 bootstrap 的 UI 框架和其他的一些 JQ 插件来协助你开发了。 经历了这一阶段的学习，如果学的好的话，那么恭喜你已经入门前端了，现在的你应该可以达到别人丢给你一个页面，你可以自己手撸或者利用其他工具偷懒去实现那个网页出来的水平啦。 3.4 初级前端知识这一块的话，咱们首先学一下 ES6 的新特性，建议买本阮一峰老师的《ES6标准入门》来看。然后就可以学习前端三大框架了，这边的话我学的是 Vue，因为简单易上手，文档齐全，国内生态完善。当然你要学其他也是可以，不过个人感觉 react 和 Vue 后面是主流技能，Angular 在国内感觉比较小众，并且听说学习成本比较大，所以暂时不推荐大家作为第一学习的前端开发框架。 除却学框架，我们还要了解一点后台的知识，这样我们也好跟后台的同事打交道。这边就会让大家简单了解一下 Node 的一点基础知识，不需要了解太多，知道个意思就差不多了，了解一个完整的项目是怎么运作的。并且其实你前面 JS 学好了，其实 Node 还是挺容易上手的。在这个学习的过程顺带了解一点计算机网络的知识和浏览器的一些知识咯。现在粗略学习，后面提升的时候就要认真学学咯。 此外，以后的开发我们不是自己一个人玩玩就可以的了，所以我们必须要学会一点 Git 操作，使用 Git 进行版本迭代和团队协作开发。顺便了解一下全球最大的同性交友网站 GitHub 这部分的知识个人感觉就是由个人的学习转向真正的项目开发的过程，学完这些，至少你自己能手把手搭建一个完整的前端项目（能和后台交互的那种哦），然后对于前端开发的工程化，你自己应该也要有自己的一份心得。简单来说就是你现在已经是个初级的前端开发工程师了，你知道一个完整的项目开发是怎么一回事，也知道自己在一个项目开发中该干啥，该怎么干了。 看起来好像这部分知识很复杂，其实上手也贼快的，基本你自己手撸一个项目，这块知识你基本就有一个感觉在了。感觉有了，学起来就快了。也不会那么迷茫了。 下面的话，我自个简单粗暴的搞了一张思维导图，比较简单，因为太复杂的我也懒得画，并且还容易摧残我们小辣鸡的自信心。就随便搞搞咯.我前面也写了，这是一个初级前端的教程，这里面的知识体系虽然不是一个完整的前端知识体系，但建立起这样的知识体系的时候你就差不多是个初级前端工程师了，后面的知识点就自个再去完善和补充了。如果自己想在这边的基础上修改成自己的知识体系的话，可以到百度脑图这边修改然后保存到你本地那边。 写到最后看到最后，是不是发现我好像也没写啥玩意，这就对了。前端入门的话，感觉还真的没啥也没那么复杂。要学前端的话，不要怕，代码敲多了，入门很简单的，就是后面提升的时候头有点凉而已。 后面的教程的话，我大概就是根据思维导图上的点来进行学习分享咯。要是觉得我这样的学法或者是本文的看法有啥问题的话，欢迎留言指正，大家一起学习交流，一起秃头，呸，一起加油。]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化使用 Vuex]]></title>
    <url>%2F2019%2F07%2F30%2Fmodule-use-vuex%2F</url>
    <content type="text"><![CDATA[前言 上回我们说了一下 vuex 的简单使用，最后面的时候有说了，由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割，今天我们也来简单了解一下他的使用，深入学习可能还是要去看官方文档 1 文件结构文件结构的话，模块化的使用要多一个 modules 的文件夹，里面放着细分模块的 js 文件/模块名文件夹。 这里官方的标准是一个模块一个 js 文件，但是要是模块太复杂的话，也可以把里面的代码拆分出来。1234567891011121314// store 文件夹 │ actions.js│ getters.js│ index.js│ mutations.js│ state.js│└─modules │ moduleB.js │ └─moduleA index.js mutation.js state.js 然后在创建 store 的 js 文件中引入这些模块，直接12345678910111213import moduleA from './modules/moduleA/index'import moduleB from './modules/moduleB';export default new Vuex.Store(&#123; state, getters, mutations, actions, modules: &#123; moduleA, moduleB, &#125;&#125;); 2 模块的局部状态对象的定义模块内部的 getter，mutation 和 action，他们方法接收的参数会和根状态的不一样，我们一个一个来 getter getter 的话，他会有三个参数，第一个是模块内的 state，第二个是 模块内的 getters，第三个是根节点状态 rootState， 123const getters = &#123; bFullName: (state, getters, rootState) =&gt; `full$&#123;state.bName&#125;`&#125; mutation mutation 里面的回调函数传入的第一个参数也是 模块内的 state，其他和根状态定义的时候一样 1234567const mutations = &#123; // 这里的 `state` 对象是模块的局部状态 SET_B_NAME(state, payload) &#123; debugger state.bName = payload.name; &#125;&#125; action 最后的 action 的话，他传入还是只有 context 对象，然后咧，这个对象里面的 state 属性指模块内的状态，rootState 指根状态，如下1234567const actions = &#123; ASYNC_SET_NAME(&#123; state, commit, rootState &#125;, payload) &#123; setTimeout(() =&gt; &#123; state.bName = 'asyncName' &#125;, 4000) &#125;&#125; 3 使用3.1 state 获取这个的话要在原来状态名前面加一个模块名才能放到到模块内的对象。具体如下123456// 原先的基础上加个模块名this.$store.state.moduleB.bName;// 辅助函数也一样，name 前面加个模块名 Deno...mapState(&#123; name: state =&gt; state.moduleB.bName,&#125;) 3.3 命名空间getter，mutation，action 他们默认都是注册在全局命名空间的，所以我们默认是可以和使用根状态一样去使用他们，但是这样不可避免会出现命名冲突的问题，所以使模块有更高的封装性与复用性，我们可以通过添加 namespaced: true 使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。12345678// moduleB 模块导出的时候加个 namespaced: true,export default &#123; namespaced: true, state, getters, mutations, actions,&#125; 3.3.1 辅助函数的使用因为有了命名空间这么一层封装，所以我们在用辅助函数的时候都要多加那么一层模块名，具体看下面代码。 12345678910111213141516171819202122// getterthis.$store.getters['moduleB/bFullName']; ...mapGetters(&#123; bGetter2: 'moduleB/bFullName'&#125;)// mutation this.$store.commit('moduleB/SET_B_NAME', &#123; name: 'QQ'&#125;);...mapMutations(&#123; setBname: 'moduleB/SET_B_NAME'&#125;),// actionthis.$store.dispatch('moduleB/ASYNC_SET_NAME', &#123; name: "JJ" &#125;);...mapActions(&#123; aSetAge: 'moduleB/ASYNC_SET_NAME',&#125;), 每次都要写模块名，这样写下来很烦，所以这些辅助函数给我们提供了一个参数位来绑定命名空间。 123456789// moduleB 模块内的 bName...mapState('moduleB', &#123; name: state =&gt; state.bName&#125;)// 同理 mapAction mapMutation 也可以这个样子...mapAction('moduleB',[ '/ASYNC_SET_NAME']) 除了这个之外，如果你当前组件用的 vuex 状态都是一个模块的话，我们可以使用 createNamespacedHelpers 创建基于某个命名空间辅助函数，如下：123import &#123; createNamespacedHelpers &#125; from 'vuex'const &#123; mapState, mapActions &#125; = createNamespacedHelpers('moduleB') // moduleName 这样创建之后，我们就可以用之前的写法来访问到模块的状态。 123...mapState(&#123; bName: state =&gt; state.bName,&#125;), 3.3.2 在带命名空间的模块内访问全局内容如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。 若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。具体看下面代码： 12345678910111213141516171819202122232425262728293031modules: &#123; foo: &#123; namespaced: true, getters: &#123; // 在这个模块的 getter 中，`getters` 被局部化了 // 你可以使用 getter 的第四个参数来调用 `rootGetters` someGetter (state, getters, rootState, rootGetters) &#123; getters.someOtherGetter // -&gt; 'foo/someOtherGetter 模块内的 getter' rootGetters.someOtherGetter // -&gt; 'someOtherGetter 全局的getter' &#125;, someOtherGetter: state =&gt; &#123; ... &#125; &#125;, actions: &#123; // 在这个模块中， dispatch 和 commit 也被局部化了 // 他们可以接受 `root` 属性以访问根 dispatch 或 commit someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123; getters.someGetter // -&gt; 'foo/someGetter' rootGetters.someGetter // -&gt; 'someGetter' dispatch('someOtherAction') // -&gt; 'foo/someOtherAction' 模块内的 action dispatch('someOtherAction', null, &#123; root: true &#125;) // -&gt;'someOtherAction' 全局的 action commit('someMutation') // -&gt; 'foo/someMutation' 模块内的 action commit('someMutation', null, &#123; root: true &#125;) // -&gt; 'someMutation' 全局 mutation &#125;, someOtherAction (ctx, payload) &#123; ... &#125; &#125; &#125;&#125; 3.3.3 将模块内的 action 注册为全局这个感觉和维护模块的封装性有点冲突，但是既然作者提出来了，那就学吧，当我们想要我们模块内的某个 action 提升为全局 action 的时候，在他声明的时候，添加 root: true，并将 action 的定义放到 hanler 函数中，具体如下： 123456789101112131415161718const actions = &#123; // 模块内 action [ASET_AGE](&#123; commit &#125;, payload) &#123; setTimeout(() =&gt; &#123; commit('SET_B_NAME', payload.name); &#125;, 2000) &#125;, // 提升到全局的 action globalAction: &#123; root: true, handler(&#123; commit &#125;, payload) &#123; debugger setTimeout(() =&gt; &#123; commit('SET_B_NAME', payload.name); &#125;, 2000) &#125; &#125;&#125; 关于模块使用 Vuex 的介绍就说到这里了，这两篇笔记的项目源码我发到了 GitHub 上面，大家可以去看一下，要是项目中有啥不明白的或者我说的有问题的，欢迎大家留言指正。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
        <tag>项目经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex 基础使用]]></title>
    <url>%2F2019%2F07%2F27%2Fuse-vuex%2F</url>
    <content type="text"><![CDATA[前言 vuex 是 vue 官方出的一个全局的状态管理模式，可以理解为一个 vuex 项目的全局变量吧，再构建大型项目的时候，我们可能会需要用到它。下面就来学一下怎么去使用它吧（本文偏向于具体使用，如要深入学习，请看官方文档）。 1 安装我们要用啥就要先装啥，直接 npm install 就行了1npm install vuex 2 文件结构vuex 的也是 vue 项目中的一个模块，使用我们一般会用一个 store 文件夹去存放属于 vuex 的文件。他一般是有下面这些模块 2.1 state.js这个的里面就放着 vuex 的 state 数据，个人理解这个就是一个一个全局变量库。123456let state = &#123; dept: 'TT', num: 'S0171',&#125;export default state; 2.2 getters.js除了我们默认的 state 状态之外，还会有一些类似组件中的计算属性的派生的状态，他定义的时候和定义计算属性是一样的，但是要传入一个 state 作为参数。12345// 使用箭头函数，简洁好看let getters = &#123; deptNo: state =&gt; state.dept + state.num&#125;export default getters; 2.3 mutations.js更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数,然后还可以传入一个额外的参数，即载荷（payload），我们一般可以使用这个 payload 传入一些修改时需要的参数。 此外 vuex 官方是推荐用常量作为事件类型，使用我们一般也就按照推荐的来咯，当项目足够大的时候，我们还会搞多一个 mutation-type.js 文件来存放这些事件类型，但是现在我们就先把他们都写一起了。1234567891011// 事件类型const SET_DEPT = &apos;SET_DEPT&apos;const mutation = &#123; // 回调函数，就处理 state 的方法啦 [SET_DEPT](state, payload) &#123; state.dept = payload.dept; &#125;&#125;export default mutation; 2.4 actions.js由于 mutation 里面不支持异步操作，所以当我们需要在 vuex 里面执行异步操作的时候,就要用到 action 了，不过要注意 action 只是提供异步操作的机会，但是如果要修改 state 的数据的时候，还是要用到 mutation 里面的同步事件。 他的声明方式和 action 是差不多的123456789const ASET_DEPT = 'ASET_DEPT'const actions = &#123; [ASET_DEPT](context,payload)&#123; setTimeout(()=&gt;&#123; context.commit('SET_DEPT',payload.dept); &#125;,2000) &#125;,&#125;export default actions; 2.5 index.js这个就直接 vuex 的入口文件了，在这边要创建 store 实例，并将其导出,我们就要把我们之前搞的所有都丢到这里面来，然后创建一个 store 实例。12345678910111213141516import Vuex from 'vuex';import Vue from 'vue';import state from './state'import getters from './getters'import mutations from './mutations'import actions from './actions'Vue.use(Vuex);export default new Vuex.Store(&#123; state, getters, mutations, actions,&#125;); 最后我们只要在创建 vue 的实例的 main.js 文件里面导入 store 模块，并在初始化 vue 实例的时候引进去就成功搭建了一个全局的状态仓库了。 3 使用前面我们说了这么去搭这个仓库，现在我们已经搭好了，就要知道这么去使用这个仓库的数据。 3.1 state 数据的获取这个由于我们是在根 vue 实例就引入了 store，然后我们一般是在计算属性中去拿取 vuex 的状态12345computed :&#123; dept()&#123; this.$store.state.dept &#125;&#125; 为了减少我们的工作量，vuex 还给我们贴心准备了辅助函数 mapState12// 引入import &#123; mapState &#125; from "vuex"; 12345678910computed: &#123; ...mapState(&#123; name: state =&gt; state.Deno.name, dept: state =&gt; state.dept, &#125;) // 当 computed 里面的计算属性的名称和 state 里面名称一样时，还可以这么写 ...mapState([ 'name','dept' ]) &#125;, 3.2 getter 的获取这个和 state 差不多，直接发代码了12345computed: &#123; deptNo() &#123; return this.$store.getters.deptNo; &#125;,&#125; 然后他也有一个辅助函数 mapGetters。用法就123456789computed: &#123; ...mapGetters(&#123; deptNo: 'deptNo', &#125;) // 当 computed 里面的计算属性的名称和 state 里面名称一样时，还可以这么写 ...mapState([ 'deptNo' ]) &#125;, 3.3 mutation 的使用mutation 是事件，也就是方法啦，所以我们用方法的形式去使用它。我们可以直接使用123this.$store.commit('SET_DEPT', &#123; dept: 'QQ'&#125;) 也可以用辅助函数 mapMutations 映射为本地方法1234...mapMutations(["SET_DEPT"]),...mapMutations(&#123; setDept: "SET_DEPT"&#125;), 然后直接调用12this.SET_DEPT('QQ');this.setDept('QQ'); 3.4 action 的使用action 也是方法啦，所以他的使用和 mutation 是差不多的。1this.$store.dispatch('ASET_DEPT',&#123;dept:'QQ'&#125;) 它的辅助函数是 mapActions，用它映射为本地方法。123456...mapActions(&#123; aSetDept: 'ASET_DEPT',&#125;),...mapActions([ 'ASET_DEPT']) 关于 vuex 的简单使用就说明到这边了，但是由于有时候我们的项目是非常大，使用单一的一个 state 来存数据可能会导致数据太多，太杂，所以 vuex 还有一个 module 的机制，大家可以去官网看文档或者看我的下一篇文章。文章就写到这里啦，如果大家发现我哪边写错的话，还望指出勘误，期待与大家一起学习进步。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node 项目调试]]></title>
    <url>%2F2019%2F07%2F02%2Fnode-debug%2F</url>
    <content type="text"><![CDATA[前言 作为一个程序员，感觉我们其实打代码的时间不多，大部分时间都在在调试上，所以如何调高我们调试的效率，这就成了我们的一个大问题了，经过在网上的搜索与自己的探索，就推荐这两种好用的 Node 调试方法吧 1 Chrome 调试因为 V8 检查器集成允许使用 Chrome 调试协议将 Chrome DevTools 附加到 Node.js 实例以进行调试。所以我们可以直接用 Chrome 进行调试。这个就最简单的的方法，直接在运行代码的地方加个前缀 --inspect，如下：1node --inspect /bin/www 这个时候我们在控制台会看到多出这么几个提示123Debugger listening on ws://127.0.0.1:9229/f54d4cb8-56bc-46c4-9b8e-fd7f2163c73cFor help, see: https://nodejs.org/en/docs/inspectorDebugger attached. 看到这个我们打开 Chrome，f12 打开控制台，点击上面的 Node 图标 我们就可以打开一个新的调试 Node 的浏览器窗口，我们在代码中打的 debugger 和 console.log 都会在那个窗口显示和输出出来。 2 VS Code 大法在 VS Code 中调试步骤也是比较简单，1、 点击蜘蛛图标，打开调试控制台 2、选择一下调试环境 这里我们就直接选 Node的了的啦 3、配置调试模式我们选择好环境之后，他会弹出一个 launch.json 的配置文件，这里面我们可以 VS Code 有很多调试模式，我们可以通过 add configurations 添加调试模式。等到我们要调试的时候就在 debug 菜单那边选模式，然后点击绿色三角开始调试。下面我们着重介绍一下几个常见的模式吧 2.1 VS Code Node 调试模式2.1.1 attach 模式这个先拉出来说，因为后面几个模式都是通过 VS Code 启动项目的，而这个模式是你项目已经启动的情况下启用的，并且那项目还是开启了 Chrome 调试的123456789101112// launch.json// port 填 Chrome 调试的端口地址，一般都是 9229&quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;attach&quot;, &quot;name&quot;: &quot;Attach to Port&quot;, &quot;address&quot;: &quot;localhost&quot;, &quot;port&quot;: 9229 &#125;, ...] 2.1.2 node 模式这个其实一开始的时候生成的配置就是 node 启动形式，代码如下1234567891011// launch.json&quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Program&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/bin/www&quot; &#125;, ...] 选择后模式之后，我们点击调试控制台的绿三角就可以启动调试了。 2.1.3 nodemon 模式我们调试的时候肯定要修修改改，如果只是用 node 启动的话，我们每次修改后都要重新启动项目，这样是很费时间的，所以我们可以借助一些依赖来实现 node 项目的热重载，比如这个 nodemon， 然后 VS Code 也有这么一个对应的模式。 不过要注意，想用调用这个调试模式，你电脑必须全局 安装 nodemon，否跑不起来。123456789101112131415// launch.json&quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;nodemon&quot;, &quot;runtimeExecutable&quot;: &quot;nodemon&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/bin/www&quot;, &quot;restart&quot;: true, &quot;console&quot;: &quot;integratedTerminal&quot;, &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot; &#125;, ...] 和上面一样这个也是在 VS Code 里面启动调试的。 大概就是这些吧，当然 Node 调试还有很多方式，这些就看大家喜欢然后自己去摸索了。最后唠叨一句，debug 是个好东西，大家要用好他。]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>Node debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 Python 开发环境]]></title>
    <url>%2F2019%2F06%2F19%2Fpython-envi%2F</url>
    <content type="text"><![CDATA[1 下载安装包Python 的话有很多个版本，我们自己学习的话就用用的比较多的 Python 3.5 的版本，官网 3.5 版本已经没有安装包了，只有源代码了，所以大家就到我百度网盘去下载 3.5 的版本。 链接：https://pan.baidu.com/s/1s-dRnouVI_eojPKnJYDAoQ 提取码：8kgy 2 安装配置不得不说，Python 用起来方便，安装配置也是相当方便，我们直接打开安装包，勾选下面的“Add Python 3.5 to PATH”，如下图。 接着我们可以选择默认的直接安装到系统盘，或者点击那个“Customize installation”自定义安装目录再直接安装，安装好了就可以直接使用 Python 开发了。 3 检测安装完环境，老规矩，检查一下成功没。我们打开控制台输入1python -v 如果和下面一样出现 Python 的版本号就代表我们已经成功搭建好 Python 的开发环境了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>搭建环境</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 Node 开发环境]]></title>
    <url>%2F2019%2F06%2F19%2Fnode-envi%2F</url>
    <content type="text"><![CDATA[1 下载安装包两种方式，官网下载最新 LTS 版本的或者到提取我的网盘文件（当前版本是 10.16.0） 链接：https://pan.baidu.com/s/1Ztsq550dPimkUAXsDyEoPA 提取码：pb2w 2 安装跟安装普通软件一样安装，到了下面这一步的时候，可以自己选择安装的位置 然后一路安装就可以了。 3 检测往控制台中分别输入1node -v, npm -v 出现下面的结果的话，接表示我们已经可以使用 node 开发了。 4 修改全局 npm 包的位置虽然做完上面的事情我们就已经可以开发了，但是它默认的全局 npm 包是放在系统盘的，要是我们以后安装太多全局 npm 包的话，会占系统盘很大空间的，这种情况肯定不好啦。所以我们要修改我们全局 npm 包的位置。（如果你系统盘留着非常多的空间的话那就随意了） 这个其实很简单，npm 自己可以设置，我们只要在控制台运行下面的脚本就可以修改全局 npm 包的位置了12npm config set prefix &quot;D:\nodejs\npm_global&quot;npm config set cache &quot;D:\nodejs\npm_cache&quot; 修改之后运行 1npm config ls 查看配置 这样就差不多了。 然后我尝试全局安装一下 vue-cli 脚手架， 1npm install vue-cli -g 安装过后，我们到 npm_global 目录下的 node_modules 看一下，已经安装成功，事实上这就是全局包的安装路径 我们尝试在控制台运行一下 vue-cli 1vue inti webpack demo 但是会发现会报错，这是因为我们修改了路径，但是还没配环境变量，所以我们就需要打开环境变量配置。 首先新建一个 NODE_PATH,变量值为设置的安装路径下的 node_modules 文件夹 然后往 path 变量中添加一个值（值为全局安装路径的地址），如下图 然后我们就可以愉快的去使用全局 npm 包啦。 5 安装 cnpm由于 npm 的站点在国外，有时候网络不好安装依赖需要很久，这个时候我们可以使用淘宝的 cnpm 镜像来安装项目依赖。首先我们运行下面的指令安装 cnpm。 1npm install -g cnpm --registry=https://registry.npm.taobao.org 然后我们输入1cnpm -v 来查看 cnpm 的版本，顺便确定是否成功安装了 cnpm ,如果能看到了 cnpm 的版本号，那就说明安装成功了，我们就可以使用 cnpm install 来替代 npm install 安装项目依赖了。 友情提示:我们最好还是用 npm 去安装项目依赖，但是要是网络不好用 npm 装依赖久到怀疑人生的时候就用 cnpm 去安装项目依赖。 至此，我们 node 的环境也配置完成了，后面就可以进一步的去学习和使用了。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>搭建环境</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 Java 开发环境]]></title>
    <url>%2F2019%2F06%2F19%2Fjava-envi%2F</url>
    <content type="text"><![CDATA[1 下载安装包这个的话直接去 Java 官网 下载就行，或者到我的百度网盘 链接：https://pan.baidu.com/s/19F0w9wWkbQMGdBk5bf4dBw 提取码：425p 下载下来。 2 安装安装真的没啥好说的，就和我们装个 QQ 微信那样，直接一直点击下一步，一直到安装就行了。 推荐是一直默认安装，但是如果有些小伙伴不想装到默认的 C 盘的话，可以在下面这个步骤的时候点击更改，改到你想安装的地方，就是要记得你安装到哪个位置，下面配环境的时候需要用到。 我们一开始是安装的是 jdk，后面装到一半会弹出下面这个安装 jre 的窗口。 如果你上面安装的时候是一直默认装的话，这个也默认就行，否则这边也要更改安装路径到前面的 jdk 的同级目录，如下所示 3 配置系统变量安装完 Java 后，我们要配置环境变量后才能开始开发。下面就安装步骤来了。 右键点击计算机进入“属性-&gt; 高级系统设置-&gt;高级-&gt;环境变量”，如下图所示 新建变量名“JAVA_HOME”，变量值 “D:\Java\jdk1.8.0_152”的环境变量。 编辑 Path 变量的值，在原来的值后面加“;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin”注意 在 win10 那边的话要像下面这样添加。 新建变量名“CLASSPATH”，变量值“.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”的环境变量。 这样我们就配好了环境变量。 4 检测配置完后，我们检查一下是否还有问题，我们打开控制台分别输入1java, javac, java -version 如果出现下面所示的提示信息，那就没啥问题了，如果出问题的话，去看环境变量那边是不是搞错了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>搭建环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 python 群发新年祝福]]></title>
    <url>%2F2019%2F01%2F31%2Fwechat-wish%2F</url>
    <content type="text"><![CDATA[快过年啦，又到了团圆的日子，在这个普天同庆的日子里面，相信很多人和我一样会碰到一年问题 – 拜年（手动捂脸）。 大过年的，大家都会发个微信拜年联络联络感情，炸一炸万年不见的老朋友。但是问题就来了，如果是用微信的群发助手群发的话，感觉有点审美疲劳或者说感觉有点没诚意（总之感觉不舒服就对了），但是如果说你要有诚意，一个一个人写名字，一个一个发的话，我觉得你手指会残的。之前我干过两次，其中我中途休息两回，发完之后手指基本快废了。 后来发觉我是一个 IT 男，应该想个办法解决这种重复性的操作，拯救我那双一年被摧残一次的双手，于是乎，经过一番学习，用现在比较火的 Python 解决了我这个问题。下面就和大家聊聊怎么操作吧。 1 所需资料 python 安装程序 有相关代码的 python 文件 这些材料我都放在下面的云盘中了 链接：https://pan.baidu.com/s/1zt11zzmJUCA8pTijg1mv1w 提取码：m6oh 2 配置 Python既然用 Python，肯定要装一下 Python 的环境啦。 到 Python 的官网,下载 3.5 版本的 Python 或者到我百度云那个搞咯。 下载完后就直接打开安装 注 请选中 把 Python 添加到环境变量，这样以后在windows命令提示符下面也可以运行Python 下面这些除了修改一下安装路径外，其他默认就好（下图的情况我忘记截图了，从网上找了张图片） 3 敲代码如果想直接用的小伙伴这一步就不用看了，直接拿网盘的 wish.py 文件，按照下面的第 4 步去运行。 后面的操作，喜欢玩 Python 或者学过的同学可以用 Pycharm 或者其他 IDE 去运行。我这边的话就直接用最原始的方法咯。 首先新建一个 txt 文件，修改它的后缀名为 .py 变成一个 Python 文件咯，用记事本或者 NotePad++ 直接打开，复制下面的代码进去，我在代码里面写了一点注释，要看哦12345678910111213141516171819202122232425262728293031323334353637383940414243#coding=utf8import itchat, time, random# SINCERE_WISH = u'祝%s新年快乐！'# REAL_SINCERE_WISH = u'祝%s新年快乐！！'# 祝福语数组 %s 后面替换为好友昵称或者好友备注wishList = [ u'祝%s新年快乐！', u'%s，祝你新年快乐！', u'%s，新年快乐！',]# 群发所有好友def send_wishes(): friendList = itchat.get_friends(update=True)[1:] for friend in friendList: # 如果不是演示目的，把下面的print方法改为itchat.send即可 print(random.choice(wishList) % (friend['RemarkName']), friend['UserName']) time.sleep(.5)# 群发指定群（该群要保存到通讯录）的好友def send_special_wishes(chatroomName='微信群名'): itchat.get_chatrooms(update=True) chatrooms = itchat.search_chatrooms(name=chatroomName) if chatrooms is None: print(u'没有找到群聊：' + chatroomName) else: chatroom = itchat.update_chatroom(chatrooms[0]['UserName']) for friend in chatroom['MemberList']: friend = itchat.search_friends(userName=friend['UserName']) # 如果不是演示目的，把下面的print方法改为itchat.send即可 # RemarkName 你对好友的备注 NickName 好友自己的昵称 print(random.choice(wishList) % (friend['RemarkName']), friend['UserName']) time.sleep(.5)itchat.auto_login(True)# 要一次性群发给所有好友，把下面的注释去掉（删除 # 号）# send_wishes()# 要群发给指定群（已保存到通讯录的群）的好友，把下面的注释去掉（删除 # 号）send_special_wishes() 4 运行按住 shift 键右键，选择「在此处打开 powershell（或者 cmd）」，输入下面命令安装 itchat 包 1pip install itchat 等待它安装后，输入下面的指令运行代码（假设我那个 python 文件是 wish.py）1python wish.py 运行之后会弹出一个二维码，那个是用于登录网页版微信的，扫码确认登录 登录之后，代码就会自动跑起来了，为了防止翻车，或者忘记给好友的迷之备注，我在发之前先在本地测试一下，用 print 方法打印出要发送的信息，看看好会不会出啥问题。 先在我这边的话是选择了发送给「微信群名」这个群的好友，控制台这边就打印出来，如下： 控制台的输出 第一个那个没有备注的是本人的微信，别怕，其次后面的那串字符是用户的id，到时候真正群发的时候当参数使用，不会发给好友，别怕。测试没有问题之后，我们就可以按照注释的说明，将代码中的 print 改成 itchat.send 方法，重新运行代码，然后真正的群发给好友了，如下 写在后面 本次我用的是 itchat 这个开源的 Python 微信库，里面还有很多玩法，挺好玩的，大家可以去它 官网 看看，有 github 的朋友也可以去到 github 上给它个 star 呗，饮水思源嘛。 告诉大家一个残忍的事实吧，其实这个也是有点麻烦的。如果是带好友自己的昵称的话，虽然方便，但是感觉也没有那么亲切啊。要是带自己给好友的备注的话，鬼知道你会给你那些损友起啥备注咧，让好友知道你对他的备注感觉会有翻车的危险啊。 给好友拜年还是要真诚啊，这样虽然也算用心了，但是也是用了点小技巧啊。如果是要给某些很重要的人（手动滑稽，别想歪哦 ~(@^_^@)~ ）发过年祝福的话，还是要自己手打一句，再发个红包啦。只希望以后有个群发红包的功能，这个不用说啦，红包都发了，谁还敢说不真诚！ 最后的最后，过年嘛，也不要老是手机联络感情啦。直接拉出来三五好友聚聚餐，吹吹水，这才好玩嘛！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>微信群发</tag>
        <tag>新年祝福</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白重装系统]]></title>
    <url>%2F2019%2F01%2F17%2Fczxt%2F</url>
    <content type="text"><![CDATA[前言 现在电脑是人手必备啦，所以大家多少都要了解一下电脑的东西，这样电脑出问题也不会被修电脑的忽悠了。今天就说一下万能的「重装系统」大法。 重装系统的话，现在有两种方式：一是用 nt6 程序直接装系统，这种就比较简单啦，直接去下个 nt6，都有文字提示，不过这个软件暂不支持在 win10 上面运行，所以 win10 的小伙伴想重装系统的话就要看下面的 U 盘装机咯。 下面就开始我们最常用的 U 盘装机咯 1 准备工作要装系统，首先有下面几样东西 一个 U 盘 启动盘制作工具（easyU） 一个系统安装包 驱动和激活工具 上面的这些东西我都放到这个网盘里面啦，大家自己下啦链接：https://pan.baidu.com/s/1DfaH7irX30XDCsqxdjgvpA提取码：rkd9下面我们开始一步一步来刷机 1.1 制作 U 盘启动盘这个就很简单啦，直接电脑插入 U 盘，打开 easyU，直接全新制作就行了，简简单单，如下图： 注 这个制作启动盘会格式化 U 盘，所以原来 U 盘有东西的话记得清走。 1.2 进入 PE进入 PE 的快捷键各个品牌的电脑可能会不一样，有的是 F2，有的是 F10，DEL，F12 也有，大家装系统前自己先去百度那那个型号的电脑进入 PE 的快捷键是啥，然后一按开机键就猛按就对了（其实在电脑品牌那个界面出现的时候按就可以了，不过为了怕错过，一开始就猛按吧） 猛按之后电脑会让你选择启动模式（如下图的样子），选择 U 盘启动（带有 「USB」 字眼的那个） 选择 U 盘启动之后，会让你选择 PE 系统，有两个选项，随便调进去进行了。如下图： 注 各个 U 盘启动盘的界面不一样的，我那时候忘记拍照了，所以就从网上找了个类似的图片,所以图片不一样的是正常的，别怕。 选择后进入 PE，这个过程和我们日常开机是一样的，需要等待一段时间，然后就开入我们所谓的 PE 啦（其实就是一个装在 U 盘里面简化的 windows 系统，没那么神秘），如下： 1.3 磁盘分区别怕，这个看起来吓人而已，其实也是用软件帮我们搞的。 打开桌面的 「DG 硬盘分区软件」，进去之后有两种选择 如果你只是想格式化 C 盘，然后装系统的话，就直接选中 C 盘，然后右键格式化就行 如果你像我一样想干干净净开始或者像重新调整磁盘空间的话，选中电脑硬盘，右键快速分区 后面要咋分配就是你自己的事情啦，不过要注意如果你要装 win7，分区表类型最好选 MBR 格式，win10 就 GUID 格式咯，然后系统盘最好留个 100 G 吧。一键确定之后，硬盘格式化！东西就全都没啦！所以千万要备份好自己的数据哦（手动滑稽） 2 重装系统准备了那么多，选择终于要开始的我们的装系统环节了，其实装系统和装一个软件是一样的，首先打开我们的系统镜像 双击 setup 装咯 下一步咯 有密钥的就输入密钥，想我一样没有的就点击「我没有产品密钥」咯 挑个喜欢的版本吧 此处我们选择自定义安装 选中系统盘安装 到了这边就等着他自己装啦 — 很久之后 — 他装完系统要重启啦，这个时候就等系统重启，但是在电脑关机之后，启动之前把 U 盘拔了。 重启之后，恭喜你，系统安装成功啦（此处省略 win10 系统那烦人的电脑个性化设置） 3 后续工作虽然说这样安装完，电脑是可以用的了，但是他会缺少一些驱动啥，后面用的时候可能会出问题，所以现在我们为我们的电脑装修一下。 3.1 装驱动这个也简单，直接用网盘中万能驱动软件（用对应系统的啊），他会自动检测电脑缺啥驱动了，我们之需要到软件的右下角选中 「安装后删除已解压的驱动文件」，并且把软件推荐中的那些不要附加软件去掉勾选，且点击上面的那个倒三角菜单，取消掉那个网址导航（虽然人家要赚钱，但是我就是不想要这些附加的鬼东西啊） 最后一键安装，等就对了 3.2 安装运行库这个步骤是可以省略的，但是有些软件运行是要依赖某些运行库的，为了省去以后的麻烦，我一般会先装网盘中的那四个运行库，当然安装前，要勾选掉倒三角菜单中的那个「网址导航」。（没有办法，自己用的电脑，一定要清爽干净） 3.3 激活不是每一个人都有正版的 windows 的密钥啊，所以我们就只能去通过各种方式去激活了。 这里的话就要用网盘里面的那两个激活工具了，win7 的图形化界面操作，就不用说了。win10 的话打开那个激活工具的文件夹，选中 KMS-VL-ALL.cmd 文件，右键以管理员身份运行（管理员身份运行哦，不要直接双击打开了，然后这个工具还会顺便帮你激活你的 office），然后就让他自己操作，激活完后他会自己关掉的。可能杀毒软件会报毒，没事的，别怕。 4 写在最后看完是不是觉得重装系统真的挺简单的列，是的，就是这么简单的，不过备份数据啊，重装软件，配置电脑这些就比较烦，所以没事就不要乱重装系统折腾自己啦，好好关心照顾自己的电脑啦。 最后放一下我那些装机工具的来源 U 盘制作工具 万能驱动软件 系统镜像,这个网站还有微软原生的 office 镜像文件，需要的也可以去下载。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>重装系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS 中数组对象的方法]]></title>
    <url>%2F2018%2F12%2F17%2Farr-fn%2F</url>
    <content type="text"><![CDATA[前言 在 JS 中我们数组用的是比较多的了，它自带了很多方法可以用，省去了我们时间，特别是 ES6 当中对数组的扩展让数组具有了更强大的功能，为了以后使用数组的时候能够充分发挥数组的特性，在这里对数组的方法进行一次汇总吧。 说明 标题后的标识 * 是说明该方法会改变原数组 对数组元素的操作push() &amp; pop() *push() 向数组的末尾添加一个或更多元素（就是传进去的参数），并返回新的长度。 pop() 删除并返回数组的最后一个元素。 具体效果看代码 12345678910let arr = [1,2,3];let res1 = arr.push(5);console.log(res1); // 4 arr的长度console.log(arr); // [1,2,3,5] let res2 = arr.pop();console.log(res2); // 5 移除的数组项console.log(arr); // [1,2,3] shift() &amp; unshift() *shift() 删除并返回数组的第一个元素 unshift() 向数组的头部添加一个或者多个元素（传入的参数），并返回新的长度。 具体效果看代码 12345678910let arr = [1,2,3];let res1 = arr.shift();console.log(res1); // 1 移除的数组项console.log(arr); // [2,3] let res2 = arr.unshift(5,7);console.log(res2); // 4 数组新长度console.log(arr); // [5,7,2,3] slice()这个方法是从某个已有的数组返回选定的元素。一般带两参数 par1 和 par2，方法返回原数组 [par1, par2) 区间内的值组成的新数组。如果只有一个参数 par1 的话，就返回原数组 [par1，数组尾] 区间内的值组成的新数组。具体看代码 12345let arr = [1,2,3];console.log(arr.slice(1,2)); // [2]console.log(arr.slice(1)); // [2,3]console.log(arr); // [1,2,3] splice() *这个方法有点复杂了，他是从原数组中删除/添加项目,并返回删除的项目。具体是删除还是添加，看参数决定，它至少需要两个参数 index，deleteCount，分别指代要开始删除/添加项目的下标 index 和要删除的项目的个数 deleteCount，后面如果其他参数通通就是要加入 index 位置后面的项目了。看代码就知道一切了。123456789101112let arr = [0,1,2,3,4];// 删除操做console.log(arr.splice(0,2)); // [0,1] 从 下标 0 的位置开始删除两个元素，并返回。 console.log(arr); // [2,3,4] 删除后就剩它仨了// 添加操作console.log(arr.splice(1, 0, 5, 6, 7)); // [] 第二个参数 0 ，那就没有删除啥元素咯，然后在下标 1 的位置开始插入console.log(arr); // [2, 5, 6, 7, 3, 4] // 替换操作console.log(arr.splice(1,1,2)); // [5]console.log(arr); // [2, 2, 6, 7, 3, 4 ] 这个方法是很强大的，可以用它来实现数组元素的删除，替换，添加的操作，看上面代码就知道啦。 整个数组的大操作(转换&amp;拼接&amp;排序&amp;倒置)join()这个方法是将数组转换为字符串，数组元素间用传进去的参数（ 没有参数就用,） 分隔123let arr = [1,2,3,4,5];console.log(arr.join('|')); // 1|2|3|4|5console.log(arr.join()); // 1,2,3,4,5 concat()这个方法用于拼接两个数组并返回一个新的数组。12let arr = [1,2,3,4,5];console.log(arr.concat([6,7,8])); // [ 1, 2, 3, 4, 5, 6, 7, 8 ] sort() *这个就不用讲了吧，排序，不过默认的排序方法是把数字当成字符串来排序的，所以就会有了下面代码中的问题，也有了我们关于排序的重写。12345678let arr = [1,22,13,4,5];arr.sort();console.log(arr) // [ 1, 13, 22, 4, 5 ] 因为 22 的第一个字符是 2 比 4 小，所以 22 比 4 小。。。 arr.sort(function(val1,val2)&#123; return val1-val2;&#125;)console.log(arr); // [ 1, 13, 22, 4, 5 ] reverse() *如其名，倒置数组的元素。123let arr = [1,22,13,4,5];arr.reverse();console.log(arr) // [ 5, 4, 13, 22, 1 ] toString() &amp; toLocaleString() &amp; valueOf()这三个方法，是个对象就会有，数组对象也不例外，也顺便写出来看看吧，具体啥效果，看代码吧。1234let arr = [1,22,13,4,5];console.log(arr.toString()); // 1,22,13,4,5console.log(arr.toLocaleString()); // 1,22,13,4,5console.log(arr.valueOf()); // [ 1, 22, 13, 4, 5 ] 数组位置方法indexOf() &amp; lastIndexOf()这个用于查找数组中的元素，找到后返回元素的下标，找不到的话就返回 -1。两个方法都是一样的，只不过一个从头到尾找，一个从尾到头找1234let arr = [1,22,13,4,5];console.log(arr.indexOf(13)); // 2console.log(arr.lastIndexOf(22)); // 1console.log(arr.indexOf(44)); // -1 迭代方法every() &amp; some()every() 对数组每一项运行一个函数，如果该函数对每一项都返回 true，则整体返回 true some() 这个和上面一样啦，不过这个只要有一项是 true，整体就返回 true 具体看代码啦1234567891011let arr = [1, 2, 3, 4, 5];console.log( arr.every(function (item, index, array) &#123; return (item &gt; 2) &#125;)); // falseconsole.log( arr.some(function (item, index, array) &#123; return (item &gt; 2) &#125;)); // true forEach()这个是对数组中的每一项运行给定函数，没有返回值。看代码吧12345let arr = [1,2,3,4,5]// 打印整个数组arr.forEach(function(item)&#123; console.log(item);&#125;); map()这个方法是对数组的每一项运行给定函数，返回每一项返回结果组成的数组。12345let arr = [1,2,3,4,5]let newArr = arr.map(function(item)&#123; return item+1&#125;);console.log(newArr); // [ 2, 3, 4, 5, 6 ] filter()这个方法是对数组的每一项运行给定函数，返回该函数会返回为 true 的数组项组成的新数组。12345let arr = [1,2,3,4,5]let newArr = arr.filter(function(item)&#123; return item &gt; 2&#125;);console.log(newArr); // [ 3, 4, 5 ] ES6 扩展的数组方法Array.from() 对象转为数组这个方法用于将两类对象转为真正的数组，分别是类数组对象和可遍历对象（包括 ES6 新增的数据结构 Set 和 Map）用法就看代码吧123456789let arrLike = &#123; '0':'1', '1':'2', '2':'2', length:'3'&#125; let arr = Array.from( arrLike);console.log(arr); // [ '1', '2', '2' ] 在实际应用中，DOM 操作返回的 NodeList 集合就是一个类数组对象。 Array.of() 值转为数组这个是用来替代 Array() 或 new Array()的，为啥要替换，来段代码感受下就知道了12345678console.log(Array()); // []console.log(Array(3)); // [, , ,]console.log(Array(1, 2, 3)); // [ 1, 2, 3 ]console.log(Array.of()); // []console.log(Array.of(undefined)); // [undefined]console.log(Array.of(3)); // [3]console.log(Array.of(1, 2, 3)); // [ 1, 2, 3 ] 看出门道了吧，Array() 会因为参数不同会有不同的效果，而 Array.of() 就不会存在这种问题啦。 copyWithin() 数组内成员复制 *这个方法有点迷，暂时不知道是用来干啥的，但是也记一下它能干啥，没准以后就用上了。它的话是在当前数组内部将指定位置的成员复制到其他位置（覆盖掉原有成员），然后返回该数组。他有下面三个参数 target（必选）：从该位置开始替换数据 start（可选）：从该位置读取数据，默认 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认是数组长度，如果为负值，表示倒数。 具体有啥效果就看代码吧12345678let arr = [1, 2, 3, 6, 5];// 从下标 0 开始换 下标 1（也就是 2）开始的数据，一直替换到 下标 4 前（也就是到 arr[3] 结束）// 人话说就是 arr[0] 到 arr[4-2] 的值被 arr[1] 到 arr[4-1] 的值替换掉console.log(arr.copyWithin(0, 1, 4)); // [ 2, 3, 6, 6, 5 ]arr2 = [0, 1, 2, 3, 4, 5, 6];console.log(arr2.copyWithin(1, 3, 6)); // [ 0, 3, 4, 5, 4, 5, 6 ] find() &amp; findIndex() 查找数组元素 find() 用于查找符合第一个符合条件的数组成员，并将其返回。如果没有的话，就返回 undefined。 findIndex() 和上面一样，不过他返回的是那个符合条件的数组的下标。 啥效果就看代码吧 12345678 let arr = [0, 1, 2, 3, 5, 5, 6];arr.find(function (value, index, arr) &#123; return value &gt; 4;&#125;) // 返回数值 5 arr.findIndex(function (value, index, arr) &#123; return value &gt; 4;&#125;) // 返回下标 4 fill() 数组填充 这个方法是用给定值填充一个数组。初始化数组的时候可以用到。它有三个参数： value 填充数组的值 start 填充的起始位置 end 填充的结束位置 12 [1, 2, 3].fill('a') // [ 'a', 'a', 'a' ][1, 2, 3, 4, 5].fill('a', 2, 4) // [ 1, 2, 'a', 'a', 5 ] entries() &amp; key() &amp; values() 遍历数组这三个都会返回一个迭代器对象，可以用 for…of 循环遍历，区别是，entries() 遍历键值对，keys() 遍历键名，values() 遍历键值，啥效果看代码。12345678910let arr = [1, 2];for (let [index, ele] of arr.entries()) &#123; console.log(index, ele);&#125; // 0 1 1 2for (let index of arr.keys()) &#123; console.log(index);&#125; // 0 1for (let ele of arr.values()) &#123; console.log(ele);&#125; // 1 2 includes() 判断数组是否有某值这个方法如其名，用于判断数组内是否有某个值，如果有，返回 true，没有，返回 false。他如果有第二个参数的话，那么第二个参数表示开始搜索的位置。123let arr=[1,2,3,4,5,6,7];arr.includes(1) // truearr.includes(1,5) // false 从下标 5 开始搜没有 1 关于数组的的方法，就总结道这边了，如果还有遗漏或者错误的地方的话，就麻烦下下面评论修正啦。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号写作备忘]]></title>
    <url>%2F2018%2F12%2F11%2Fwechat-writing%2F</url>
    <content type="text"><![CDATA[前言 相信很多人除了在博客网站分享之外还会在微信公众号上进行分享，当然我也不例外，所以今天就写一下关于方面的内容。 优雅的展示代码相信现在大部分开发者写博客都是用 markdown 语法来写的，但是微信公众号并不支持 markdown 写作，这不是难受吗？所以一般都是现在其他支持 markdown 的平台先写好，然后再复制过去微信那个，文本是没问题的，但是代码就让人很难受了，鄙人尝试过各种方式，Hexo 博客，简书，有道云笔记平台上的效果，VScode 的 「Markdown preview Enhanced」插件 和 Md2All 网站的转换，结果都不行。。。 有的复制过来就出问题有的是在手机上看出问题还有些是很完美了，一般手机看都 OK 了，但是，到了 iOS。。。好吧，我要奔溃了，我只是想写个实例代码而已，不用这么坑吧！终于，我找到了一个网站 程序猿DD 在线 markdwon 转换，他终于啥都没问题了，终于连 iOS 都可以正常显示一代码了，那个网站如下图所示这个是一群大佬开源的一个项目，专治微信公众号不服了，用了不忘给人家一个 star 吧，毕竟还是要感谢人家给这么一个好用的工具是吧。 他那边可以选代码主题，我是选择 atelier-seaside-light 这个主题，觉得这个看起来舒服，然后就不管了，毕竟咱们写博客重要的是内容，排版的话也不用讲究啥最好啦，看起来舒服就可以了。从此就过上了本地 VScode 写博客，写完复制到那边格式化，然后一键复制到微信公众号，这就舒服啦。 其他排版标准这里的话就顺便放一下我从 「stormzhang」那边偷学过来的排版标准啦，希望万一哪天张哥发现这边了不要打我 空格 我们写博客会写中文、英文还有各种符号等等，如果没有一定空格隔离，看起来真的有点难受，所以不要省了下面这些情况的空格。 中英文之间需要加空格 eg. 我们注意一下 Object 类型的浅拷贝问题。 中文与数字之间需要加空格 eg. Javascript 中有 5 种基本数据类型。 数字与单位之间需要加空格 eg. 一个包含了 Vuex + Vue Router 的 Vue 项目 (gzip 之后 30 KB) 完整的英文整句时标点与单词之间需要加空格 eg. Stay hungry, stay foolish. 但是也有一些例外。 度的标志、百分号不加空格 eg. 今天广州温度只有 10°。eg. 我们一生有 50% 的时间都在睡觉。 全角标点与其他字符之间不加空格 eg. 我先学 HTML，然后再学 CSS。 标点 说到标点，简单说下全角和半角，简单来说，全角占两个字节，半角占一个字节，按照我们现在的输入法，你可以理解成中文汉字是全角，英文字母是半角， 使用全角中文标点 中文排版中所有的标点都应该使用中文全角中文标点 eg. 你看这个碗，它又大又圆。 遇到英文整句、特殊名词时使用半角标点。 eg. 乔布斯说过：「Stay hungry, stay foolish.」 使用直角引号 我国国家标准要求弯引号，但是新媒体排版时使用直角引号看起来舒服一点。 eg. 乔布斯说过：「Stay hungry, stay foolish.」 如果引号再使用引号使用直角双引号。 eg. 我和你讲，「你可以关注『异乡小红帽』这个公众号。」 其他 初以上之外，还有一些其他标准推荐大家使用的。 英文名词首字母尽量大写 eg. Javascript, HTML, CSS 专有名词使用正确的大小写 eg. GitHub、iOS、iPhone 6S 首行不要缩进 这个的话，看技术文档和前台公众号的文章就能看到基本人家都不会缩进，这是为啥咧，其实「首行缩进两字符」也就是为了区分一下自然段，看文章的时候能分个层次出来，但是我们现在微信公众号还是文档， 大家一般都采用「空出一行」来区分自然段，这种就很省事很多啦，就不用再去多敲那两个空格啦，看起来也很整齐舒服。 当然如果是写正式的电子文件和我们日常书写，肯定还是要首行缩进两字符的啦。 差不多就是这样啦。有啥遗漏或者出错的地方就麻烦大家在下面留言评论哈。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>微信公众号，排版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express 项目分层实践]]></title>
    <url>%2F2018%2F12%2F08%2Fexpress-project-2%2F</url>
    <content type="text"><![CDATA[前言 上次我们搭建了一个基本的 express 后台，但是这样的项目结构的可扩展性，维护性和代码复用性都不是很好，参照之前学习 JavaWeb 时候的四层架构设计，用分层的思想来对 express 进行一点小优化，进一步提高代码的可拓展性。本文的源代码在 Github 上，建议看着代码来看这篇文章。 1 四（五）层结构概念这个就简单说一下，所谓四层架构就是 Model实体层，Dao层（数据访问层也就是从数据库中查数据），Service层（业务逻辑层，也就是处理好数据），Controller层（视图控制层，在前后端分离的情况下就是写接口响应前端请求）和前端的 view（视图层），为啥要搞分层咧，说到底就是要解耦合，提高拓展性和维护性，写代码的时候，思路清晰一点，后面改代码的时候也知道要改哪边。 但是我们这次只是涉及后台的，视图层我们就不用管了，只需看前面的就行了。 2 分层首先看一下项目结构哈12345678910111213141516171819202122232425262728293031323334353637383940414243444546│ app.js│ package.json│ README.md│├─.idea│ │ express-project.iml│ │ misc.xml│ │ modules.xml│ │ vcs.xml│ │ watcherTasks.xml│ │ workspace.xml│ ││ └─inspectionProfiles├─bin│ www│├─config│ db.json│├─dao│ BaseDao.js│ UserDao.js│├─models│ user.js│├─public│ ├─images│ ├─javascripts│ └─stylesheets│ style.css│├─routes│ index.js│ users.js│├─services│ UserService.js│├─utils│ db-util.js│└─views error.jade index.jade layout.jade 按照分层思想，我们新建几个文件夹哈，首先是 Model层的 models 文件夹，dao 层的 dao 文件夹，service 层的 services 文件夹，controller 层的话就用原来的 routes 文件夹就可以了，为了方便，我加了一个全局配置的 config 文件夹和工具函数 utils 文件夹。具体项目如下，我们从最底层开始来一个一个来分析 2.1 config这个就放着各种配置文件，例如我的 db.json 里面就放了mongodb 的端口号，数据库名那些，反正就是各种配置啦 2.2 utils这个就是有一些创建型的方法或者其他公共方法，像创建数据库连接池的方法我就放在这边的 db-util 里面了。 2.3 models实体层,针对 mongodb 来说，一个集合对应一个 model，然后都是这样的形式啦。123456789101112131415const mongoose = require('mongoose');const &#123; mongoClient &#125; = require('../utils/db-util');// 创建 user Schemaconst user = new mongoose.Schema(&#123; name: String, id: String,&#125;,&#123;versionKey: false&#125;);/*model 的参数1 导出的模块名，参数2 创建的 Schema，参数2 指定数据库中的集合的名字，若不加的，则抹默认取‘第一个参数s’的集合*/let User = mongoClient.model('User', user, 'user');module.exports = User; 2.4 dao创建完实体层，接下来就是 dao 层了，这边我封装了一个 BaseDao，基本的数据库操作都有了，后面我们创建其他 dao 的时候就很舒服啦，直接继承一下 BaseDao 就好了。例如下面的这个 UserDao：123456789101112let BaseDao = require('./BaseDao');// 导入对应的实体let User = require('../models/user');class UserDao extends BaseDao&#123; constructor() &#123; super(User); &#125; //如果有啥特殊需求的话，自己再重写方法咯&#125;module.exports = UserDao; 这样就写好了一个基本的 dao 了，增删改查这些他都从 BaseDao 中继承了， 2.5 servicesservice 层是业务逻辑层，这么写就看你项目的业务啦。我下面就简单些一个查询所有 user 数据的方法啦。1234567891011121314151617const UserDao = require('../dao/UserDao');let userDao = new UserDao();class UserService &#123; async getUserList() &#123; try &#123; // 调用 dao 层查询数据 let userList = await userDao.findAll(); return userList; &#125; catch (err) &#123; console.log(`getUserList error--&gt; $&#123;error&#125;`); return error; &#125; &#125;&#125;module.exports = UserService; 2.6 routescontroller 层，写接口用，这个写起来简单，就拿一下 service 层的数据返回就可以啦。12345678910111213141516171819202122232425var express = require('express');var router = express.Router();const UserService = require('../services/UserService');let userService = new UserService();/* GET users listing. */router.get('/', function(req, res, next) &#123; userService.getUserList().then((data)=&gt;&#123; res.json(&#123; code:0, msg:'OK', data:data &#125;) &#125;); // res.send('respond with a resource');&#125;);router.get('/login',(req,res,next)=&gt;&#123; res.json(&#123; code:0, msg:'OK', data:&#123;result:true&#125; &#125;)&#125;);module.exports = router; 然后这边的话，我有一个想法，就是想着每次多一个路由实例（controller）的时候，就要往 app.js 里面导入并引入，觉得这样 controller 多了的时候，app.js 里面代码会很多，所以就想着把模块导入的代码移到 routes 文件夹里面的 index.js 里面来，app.js 就引入个 index 就好啦。所以就有了下面 index.js 的代码。1234567891011var express = require('express');var router = express.Router();/* GET home page. */router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;);// user 路由模块// 当我在 user 文件里面写一个 '/login' 的时候，前端访问就要访问 '/user/login'router.use('/user', require('./users'));module.exports = router; 至此，全文就结束啦，对于 express 框架的分层实践如果有更好的建议或者我这样分层有啥问题的话，欢迎在在下方留言哈，大家一起学习一下。]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>express</tag>
        <tag>分层架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手用 express 搭建后台]]></title>
    <url>%2F2018%2F12%2F08%2Fexpress-project-1%2F</url>
    <content type="text"><![CDATA[前言 想必很多小伙伴开始学 node 的时候想搞个项目出来却不知道怎么下手吧，这个教程的话就是教大家用 express 框架简单粗暴搭建一个可以用的后台出来，然后关于 node 和 express 的其他知识，大家还是需要自己去看看文档了解一下。 1 环境准备express 既然是基于 node 的开发框架，首先 node 那些肯定都配好了吧，这个就自己搞去。然后下面就是要搞 express 的东西了。 1、全局安装 express，方便后面直接导入 express 模块。1npm install express -g 2、再全局安装 express 的脚手架工具，装完我们就可以很舒服的生成一个 express 项目了1npm install express-generator -g 2 项目2.1 搭建环境配好后，搭建项目就很舒服啦，直接就是一条指令1express express-demo 接下来就是，安装依赖，运行项目12npm installnpm run start 然后我们打开浏览器查看 3000 端口，看到下面的页面就说明我们 express 后台已经跑起来了 2.2 项目结构生成的项目结构如下图所示1234567891011121314151617181920212223242526272829│ app.js│ package.json│├─.idea│ │ express-demo.iml│ │ modules.xml│ │ vcs.xml│ │ workspace.xml│ ││ └─inspectionProfiles├─bin│ www│├─public│ │ index.html│ ││ ├─images│ ├─javascripts│ └─stylesheets│ style.css│├─routes│ index.js│ users.js│└─views error.jade index.jade layout.jade 我们一个一个来说明哈。 1、bin 文件夹 里面的话有 www 文件，那个就是项目的启动脚本文件，监听端口在里面设置，一般情况不管这个文件。 2、public 文件夹 静态资源文件夹，放着 css，js，img 那些，然后如果在里面写个 index.html 的话，我们访问 3000 端口的时候就会直接访问 index.html 的那个页面。所以这边的话，可以把我们前端开发打包好的代码。 3、routes 文件夹 这个是重点啦，路由文件夹，里面的文件用于生成路由实例，这个路由实例用来响应前端发过的请求，按照现在前后端分离的思想，我们在这里面写后台的那些接口了。我们抓一个文件来看一下12345678910111213141516// index.js// 引入依赖var express = require('express');var router = express.Router();// 处理前端请求/* GET home page. *//* 这边的 router.get 是接收前端的 get 请求 第一个参数是路由地址，这边的 '/' 就指根路由，也就是http://localhost:3000 啦 第二个参数是一个响应接口的回调函数，里面有三个参数，分别是 请求头request 响应体response，和一个next*/router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;);// 导出路由模块module.exports = router; 上面这个是系统默认的给的，他的话是根据模板（下面会讲）生成了一个页面渲染回去，但是我们现在前后端都分离啦，一般都是后台写接口丢给前端就好啦，所以我们要改成下面这个样子123456789101112router.get('/', function(req, res, next) &#123; // 处理好要返回给前端的数据 let data = &#123; name:'xhm', age:12 &#125; // 用 res.json 方法写接口 res.json(&#123; code:0, msg:'ok', data:data &#125;)&#125;); 安装上面这样搞，我们重新访问 3000 端口的时候就会发现这个时候返回就是一个 json 的数据啦（如下图），这样就写了一个简单的后台接口，后面的不同业务逻辑的接口，就看你前面怎么去处理那些数据啦。 4、views 文件夹这个用于存放 jade 模板，这个的话，不懂也比较少会用到，只知道这个可以作为页面的模板来使用，渲染一下报错页面和主页，其他就没有用了。 5、app.js 文件这个是项目的入口文件，这边有着项目的一下配置，也在此整合了项目的模块，其中要注意的就是里面关于路由模块的配置了。看下面代码1234567// 引入 routes 文件夹中的路由文件var indexRouter = require('./routes/index');var usersRouter = require('./routes/users');...// 设置这些路由的地址app.use('/', indexRouter);app.use('/users', usersRouter); 这边做一点说明吧： 这边设置路由的地址是相对于项目的，然后在 routes 文件夹里面的地址是相对于这边的，用上面的代码来说，假设那个 ./routes/users 文件里面定义了 &#39;/login&#39; 这么一个路由地址，那么由于整个 users 的地址是 &#39;/users&#39;，所以我们在外面要访问那个 login 的话，该访问的地址是 http://localhost:3000/users/login。 后面要再想加其他路由模块的时候，就按照上面先引入路由模块，再用 app.use 设置好地址，后面就可以用了。 6、package.json 文件 这个就是整个项目的配置文件啦。项目的名字啦，版本号和项目所需的那些依赖全都写在这里面的啦，但是一般我们是不用管的。 3 数据库既然搭建了后台，数据库肯定是要连接的，不同的数据库的话，就安装不同的插件来使用，如果你使用的是 mongoDB 的话，就推荐使用 mongoose 来操作数据库，关于 mongoose 的使用可以看我另外一篇教程 4 后记源代码的话我放到我的 Github 上面去了,可以去 clone 下来看一下。关于 express 项目的简单开发就讲到这边啦，但是如果是这么简单的设置这个项目的目录结构的话，可扩展性不高，代码复用也不好，所以我们要看下一篇文章啦–express 项目分层实践]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>express</tag>
        <tag>分层架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 自定义指令]]></title>
    <url>%2F2018%2F11%2F26%2Fvue-custom-directive%2F</url>
    <content type="text"><![CDATA[前言 最近搞了毕设，需要实现一个场景，点击一块区域，弹出一个编辑区域，点击页面的其他地方的时候，这个编辑区域就隐藏，本想想之前写模态框一样写个方法的时候，突然 觉得可以尝试用 vue 相关的东西优雅的解决这个事情，然后就学了下面的自定义指令了。 1 Vue 自定义指令1.1 定义直接看官网的介绍吧（觉得官方文档说的很清楚了，所以我基本都是抄他的了）。 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 1.2 基础实现这个在分两种情况，如果你想定义一个全局的自定义组件的话,那么就在项目中的 main.js 里面定义了，例如定义一个官网中的自动聚焦的指令12345678// 注册一个全局自定义指令 `v-focus`Vue.directive('focus', &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 要是你只是想定义一个局部的指令在某个组件内部用的话，那么就在相应的组件内定义了123456789// 跟 data(),methods:&#123;&#125; 那些同级写了directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 定义完后我们就能愉快的使用了1&lt;input v-focus&gt; 1.2 钩子函数当然这个自定义指令不会就这么一点东西啦，为了解决一些现实中场景，Vue 给我们一堆钩子函数用来实现我们的一些骚操作。具体如下 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。 当然要想好好用用这写钩子函数，就要懂得用下面的这些参数 1.3 钩子函数参数指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：- v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { - foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 然后官网有话说 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 然后下面我们给一个简单的例子1234567891011121314151617// 在组件内部定义一个局部指令directives:&#123; demo:&#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify; el.innerHTML = `name: $&#123;s(binding.name)&#125; &lt;br&gt; value: $&#123;s(binding.value)&#125; &lt;br&gt; expression: $&#123;s(binding.expression)&#125; &lt;br&gt; argument: $&#123;s(binding.arg)&#125; &lt;br&gt; modifiers: $&#123;s(binding.modifiers)&#125; &lt;br&gt; vnode keys: $&#123;Object.keys(vnode).join(', ')&#125;` &#125; &#125;&#125; // 绑定到组件中的一个 div 中&lt;div v-demo:foo.a.b="message"&gt;&lt;/div&gt; 然后我们在网页中就可以看到这么一堆文字了(当然下面的注释是我自己写的)123456789101112name: "demo" // 指定名称value: "Welcome to Your Vue.js App" // 指令绑定值expression: "message" // 字符串形式的指令表达式argument: "foo" // 传给指令的参数modifiers: &#123;"a":true,"b":true&#125; // 修饰符的对象vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholderVue 编译生成的虚拟节点 1.4 函数简写在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写:123colorSwatch: function colorSwitch(el, binding) &#123; el.style.backgroundColor = binding.value&#125;, 1.5 对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。1&lt;div v-demo="&#123; color: 'white', text: 'hello!' &#125;"&gt;&lt;/div&gt; 1234Vue.directive('demo', function (el, binding) &#123; console.log(binding.value.color) // =&gt; "white" console.log(binding.value.text) // =&gt; "hello!"&#125;) 就差不多这样吧，想看个实例的话就看一下我的另外一篇笔记《Vue 自定义指令实现点击元素外触发事件》吧]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>自定义指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 父子组件间的通信]]></title>
    <url>%2F2018%2F11%2F25%2Fparent-child-talk%2F</url>
    <content type="text"><![CDATA[前言 在 Vue 项目中父子组件的通信是非常常见的，最近做项目的时候发现对这方面的知识还不怎么熟练，在这边做一下笔记，系统学习一下吧。 1 父组件传值给子组件1.1 传值写法父组件传值给子组件，这个就比较常见了，直接用 props 就可以了。但是就算是 props 子组件那边也有三种写法，如下面代码所示：父组件12345&lt;!-- 两种情况 --&gt;&lt;!--静态传值--&gt;&lt;child name="xhm"&gt;&lt;/child&gt;&lt;!--动态传值--&gt;&lt;child :name="userName"&gt;&lt;/child&gt; 子组件12345678910111213// 1 简单粗暴就给个名称的情况props:['name'],// 2 给个名称顺便指定个类型，如果父组件传递过来的值类型不对的话就会报错props:&#123; name:String&#125;,// 3 给个名称不仅指定了类型，还顺便送了个默认值,当父组件传个空过来或者啥都没传过来的时候就用默认值了props: &#123; name: &#123; type: String, default: 'xhm', &#125;&#125;, 注意一下的话，如果是数组或者是对象要默认值的话，直接设置默认数组或者默认对象会报错，需要用工厂函数返回，如下：123456789props: &#123; arr:&#123; type:Array, default:()=&gt;&#123; return [1,2,3] &#125; &#125;&#125;,// 对象也是和上面一个用工厂函数 1.2 子组件使用父组件的值由于单向数据流的限制，我们不能直接在子组件中修改 props 的值，当我们修改的时候会报错,官方的说法是： 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。 所以啊，如果你不只是想在子组件中简单的渲染父组件传过来的值的话，那么可以用下面的两种方法。 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： 123456props: ['name'],data() &#123; return &#123; userName:this.name, &#125;;&#125;, 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性： 123456props: ['name'],computed: &#123; userName()&#123; return this.firstName + this.name &#125;&#125;, 2 子组件传值给父组件虽然我们说是要单向数据流，但是很多时候，我们在子组件改变了某些值之后，还是要反馈给父组件，让父组件做一下修改，那么这个时候就要想着子组件向父组件传值啦。有下面这么两种方式 2.1 emit 方法这个基本都是用 emit 来传递了，用法直接看代码吧：子组件1234567// props:['name]// methods 里update()&#123; this.$emit('update','ljy'); // 第一个参数：事件名，第二个参数：传递给事件方法的参数&#125; 父组件1234567891011/* template 里面的代码，监听子组件里面的 update 事件，调用父组件的 childUpdate 方法 &lt;child :name="userName" @update="childUpdate"&gt;&lt;/child&gt;*/// methodschidlUpdate(val)&#123; // val 参数就是子组件传递过来的数据 this.userName = val;&#125; 虽然这样是可以实现子组件向父组件传值，但是写多一个方法感觉很烦，所以 vue 官方高出了一个 以 update:myPropName 的模式触发事件。，这个是啥，举个例子，我们的子组件中有一个 name 的 props，我们用下面这个形式通知父组件12this.$emit('update:name', newName)// this.$emit('update:props中的变量名', 新的值) 然后父组件可以监听那个事件并根据需要更新一个本地的数据属性:1&lt;child :name="userName" @update:name="userName = $event"&gt;&lt;/child&gt; 这样当我们在子组件触发那个修改的方法的时候，父组件的 userName 变量就会更新为 newName了，然后为了方便起见，官方提供了一个缩写，即 .sync 修饰符。看代码吧：1&lt;child :name.sync="userName"&gt;&lt;/child&gt; 上面的代码和前面的代码是一个效果，是不是方便了很多。舒服了吧。 2.2 利用浅拷贝（不推荐）这个的话是针对于 对象和数组那些引用类型的数据而言的，由于这些存在浅拷贝的问题（不明白浅拷贝的看这篇文章），所以可以利用这点来实现子父组件的「同生共死」，看代码吧12345// 假设 name 是一个对象或者数组props:['name'],return &#123; userName:this.name,&#125;; 就这样？！ 没错就是这么简单粗暴，由于浅拷贝的问题，我们在子组件修改 userName 的时候，从父组件传递过来的那个值也会改变的，然后就会实现 props 的「双向绑定」了。但是一般没人会这么干，因为这样会造成维护上的问题，会让人觉得咋没干啥父组件的值咋就变了，会让人头秃啊，所以除非你项目中非得要搞这么一个子父组件 props 的「同生共死」，那就这么干吧。 3 子组件调用父组件的方法不知道这样的叫法对不对，反正就这样啦。总结之后又下面这几种方法 3.1 emit其实本来 emit 就是用于子组件向父组件通信的，上面的子组件传值给父组件其实也就是父组件监听子组件的事件，然后触发父组件的方法的，换个说法，也就是子组件调用了父组件的方法，再写一下代码吧： 子组件12345// methods 里update()&#123; this.$emit('update','ljy'); // 第一个参数：事件名，第二个参数：传递给事件方法的参数&#125; 父组件1234567891011/* template 里面的代码，监听子组件里面的 update 事件，调用父组件的 childUpdate 方法 &lt;child :name="userName" @update="childUpdate"&gt;&lt;/child&gt;*/// methodschidlUpdate(val)&#123; // val 参数就是子组件传递过来的数据 this.userName = val;&#125; 上面的代码中，从某种意义上来说，就是子组件调用了父组件的 childUpdate 方法。 3.2 this.$paarent.event这个就比较简单了，我们假设我们在父组件定义了一个 fatherMethod() 方法，然后我们子组件就可以通过下面的代码实现调用 fatherMethod() 的方法123childClick()&#123; this.$parent.fatherMethod();&#125; 3.3 propsprops 能传递 Function 类型的数据，所以，我们通过 props 当然也是可以直接的调用父组件传递过来的方法啦。不多说，直接撸代码：父组件12&lt;!-- 假设父组件里定义了一个 fatherMethod() 方法 --&gt;&lt;child :fatherMethod="fatherMethod"&gt;&lt;/child&gt; 子组件1234567891011props: &#123; fatherMethod: &#123; type: Function, default: null &#125;&#125;,methods: &#123; childClick() &#123; this.fatherMethod(); &#125;&#125;, 这样我们也是调用了父组件的方法啦。 4 父组件调用子组件的方法这个，暂时没有遇到过这种情况，不过以备不时之需，也写一下吧。父组件调用子组件的方法的话是利用 ref 获取到子组件实例，从而调用子组件的方法，假设我们子组件有这么一个 childMethod() 方法。那么我们的父组件就可以这么来调用子组件的方法了1234567/* &lt;child ref="con"&gt;&lt;/child&gt; 子组件 */methods: &#123; update() &#123; this.$refs.con.childMethod(); &#125;,&#125; 至此，关于父子组件通信的的话题就聊到这边了，如果有啥错误或者遗漏的，欢迎在下面斧正啦。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue 自定义指令实现点击元素外触发事件]]></title>
    <url>%2F2018%2F11%2F25%2Fcustom-directive-clickoutside%2F</url>
    <content type="text"><![CDATA[前言 最近搞了毕设，需要实现一个场景，点击一块区域，弹出一个编辑区域，点击页面的其他地方的时候，这个编辑区域就隐藏，本想想之前写模态框一样写个方法的时候，突然觉得可以尝试用 vue 相关的东西优雅的解决这个事情，然后就学了下面的自定义指令了。 前置知识既然要用 Vue 的自定义指令，那么肯定要了解一下 Vue 自定义指令的相关知识啦，关于这部分的内容，看我之前写过的《Vue 自定义指令》或者直接看官方文档就可以啦，这里我就不再多讲了。 解决思路这个按照我之前写模态框的经验，我的做法是给 document 绑定一个点击事件，然后判断触发点击事件的那个元素是不是模态框所在的目标区域，如果不是，那么就触发隐藏事件。看一下代码吧123456$(document).mouseup(function(e)&#123; var _con = $(' 目标区域 '); // 设置目标区域 if(!_con.is(e.target))&#123; // 判断是不是目标区域 some code... // 功能代码 &#125;&#125;); 实现有了思路，实现起来就简单了。就直接放定义的代码啦12345678910111213141516171819202122232425262728const clickOutside = &#123; // 初始化指令 bind(el, binding, vnode) &#123; function clickHandler(e) &#123; // 这里判断点击的元素是否是本身，是本身，则返回 if (el.contains(e.target)) &#123; return false; &#125; // 判断指令中是否绑定了函数 if (binding.expression) &#123; // 如果绑定了函数 则调用那个函数，此处binding.value就是handleClose方法 binding.value(e); &#125; &#125; // 给当前元素绑定个私有变量，方便在unbind中可以解除事件监听 el.__vueClickOutside__ = clickHandler; document.addEventListener('click', clickHandler); &#125;, update() &#123;&#125;, unbind(el, binding) &#123; // 解除事件监听 document.removeEventListener('click', el.__vueClickOutside__); delete el.__vueClickOutside__; &#125;,&#125;;directives: &#123;clickOutside&#125;, 接下来就可以就可以在组件内直接使用啦1&lt;div v-click-outside="closeDialog"&gt;&lt;/div&gt; 我实现的效果 然后关于这个点击元素外触发某个事件，如果还有啥其他优雅的方式的话，下面留言分享一下哈。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS 中的深拷贝与浅拷贝]]></title>
    <url>%2F2018%2F11%2F25%2Fdeepcopy-shallowcopy-in-JS%2F</url>
    <content type="text"><![CDATA[前言 最近在写项目的时候涉及到一些父子组件传递个对象或者数组通信啥的，或者是直接复制添加对象啥的，直接使用赋值的时候总会出错 1 什么是深拷贝&amp;浅拷贝见名知义，无论是深拷贝还是浅拷贝，都是 copy 的问题。就是 copy 的时候出现的两种情况。区分起来也挺简单的，举个例子，假设 B 是 A 复制过来的，当我们修改 A 的时候，B 也随之改变了，那么这个就是浅拷贝，那要是 B 没有随 A 一起改变的话，那么这个就深拷贝了。 2 现实场景首先呢，我们先要明白在 Javascript 中，有 5 种简单数据类型（也称为基本数据类型），分别是 Undefined，Null，String，Number，Boolean,还有 1 种复杂数据类型即 Object，（ES6 新出的 Symbol 数据类型就先不讨论了） 2.1 基本数据类型对于基本数据类型的复制就谈不上什么深拷贝和浅拷贝了，对于基本数据类型来说，他们的值在栈内存中占据着固定大小的空间，并被保存在栈内存中。假设 变量 b 复制 基本数据类型变量 a，那么 b 会内存中占据自己的空间，和 a 就没啥关系了，大家各管各的，互不干涉。12345let a = 2; let b = a;b = 4;console.log(a); // 2console.log(b); // 4 2.2 复杂数据类型（Object）对于对象的话，他是引用类型，复制起来就要区分浅拷贝和深拷贝了，因为 Object 是引用类型，他真正的值保存在堆内存中，他在栈内存存储是变量名和指向该对象值的指针（就是一个地址），如下图所示。所以当我们用平常用一个变量去复制一个 Object 类型的变量的时候，复制的是他的指针地址而已，所以两个变量最终都指向同一个变量，大家要改一起改，这就是浅拷贝啦，如下12345let obj1 = &#123;name:'kk',age:12,desc:'源对象'&#125;let obj2 = obj1;obj2.desc = '目标对象'console.log(obj1); //&#123;name:'kk',age:12,desc:'目标对象'&#125; 此处源对象跟着一起变了console.log(obj2); // &#123;name:'kk',age:12,desc:'目标对象'&#125; 啥，不信？！，那就看图如何但是在我们日常的使用当中，Object 类型的浅拷贝的行为会让我们很迷，我复制这个对象就是想复制他的值而已啦，不要复制人家个值就和他绑到一块了，跟他一起「同生共死」。所以啊，当我们想按照我们复制的想法，就只复制他的值用来自己用，他的是他的，我的是我的，大家井水不犯河水。接下来就要说咋办了。 3 实现对象类型的深拷贝对于对象的深拷贝，搜集了网上的资料，就有下面三种方法 3.1 slice()&amp;concat()这个是针对数组的深拷贝，可以通过这两个方法实现对数组的深拷贝,如下1234567891011121314151617let arr = [1,2,3,4]let arr2 = arr.slice();arr[0] = 0;console.log(arr); //[1,2,3,4]console.log(arr2); //[1,2,3,4]``` `concat` 同理可得，不过这两个方法有个问题，`slice()` 和 `concat()` 方法能够深拷贝的就只有数组的一级属性，但是如果是多维数组的话，那么只有一级属性的值是深拷贝，往下就都是浅拷贝了，如下所示```javascriptlet arr = [[1,2],2,3,4]let arr2 = arr.concat();arr[0][0] = 0;arr[1] = 1;console.log(arr); //[[0,2],1,3,4]console.log(arr2); //[[0,2],2,3,4]// arr2[1] 没变，但是 arr2[0] 跟着一起改了 3.2 JSON 的骚操作通过 JSON 的 stringify， parase 操作也可以实现对象的深拷贝。123456789101112131415161718192021222324252627282930313233let obj1 = &#123;name:&apos;kk&apos;,age:12,desc:&apos;源对象&apos;&#125;let obj2 = JSON.parase(JSON.stringify(obj1));obj2.desc = &apos;目标对象&apos;;console.log(obj1); //&#123;name:&apos;kk&apos;,age:12,desc:&apos;源对象&apos;&#125; 此处源对象就没有一起变了console.log(obj2); // &#123;name:&apos;kk&apos;,age:12,desc:&apos;目标对象&apos;&#125;``` 此法数组和对象都可以用。### 3.3 自己写一个深拷贝函数自己动手，丰衣足食```javascriptfunction deepCopy(obj) &#123; let newObj = Array.isArray(obj) ? [] : &#123;&#125;; if (obj &amp;&amp; typeof obj === &quot;object&quot;) &#123; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; //判断ojb子元素是否为对象，如果是，递归复制 if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123; newObj[key] = deepCopy(obj[key]); &#125; else &#123; //如果不是，简单复制 newObj[key] = obj[key]; &#125; &#125; &#125; &#125; return newObj;&#125;let a = [1,2,3];let b = deepCopy(a);a[0] = 0;console.log(a); //[0,2,3]console.log(a); // [1,2,3] 3.4 JQ 的 extend 方法这个就直接放文档了$.extend( [deep ], target, object1 [, objectN ] )deep:如果设为true，则递归合并即深拷贝。target:待修改对象。object1:待合并到第一个对象的对象。objectN:待合并到第一个对象的对象。使用如下 let a = [1,2,3], let b = $.extend(true,[],a); a[0]=1; console.log(a); // [0,2,3] console.log(b); // [1,2,3] 以上就是关于 JS 中的深拷贝与浅拷贝的知识和如何进行深拷贝的知识了，如果有错或者有其他方式的话，欢迎在下面留言评论啦。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
        <tag>浅拷贝</tag>
        <tag>对象复制</tag>
        <tag>对象传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 模块化知识]]></title>
    <url>%2F2018%2F11%2F02%2Fjs-module%2F</url>
    <content type="text"><![CDATA[前言最近遇到很多朋友问 Javascript 模块化使用的问题，然后发现对这这个也是一知半解，偶尔还会搞混，在项目中使用的时候会出各种小错误，所以就写一下，复习一下 Javascript 模块化的知识和使用方式。 模块通常是指编程语言所提供的代码组织机制，利用此机制可将程序拆解为独立且通用的代码单元。所谓模块化主要是解决代码分割、作用域隔离、模块之间的依赖管理以及发布到生产环境时的自动化打包与处理等多个方面。 1 模块化的优点 可维护性。因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进。 命名空间。在 JavaScript 里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化开发来封装变量，可以避免污染全局环境。 重用代码。我们有时候会喜欢从之前写过的项目中拷贝代码到新的项目，这没有问题，但是更好的方法是，通过模块引用的方式，来避免重复的代码库。 2 模块化规范2.1 CommonJS 规范CommonJS 是 Mozilla 的工程师于 2009 年开始的一个项目，他的目的是让浏览器之外的 Javascript （比如服务器端或者桌面端）能够通过模块化的方式来开发和协作。 在 CommonJS 规范中，每个 JS 文件就是一个独立的模块上下文（module context），在这个上下文中创建的属性都是私有的。也就是说，在一个文件定义的变量（包括函数和类），都是私有的，对其他文件是不可见的。 2.1.1 实例这里分两种情况讲明吧，一种是一个文件中导出一个模块，这种我们引入模块的时候可以定义随便一个变量名去接入使用模块。另外则是一个文件中导出多个模块。这种情况的话，模块文件导出的是一个包含多个模块的对象，我们导入引用的时候只能是用一个对象 {} 引用，然后这边使用的模块名必须要和源文件中导出的模块名一致。（这边有点绕，具体看代码就明白了） 一个文件导出一个模块 123456789// sayHello.jsfunction sayHello()&#123; console.log('hello')&#125;module.exports = sayHello//main.js 中引入 sayHello.js// 引入单个模块，这里引入的时候可以 say，sayHello 等等变量名去定义导入的模块 const say = require('./sayHello.js'); 一个文件导出多个模块 12345678910111213// say.jsfunction sayHi()&#123; console.log('hello'); &#125;function sayBye()&#123; console.log('bye');&#125;module.exports = &#123;sayBye,sayHi&#125;/* main.js* 这个时候引用的话，用&#123;&#125;去引用导出的模块，怎么导出我们就怎么引用，然后里面的模块名就只能是引用文件 say.js 里面定义的 sayBye，sayHi 变量名*/const &#123;sayBye, sayHello&#125; = require('./say.js'); 2.1.2 注意事项因为 CommonJS 规范主要应用的场景是服务器端，所以采用同步加载模块的策略。如果我们依赖 3 个模块，代码会一个一个一次加载，这种的话就不适合浏览器端来使用了。 2.2 AMD 规范AMD 是 Asynchronous Module Definition 的简称，即『异步模块定义 』，见名知义，AMD 优先照顾浏览器模块的加载场景，使用异步加载和回调的方式。注意使用模式需要 define 方法的支持。一般是引用 requireJS 2.2.1 实例123456789101112131415// file lib/sayModule.js define(function ()&#123; return &#123; sayHello: function () &#123; console.log('hello'); &#125; &#125;; &#125;); //file main.js define(['./lib/sayModule'], function (say)&#123; say.sayHello(); //hello &#125;) 这种形式感觉有点烦，个人基本都没怎么用。 2.3 CMD 规范CMD 是 Common Module Definition，公共模块定义， 2.4 ES6 规范ES6 规范用的就比较多了，他的话比较简单清晰，就分为导出（export）与导入（import）两个模块 然后他的使用方式也是有很多种情况。 直接用 export {模块，模块} 导出。引用的话就直接用 import from 导出就可以了。 123456789// module.jslet fn = function()&#123; console.log('test');&#125;let bar = 'bar';export &#123;fn, bar&#125;// main.jsimport &#123;bar, fn&#125; from './module'; 重命名导出与导入。有时候发现我引用了两个文件的模块的名字是一样的，然后就会出现命名冲突了，这个时候就需要重命名导出导入来解决这种情况了，具体就看代码了。 12345678// 导出重命名let name = 'name';// 这个时候其他文件导入的时候就用 newName 导入了export &#123; name as newName&#125;// 导入重命名// 这样我们就用 newName 这个名字重命名原来的模块了。import &#123; moduleName as newName&#125; from 'test' export default 匿名导出，如果只想导出一个 js 模块或者功能，可以直接用 export default 导出 123456// module.js 字符串，方法，对象，想导出啥就导出啥export default 'string';// main.js XX YY，想用啥命名就用啥命名，毕竟导出的就只有一个对象import XXX from './lib'console.log(XXX) // 'string' 总结一般就用 ES6 的规范和 CommonJS 的规范，AMD 和CMD 实在不熟，就没用过了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>CommonJS</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单学习 Promise 对象]]></title>
    <url>%2F2018%2F10%2F24%2Flearn-promise%2F</url>
    <content type="text"><![CDATA[引言 Promise 是异步编程的一种解决方案，比传统的解决方案——回调和事件——更合理且强大。最近的项目要用到这个，就参考阮一峰老师的《ES6标准入门》这本书简单学一下了。 1 Promise 的含义所谓 Promise ，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上来看，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise 对象有以下两个特点。 对象的状态不受外界影响。 一旦状态改变就不会再变。 2 基本用法ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。举个例子。 123456789var promise = new Promise(function (resolve, reject) &#123; // some code if (/* 异步操作成功*/) &#123; resolve(value); &#125; else &#123; // 异步操作失败 reject(error); &#125;&#125;); Promise 构造函数接收一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。他们是两个函数，由 Javascript 引擎提供，不用自己部署。 resolve 函数的作用是将 Promise 对象的状态从『未完成』（Pending）变为『成功』（Resolved），在异步操作成功的时候调用，并将异步操作的结果作为参数传递过去。 reject 函数的作用是，将 Promise 对象的状态从『未完成』（Pending）变为『失败』（Rejected） 当我们生成了一个 Promise 实例之后。就可以用 then 方法分别指定 Resolved 状态和 Rejected 状态的回调函数。 1234567promise.then(function (value) &#123; // success console.log(value);&#125;, function (error) &#123; // failed console.log(error);&#125;); then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 Resolved 时调用，第二个回调函数是 Promise 对象的状态变为 Rejected 时调用。其中第二个参数是可选的，不一定要提供。这两个函数都接收 Promise 对象传出的值作为参数。 我们来个小例子 1234567891011121314let promise = new Promise(function(resolve,reject)&#123; console.log('Promise'); let value = 'value'; resolve(value);&#125;);promise.then(function(value)&#123; console.log(value);&#125;);console.log('Hi');// Promise// Hi// value 上面的代码中，Promise 新建后会立即执行，所以首先输出的是 Promise。然后，then 方法指定的回调函数将当前脚本所有同步任务执行完成后才会执行，所以 Resolved 最后输出。 3 Promise.prototype.then()Promise 实例具有 then 方法，即 then 方法是定义在原型对象 Promise.prototype 上的。它的作用是为 Promise 实例添加改变状态时的回调函数。前面说过，then 方法的第一个参数是 Resolved 状态的回调函数，第二个参数（可选）是 Rejected 状态的回调函数。 then 方法返回的是一个新的 Promise 实例（注意 不是原来的那个 Promise 实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。 12345getJSON("/posts.json").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 上面的代码使用 then 方法依次指定了两个回调函数。第一个回调函数完成以后，将会返回结果作为参数，传入第二个回调函数。 然后采用链式的 then 可以指定一组按顺序调用的回调函数。这时，前一个回调函数有可能返回的还是一个 Promise 对象（即有异步操作），而后一个回调函数就会等待该 Promise 对象的状态发生变化，再被调用。 4 Promise.prototype.catch()Promise.prototype.catch 方法是 .then(null, rejection) 的别名，用于指定发生错误时的回调函数。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面的代码中，getJSON 方法返回一个 Promise 对象，如果该对象状态变为 Resolved，则会调用 then 方法指定的回调函数；如果异步操作抛出错误，状态就会变成 Rejected，然后调用 catch 方法指定的回调函数处理这个错误。另外， then 方法指定的回调函数如果在运行中抛出错误，也会被 catch 方法捕获。 123456p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err)); // 等同于 p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log("rejected:", err)); 下面是一个例子。 1234567const promise = new Promise(function(resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// Error: test 上面的代码中，Promise 抛出一个错误就被 catch 方法指定的回调函数所捕获。注意，上面的写法和下面两种写法是等价的。12345678910111213141516171819// 写法一const promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error('test'); &#125; catch(e) &#123; reject(e); &#125;&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// 写法二const promise = new Promise(function(resolve, reject) &#123; reject(new Error('test'));&#125;);promise.catch(function(error) &#123; console.log(error);&#125;); 由上面可以看出， reject 方法的作用等同于抛出错误。如果 Promise 状态已经变成 Resolved，在抛出错误是无效的。123456789const promise = new Promise(function(resolve, reject) &#123; resolve('ok'); // Promise 状态已变成 已完成 throw new Error('test');&#125;);promise .then(function(value) &#123; console.log(value) &#125;) .catch(function(error) &#123; console.log(error) &#125;);// ok 注意 一般来说，不要在 then 方法中定义 Reject 状态的回调函数（即 then 的第二个参数），而是使用 catch 方法。 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error&#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面 then 方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用 catch 方法，而不使用 then 方法的第二个参数。 5 Promise.all()Promise.all 方法是将多个 Promise 对象实例包装成一个新的实例。 1var p = Promise.all([p1, p2, p3]); 上面的代码中，Promise.all() 方法接受一个数组作为参数，p1, p2, p3 都是 Promise 对象的实例。如果不是，就会先调用下面讲到的 Promise.resolve 方法，将参数转换为 Promise 实例，再进一步处理（Promise.all 方法的参数不一定是数组，但是必须具有 Iterator 接口，且每个返回成员都是 Promise 实例）。 p 的状态由 p1, p2, p3 决定，分成两种情况 只有 p1, p2, p3 的状态都变成 FulFilled，p 的状态才会变成 FulFilled，此时 p1, p2, p3 的返回值组成一个数组，传递给 p 的回调函数。 只要 p1，p2，p3 中有一个被 Rejected ，p 的状态就直接变成 Rejected，此时第一个被 Rejected 的实例的返回值会传递给 p 的回调函数。 下面是一个具体例子。12345678910111213var promises = [2,3,4,5].map(function(id)&#123; console.log(id) &#125;); Promise.all(promises).then(function(res)&#123; console.log(res); resolve &#125;).catch(function(error)&#123; console.log(error); &#125;);// 先执行所有 promise 实例的异步操作，然后吧操作的结果打包数组返回// 2 3 4 5 [undefined,undefined,undefined,undefined] 上面的代码中，Promise 是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成 fulfilled，或者其中有 1 个变成 rejected，才会调用 Promise.all 方法后面的回调函数。 6 Promise.race()Promise.race 方法同样是将多个 Promise 实例包装成一个新的 Promise 实例。 1var p = Promise.race([p1, p2, p]) 上面的代码中，只要 p1, p2, p3 中 有一个实例 率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值就传递给 p 的回调函数。Promise.race 方法的参数与 Promise.all 方法一样，如果不是 Promise 实例，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。 下面是一个例子,如果指定时间内没有获得结果，就将 Promise 的状态变成 Rejected，否则就变为 Resolved。 12345678910const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error); 上面代码中，如果 5 秒之内 fetch 方法无法返回结果，变量 p 的状态就会变为 rejected，从而触发 catch 方法指定的回调函数。 7 Promise.resolve()有时需要将现有对象转为 Promise 对象，Promise.resolve 方法就起到这个作用。 1const jsPromise = Promise.resolve($.ajax('/whatever.json')); 上面代码将 jQuery 生成的 deferred 对象，转为一个新的 Promise 对象。 Promise.resolve 等价于下面的写法。 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.resolve方法的参数分成四种情况。 7.1 参数是一个 Promise 实例如果参数是一个 Promise 实例，那么 Promise.resolve 将不做任何修改，原封不动的返回这个实例。 7.2 参数是一个 thenable 对象thenable 对象是指具有 then 方法的对象，例如下面这个对象 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve 方法会将这个对象转为 Promise 对象，任何执行 thenable 对象的 then 方法。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 上面的代码中， thenable 对象的 then 方法执行后，对象 p1 的状态就变为 resolved，从而立即执行最后的 then 方法指定的回调函数。输出 42。 7.3 参数不是具有 then 方法的对象，或根本就不是对象如果参数是一个原始值，或者是一个不具有 then 方法的对象，那么 Promise.resolved 方法返回一个新的 Promise 对象，状态为 Resolved。 123456const p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello 上面代码生成一个新的 Promise 对象的实例 p。由于字符串 Hello 不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是 resolved，所以回调函数会立即执行。Promise.resolve 方法的参数，会同时传给回调函数。 7.4 不带有任何参数Promise.resolved 方法允许在调用时不带有参数，而直接返回一个 Resolved 状态的 Promise 对象。 所以，如果你希望得到一个 Promise 对象，比较方便的方法就是直接调用 Promise.resolve 方法。 12345const p = Promise.resolve();p.then(function () &#123; // ...&#125;); 上面代码中的 p 就是一个 Promise 对象。需要注意的是，立即 resolve 的 Promise 对象实在本轮 『事件循环』（event loop）结束时，而不是在下一轮『事件循环』开始时。 12345678910111213setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three 上面代码中，setTimeout(fn, 0) 在下一轮『事件循环』开始时执行，Promise.resolve() 在本轮『事件循环』结束时执行，console.log(&#39;one&#39;) 则是立即执行，因此最先输出。 8 Promise.reject()Promise.reject(resson) 方法也会返回一个新的 Promise 实例，状态为 Rejected （这个就暂时想不懂怎么应用了）。 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 上面的代码生成一个 Promise 对象的实例 p，状态为 Rejected，回调函数会立即执行。 总结以上就是关于 Promise 学习的内容，如有错误的地方就请在下面评论处，发表一下看法，当然也可以放一下关于进阶学习 Promise 的文章，大家一起学习。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongose 插件的简单使用]]></title>
    <url>%2F2018%2F10%2F23%2Fusing-mongoose%2F</url>
    <content type="text"><![CDATA[摘要 由于毕业设计要做小程序·云开发，它那边的云数据库是非关系数据库，所以就要用一下非关系型的数据库来开发了，这里的话，我就使用比较常用的 mongoDB 这个非关系型的数据库了。然后调用它的话一般使用 mongoose 这个插件来用，趁着做毕设，就学习一下怎么用这个家伙吧。 1 安装1npm i mongoose 2 使用2.1 连接 mongoDB在后台跑起来后或者是初始化请求的时候，引入mongoose，连接数据库，以我搭的 express 框架为例，在路由的 index 文件中连接数据库。 12345678910111213const mongoose = require('mongoose');/** * 连接 mongoDB 的 user 数据库 */mongoose.connect('mongodb://localhost/user');const db = mongoose.connection;// 连接失败db.on('error', console.error.bind(console, 'connection error:'));// 连接成功db.once('open', function() &#123; console.log("mongoDB connected success"); // we're connected!&#125;); 2.2 创建连接Mongoose 里，一切都始于 Schema。 现在我们来看一个我项目中例子。（鉴于篇幅，删减了哈） 123const user = new mongoose.Schema(&#123; userId:String&#125; 现在我们就创建了一个 带有 String 类型 userId 属性的 schema。接着我们需要把这个 schema 编译成一个 Model。通过这个 Model 我们就能够直接操纵数据库里面的数据了 1234/*model 的参数1 导出的模块名， 参数2 创建的 Schema，参数3 指定数据库中的集合的名字，若不加的，则抹默认取‘第一个参数s’的集合*/module.exports = mongoose.model('User',user,'user'); 2.3 做个小查询首先我们需要先引入模块 1const User = require('./../../models/user'); 接下来就是直接查询了 12345678// 获取 user 表中的所有数据User.find(function (err, doc) &#123; if (err)&#123; return console.error(err); &#125; // 打印查询到的内容，后面要怎么操作这些数据就看具体的业务需求了 console.log(doc);&#125;) 如果我们想获取特定的数据，这个时候就了解有一下 query 的用法了,下面给出一个简单的小例子。12// 这么写可以获取所有 name 为 "Fluff" 开头的数据,然后在 callback 里面去写怎么处理那些数据咯User.find(&#123; name: /^fluff/ &#125;, callback); 关于 mongoose 的简单使用就差不多这个样子了]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack3 迁移到 Webpack4]]></title>
    <url>%2F2018%2F10%2F16%2Fupdate-webpack4%2F</url>
    <content type="text"><![CDATA[为什么要迁移其实我是不知道的，只是实习的公司的项目要迁移，所以采取了解这方面的东西，公司的原因是由于公司项目越来越大，需要的依赖越来越多，导致开发的时候重新构建的时候速度十分缓慢，开发效率很低。 升级 webpack4 直奔主题，直接开始升级 首先升级 webpack4 到 4.8.1 （当然其他 4 的版本都是可以的），顺便安装一下 webpack-cli1npm install webpack@4.8.1 webpack-cli -D 然后我们 npm run dev 一下。 『报错啦！』 这个是因为 webpack 和 webpack-dev-server 版本不兼容，升级一下就好了 1npm install webpack-dev-server@3.1.4 -D 再次启动，又报错了。。。 这里是因为 html-webpack-plugin 版本不兼容导致的，网上给出的解决方案大部分是说执行 yarm add webpack-contrib/html-webpack-plugin -D 但是现在作者已经更新版本了，直接升级版本就可以了，不需要再去安装 webpack 官方的替代版本1npm install html-webpack-plugin@3.2.0 -D 再次启动，再次报错 升级一下 eslint 和 eslint-loader 吧1npm install eslint eslint-loader@2.0.0 -D 继续报错 升级 vue-loader 吧1npm install vue-loader@15.0.10 -D 错的更彻底了 这是因为新版的 vue-loader 需要加入一个新的配置 VueLoaderPlugin。所以要在下面这些文件修改一下配置。 1234567891011121314151617181920// webpack.dev.conf.js 文件// 引入 VueLoaderPluginconst &#123; VueLoaderPlugin &#125; = require('vue-loader')// 在下面的插件中添加 VueLoaderPlugin plugins: [ ... new VueLoaderPlugin(), ... ] // webpack.prod.conf.js 文件// 这个和上面的文件一样处理了// 引入 VueLoaderPluginconst &#123; VueLoaderPlugin &#125; = require('vue-loader')// 在下面的插件中添加 VueLoaderPlugin plugins: [ ... new VueLoaderPlugin(), ... ] 再来，再来 这个是 webpack4 需要指定一下打包的模式（mode），指定一下就好，直接该配置就行了。『不要慌，小问题』 1234567891011// webpack.dev.conf.js文件const devWebpackConfig = merge(baseWebpackConfig, &#123; mode: 'development', module: &#123;...&#125;&#125;,//同理在 webpack.prod.conf.js 文件const devWebpackConfig = merge(baseWebpackConfig, &#123; mode: 'production', module: &#123;...&#125;&#125;, 疲惫的手再次按起了 npm run dev 震惊！居然没错了，居然可以运行了。好的，webpack4 升级结束，撒花！！ 然而当我默默敲起了 npm run build 该错的终究还是要错的啊。。 这部分的错误是因为 webpack.optimize.CommonsChunkPlugin 已经被弃用，需要使用新的配置 config.optimization.splitChunks，在下面的文件再改一下配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// webpack.prod.conf.js 文件// 在 plugins 同级下添加下面代码optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; test: /[\\/]node_modules[\\/]/, name: 'vendor', chunks: 'all' &#125;, manifest: &#123; name: 'manifest', minChunks: Infinity &#125;, &#125; &#125;, &#125;, // 嗯，就在上面加这一段代码 plugins:[...] // 分割线// 再去掉该文件中 plugins 中的这部分代码 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks(module) &#123; // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, '../node_modules') ) === 0 ) &#125; &#125;), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', minChunks: Infinity &#125;), // This instance extracts shared chunks from code splitted chunks and bundles them // in a separate chunk, similar to the vendor chunk // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk new webpack.optimize.CommonsChunkPlugin(&#123; name: 'app', async: 'vendor-async', children: true, minChunks: 3 &#125;), ...// 不要客气，全删了，怕错就先注释掉呗。 让我们再次打包 『这个是大问题，要慌！』这个是因为官方已经不推荐使用 extract-text-webpack-plugin 提取 css 样式，可以使用 mini-css-extract-plugin 替代如果不想改变的话可以升级 extract-text-webpack-plugin 1&quot;extract-text-webpack-plugin&quot;: &quot;^4.0.0-beta.0&quot;, 但是，我们还是要用推荐的 mini-css-extract-plugin 首先安装一下插件1npm install mini-css-extract-plugin -D 记得去掉 package.json 中的包 “extract-text-webpack-plugin”: “^4.0.0-beta.0” 然后我们又来改配置了 1234567891011121314151617181920212223242526272829303132333435363738//build 里面的util.js 文件// 1 去掉 extract-text-webpack-pluginconst ExtractTextPlugin = require('extract-text-webpack-plugin') // 走好了您咧// 2 引入新大佬const MiniCssExtractPlugin = require('mini-css-extract-plugin')// 3 修改下面的 generateLoaders 函数// 删掉原来的即我注释的代码，修改成下面这个样子function generateLoaders (loader, loaderOptions) &#123; ... if (options.extract) &#123; // return ExtractTextPlugin.extract(&#123; // use: loaders, // fallback: 'vue-style-loader' // &#125;) return [MiniCssExtractPlugin.loader].concat(loaders) &#125; else &#123; return ['vue-style-loader'].concat(loaders) &#125;&#125;// webpack.prod.conf.js文件// 1 去掉 extract-text-webpack-plugin// 删这个const ExtractTextPlugin = require('extract-text-webpack-plugin') // 加下面的const MiniCssExtractPlugin = require('mini-css-extract-plugin')// 2 去掉 plugins 里的配置 new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].[contenthash].css'), allChunks: true, &#125;),// 3 在 plugins 加入新的插件配置 new MiniCssExtractPlugin(&#123; filename: utils.assetsPath('css/[name].[contenthash:12].css'), allChunks: true, &#125;), 最后再打包。。。 欢乐女神，圣洁美丽，webpack4 升级完成咧，如有其他问题，留言加百度，我们一起研究研究。]]></content>
      <categories>
        <category>项目经验</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>升级Webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则基础知识]]></title>
    <url>%2F2018%2F10%2F13%2Freg-knowledge%2F</url>
    <content type="text"><![CDATA[正则表达式1 定义正则12let reg = new RegExp("G");//RegExp对象，参数就是我们要制定的规则let reg = /G/; //一般写法，推荐使用，性能更好 2 常用方法 test()：在字符串中查找符合正则的内容，找到返回true，反之返回false 1234//判断数字是否有非数字let str ='1233456';let reg = /\D/;console.log(reg.test(str));//false exec() RegExp的exec()方法和String的match()方法很类似，它对一个指定的字符串执行一个正则表达式匹配，如果没有找到任何一个匹配，它将返回null，否则返回一个数组，这个数组的第一个元素包含的是与正则表达式相匹配的字符串,余下的所有元素包含的是匹配的各个分组。而且，正则表达式对象的index属性还包含了匹配发生的字符串的位置，属性input引用的则是被检索的字符串。如果正则表达式具有g标志，它将把该对象的lastIndex属性设置到紧接着匹配字符串的位置开始检索，如果exec()没有发现任何匹配，它将把lastIndex属性重置为0，这一特殊的行为可以使你可以反复调用exec()遍历一个字符串中所有的正则表达式匹配。1234let str5 = 'cat,fat,bat,sat,cct';let reg5 = /.at/g;reg5.lastIndex = 10;console.log(reg5.exec(str5));//[ 'cat', index: 0, input: 'cat,fat,bat,sat,cct' ] replace():查找符合正则的字符串，替换成对应的字符串 1234567891011121314//替换关键字let str4 = '七夕，JJ，我在月下等你';let reg4 = /七夕|JJ/g;/*str4 = str4.replace(reg4,'*');console.log(str4);//*，*，我在月下等你.有点问题啊，那么就不要直接替换，我们用个回调函数解决*/str4 = str4.replace(reg4,function (str4) &#123; let res = ''; for(let i =0;i&lt;str4.length;i++)&#123; res +='*'; &#125; return res;&#125;);console.log(str4);//**，**，我在月下等你 search():在字符串搜索符合正则的内容，搜索到就返回出现的位置注意：如果找到多个，则只会返回第一个找到的字符的位置，找不到就返回- 1234//在字符串中找到字母b，且不区分大小写let str2 = 'abcbdef';let reg2 = /B/gi;console.log(str2.search(reg2));//2 找到的第一个字符的位置 match():在字符串中搜索符合规则的内容，搜索成功就返回内容，反之则返回null 1234//找到指定格式的所有数字let str3 = 'haj123sdk54hask33dkhalsd879';let reg3 = /\d+/g;//每次至少匹配一个数字console.log(str3.match(reg3));//[ '123', '54', '33', '879' ] 3 常见字符 转义字符 这几个常见转义字符还是要的顺手记下滴12345678\s :空格\S :非空格\d :数字\D :非数字\w :字符（字母，数字，下划线那些）\W :非字符. :任意字符\. :真正的点 量词 123456&#123;n,m&#125; :出现n~m次&#123;n,&#125; :至少n次&#123;n&#125; :出现n次* :任意次? :1次或者0次，相当于&#123;0,&#125;+ :1~n次 其他符号 123456^ :匹配输入串的开始位置$ :匹配输入串的结束位置[] :[]里面的任意字符[^] :非[]里面的任意字符() :分组符，小括号中的项叫做正则的子项$1($n) :正则式中的第1（n）个子项]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置自己的github博客]]></title>
    <url>%2F2018%2F10%2F10%2Fdeploy-hexo%2F</url>
    <content type="text"><![CDATA[1 项目结构1.1 _config.yml网站的配置信息，在这边配置网站的大部分信息 1.2 scaffolds模板文件夹，新建文件会根据里面的模板创建新的文件 1.3 source资源文件夹是存放用户资源的地方，然后 _posts 是存放 markdown 文章的地方 1.4 themes主题文件夹，hexo 会根据主题生成静态文件夹。本次我们使用的主题是 Next 主题主题网站 2 _config.yml 的配置2.1 网站我们可以在 _config.yml 文件 中修改大部分的配置，具体咋配置，我就偷个懒了。直接贴中文文档的图了。其中，language 就设置为 zh-Hans 啦，毕竟咱还是用中文写博客的，当然如果有大佬想搞个国际化的全英博客的话就另当别论了。 description 主要用于SEO，告诉搜索引擎一个关于我们站点的简单描述，官方是推荐在里面写我们站点的关键字，主题啥的，但是个人咧还是比较喜欢直接写个个人签名╭(╯^╰)╮ author 参数就是来说这个博客的是谁家的孩子啦。 2.2 网址如果你的网站存放在子目录中，例如 http://yoursite.com/blog，则请将你的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 2.3 目录这里是高端局，我这种菜鸡就老老实实跟着官方走，不乱改了。 2.4 文章默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 example.com，您有一篇文章名为 hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 2.5 其他 3 其他配置3.1 标签、分类、关于设置仔细看了一下上面关于目录的配置，然后又看了其他人的 hexo 博客，心头是不是一阵疑惑，咦，咋感觉自己少了那么多目录结构咧。咋整啊？自己装呗。123hexo new page &quot;tags&quot;hexo new page &quot;categories&quot;hexo new page &quot;about&quot; 执行完这三条命令后，在站点的source 的目录下就生成了 tags，about，categories 三个文件夹然后就分别到 source 文件夹中新生成的 about 文件夹里面的 index.md 中添加下面的代码type: “tags”重新运行之后是不是就出来了，什么？出不来？好吧，我错了，这样的话就要去看你选择的 theme 里面的配置了，把 menu 里面对这三个菜单项的注释去掉，就可以了。再不行的话，那就那就，百度吧。 3.2 关联到 github pages 修改 _config.yml, 在文件最底部添加如下代码 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: ssh://git@github.com/你的github名/你的github名.github.io.git branch: master 安装一个 hexo 插件 1npm install hexo-deployer-git --save 部署项目，就直接运行下面三条命令就行了 123hexo clean // 清除原来打包的项目hexo g // 生成新的项目hexo d // 上传项目到github 最后的最后，让我们打开浏览器，输入 https://你的github用户名.github.io，例如我的 https://lijiayuan365.github.io\ 4 真正的最后强烈推荐下面这位大佬的博客 Hexo 博客主题的设置与完善，可以说是相当的全面与仔细了，快速配置好你的博客。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>配置博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2018%2F08%2F26%2Fflex-knowledge%2F</url>
    <content type="text"><![CDATA[语法篇一、flex是啥?flex即Flexible Box，意为弹性盒布局，用来为盒状模型提供最大的灵活性。（任何一个容器都可以被指定为flex布局）用法：display:flex 注意设置为flex布局之后，子元素的float，clear，vertical-align属性将失效 二、基本概念采用flex布局的元素，称为flex容器（flex container）简称“容器”，它的所有子元素自动成为容器成员，称为flex项目（flex item），简称“项目”。容器默认存在两根轴，水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start,结束位置叫做mainend；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列，单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下有六个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性flex-direction属性决定主轴方向（即项目的排列方向）它可能有四个值 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称轴线）上，flex-wrap属性定义，如果一条轴线排不下，如何换行。它可能取三个值 nowrap(默认)：不换行 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方 3.3 flex-flowflex-flow属性是flex-direction属性与flex-wrap属性的简写形式，默认值为row nowrap（水平排列，不换行） 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。（主轴如果是水平的话，那么就是定义项目是否水平居中那些的了）它可能取5个值，具体对齐方式与主轴的方向有关，下面假设主轴为从左到右 flex-start（默认值）：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等。所以，每个项目之间的间隔比项目与边框的间隔大一倍 3.5 align-items属性align-it属性定义项目在交叉轴上如何对齐。（默认的就是垂直方向的居中那些问题啦）它可能有五个值 flex-start:交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐（一般的话就是垂直居中啦） baseline：项目的第一行文字的基线对齐。 stretch（默认）：如果项目未设置高度或设为auto，将占满整个容器的高度 3.6 align-content属性align-content属性定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用它可能的值有 flex-start：与交叉轴的起点对齐 flex-end：与交叉轴的终点对齐 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间平均分布 space-around:每根轴线两侧的间隔都相等，所以轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink blex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序，数值越小，排列越靠前，默认为0. 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 注 如果所有的项目的flex-grow属性都为一，则它们将等分剩余空间(如果有的话)，如果每个项目的属性值不同，那么首先就是先把剩余空间等分成所有项目flex-grow值之和份，然后每个项目根据自己的flex-grow值分剩余空间。例：三个项目，两个flex-grow值为1，一个值为2，则将剩余空间4等份，其中那个flex-grow值为2的项目分得2/4的剩余空间 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 注如果所有项目的flex-shrink属性都为1负值对该属性无效 4.4 flex-basis属性flex-basis属性定义了再分配多余空间之前，项目占据主轴的空间。浏览器根据这个属性，计算主轴是否有多余的空间，它默认为auto，即项目的本来大小。 4.5flex属性flex属性是flex-grow，flex-shrink，flex-basis的简写，默认值为0 1 auto，后两个属性可选。（一般也是直接用这个） 该属性有两个快捷键值：auto（1 1 auto）和none（0 0 auto）然后肯定推荐用这个啦。 4.6 align-self属性align-self属性允许单个项目有着与其他项目不一样的对齐方式，可覆盖align-item属性，默认为auto，表示继承父元素的align-items属性，如果没有父元素，等同于stretch。该属性和容器的align-items属性一样可能取6个值，除了auto，其他都和它一样。 后记本文学习自阮一峰老师的flex布局教程语法篇（完）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端布局</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则练习题]]></title>
    <url>%2F2018%2F06%2F30%2Freg-trian%2F</url>
    <content type="text"><![CDATA[前言我们在上次说到了一些关于正则表达式的基本知识，然后学啥东西都一样，要会用，不然干看着概念，就算你厉害把所有的知识点都背下来了，但是一段时间不看就会忘记了，所以咧，还是要找一点题练一下，这次的话就随便找了几道我做项目的时候做的正则的题型，权当复习吧邮箱校验 要求：能够识别判断当前使用比较多的免费邮箱，企业邮箱不熟，以后再考虑1234let demo = "123@qq.com";let pataern = /^[a-zA-Z0-9_.]+@[a-zA-Z0-9-]+(\.[a-zA-Z0-9]+)*\.[a-zA-Z0-9]&#123;2,6&#125;/;let res = pataern.test(demo);console.log(res);//true 账户姓名校验 要求：1-n个以字母开头的字符串12345678910const n = 5;let user1 = 'ssh';let user2 = '1word';function UserName(user) &#123; let reg = /^[a-zA-Z][a-zA-Z0-9_]&#123;0,4&#125;$/; let result = reg.test(user); return result;&#125;console.log(UserName(user1));//trueconsole.log(UserName(user2));//false 密码校验 要求：6-12字母、数字、下划线123456789let pwd1 = 's';let pwd2 = '1_word';function Password(pwd) &#123; let reg = /[a-zA-Z0-9_]&#123;6,12&#125;$/; let result = reg.test(pwd); return result;&#125;console.log(Password(pwd1));//falseconsole.log(Password(pwd2));//true 格式化金额 要求：将数字转换为形如￥2,000.12的形式1let 获取金额中的有效数字 要求：将￥2,000.20中的有效数字提取出来，如2000.2123456789let str = `CNY 1,000.0`;function tiqu(str)&#123; let reg = /[^0-9\.]/g;//去掉货币符号和逗号 str = str.replace(reg,''); str = parseFloat(str);//如果去掉无效的小数数据 return str;&#125;let res = tiqu(str);console.log(res);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>正则</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建自己的github博客]]></title>
    <url>%2F2018%2F06%2F25%2Fbuild-hexo%2F</url>
    <content type="text"><![CDATA[1 什么是 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2 开始搭建博客2.1 前提电脑安装好 Node 和 Git 2.2 安装直接用 npm 全局安装（嫌慢的话就用 cnpm 吧）1npm install -g hexo-cli 2.3 搭建博客网站完成 Hexo 的安装之后，就可以执行下面的命令，在指定文件夹内生成系列的网站文件123hexo init folderNamecd folderNamenpm install // 安装依赖 注意好像新版本的 hexo-cli 在初始化项目的时候会自动安装依赖，如下图 鉴于网络因素，直接用npm 安装依赖实在是太慢了，想快一点的同学看到他在装依赖的时候，不要怂，直接就是 Ctrl+C 断了它进程，然后自己进入文件夹用 cnpm install 装依赖。 3 查看效果运行下面代码，开启博客1hexo server 最后打开4000端口就可以看到自己的博客网站啦 4 项目结构新建个项目之后，指定的文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 4.1 _config.yml网站的 配置 信息，小伙伴们可以在这边配置大部分的参数。 4.2 package.json这个就不说了，就是这个项目的信息了。 4.3 scaffold 文件夹模板 文件夹。当我们新建文章的时候，Hexo 会根据 scaffold 来建议文件 Hexo 的模板是指在新建的 markdown 文件中默认填充的内容。例如，如果我们修改 scaffold/post.md 中的 Front-matter 内容，那么没一次新建一篇文章都会包含这个修改 4.4 source 文件夹资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _(下划线)的文件/文件夹和隐藏的文件将会被忽略（意思就是在这里不要以下划线开头去命名新建的文件/文件夹）。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 4.5 themes 文件夹主题 文件夹。Hexo会根据主题来生成静态页面。这里的话，推荐一个主题吧。 next 我也不知道为啥要推荐它，反正就瞅他顺眼+多人用+文档全吧。不过想用其他也随便吧，反正写博客嘛，咱们还是多关注内容，外观的话，顺眼舒服就行了。 5 开始写博客这个就很简单了，三步走直接搞定啦。 直接找个能写 markdown 的工具就开始写我们的博客了。这里的话我推荐用一下 『有道云笔记』吧（『有道云笔记』的工作人员看到了麻烦给点广告费啊~(@^_^@)~），平常就可以在上面做做笔记，写写博客，写完直接导出来一个 markdown 文件。当然其他编辑器一般也是可以方便的写 markdown 的。 『注意：这里有道云笔记有个坑点，不是会员不给 markdown 引入本地的图片，如果想用图片的话只能引入网上外链，这时候就要使用图床了，这边推荐用一下『七牛云』吧，有免费 10 G 的空间可以用。（『七牛云』的小姐姐看到麻烦给我叫个鸡腿），里面还有一些使用技巧，这里就不说了，大家自己再去百度玩一下吧。』 将写完的 markdowm 文件直接丢到 source/_posts 文件夹内，但是为了方便分类和管理自己的文章，在导出的 markdown 文件加入下面这些东西 1234567891011---#文章标题title: flex布局#文章发布时间date: 2018-08-26 21:37:55#文章的标签，可多写几个tags: 前端布局#文章分类categories: flex---#下面就是我们的文章正文啦 上面然后就可以在我们的站点中看到我们新增的博客啦。 6 后续讲到这里，我们的博客已经搭建起来的了，如果还有不明白的东西可以去翻翻 hexo 中文文档。最后咧，虽然博客搭起来了，也能写了，但是不自己配置一下的话，还是有点简陋的，所以下次就来讲讲如何去配置我们的 Hexo 博客吧。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
</search>
